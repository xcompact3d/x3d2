var tipuesearch = {"pages":[{"title":" x3d2 ","text":"x3d2 This project is a rewrite of Xcompact3d leading to Improved serial and parallel performance. Support for NVIDIA GPU accelerators (using CUDA Fortran). Improved modularity and testability.\" Developer Info Xcompact3d Team","tags":"home","url":"index.html"},{"title":"io_manager_t – x3d2 ","text":"type, public :: io_manager_t Inherits type~~io_manager_t~~InheritsGraph type~io_manager_t io_manager_t type~checkpoint_manager_t checkpoint_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~snapshot_manager_t snapshot_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~checkpoint_config_t checkpoint_config_t type~checkpoint_manager_t->type~checkpoint_config_t config type~field_buffer_map_t field_buffer_map_t type~checkpoint_manager_t->type~field_buffer_map_t field_buffers type~snapshot_manager_t->type~checkpoint_config_t config type~snapshot_manager_t->type~field_buffer_map_t field_buffers type~writer_session_t writer_session_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~base_config_t base_config_t type~checkpoint_config_t->type~base_config_t type~io_session_base_t io_session_base_t type~writer_session_t->type~io_session_base_t type~io_writer_t io_writer_t type~writer_session_t->type~io_writer_t writer type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~io_manager_t~~InheritedByGraph type~io_manager_t io_manager_t type~base_case_t base_case_t type~base_case_t->type~io_manager_t checkpoint_mgr type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( checkpoint_manager_t ), public :: checkpoint_mgr type( snapshot_manager_t ), public :: snapshot_mgr Type-Bound Procedures procedure, public :: init => io_init private  subroutine io_init(self, comm) Arguments Type Intent Optional Attributes Name class( io_manager_t ), intent(inout) :: self integer, intent(in) :: comm procedure, public :: handle_restart => io_handle_restart private  subroutine io_handle_restart(self, solver, comm) Arguments Type Intent Optional Attributes Name class( io_manager_t ), intent(inout) :: self class( solver_t ), intent(inout) :: solver integer, intent(in), optional :: comm procedure, public :: handle_io_step => io_handle_step private  subroutine io_handle_step(self, solver, timestep, comm) Arguments Type Intent Optional Attributes Name class( io_manager_t ), intent(inout) :: self class( solver_t ), intent(in) :: solver integer, intent(in) :: timestep integer, intent(in), optional :: comm procedure, public :: finalise => io_finalise private  subroutine io_finalise(self) Arguments Type Intent Optional Attributes Name class( io_manager_t ), intent(inout) :: self procedure, public :: is_restart => io_is_restart private  function io_is_restart(self) result(is_restart) Arguments Type Intent Optional Attributes Name class( io_manager_t ), intent(in) :: self Return Value logical","tags":"","url":"type/io_manager_t.html"},{"title":"base_config_t – x3d2 ","text":"type, public, abstract :: base_config_t All config types have a method read to initialise their data Inherited by type~~base_config_t~~InheritedByGraph type~base_config_t base_config_t type~channel_config_t channel_config_t type~channel_config_t->type~base_config_t type~checkpoint_config_t checkpoint_config_t type~checkpoint_config_t->type~base_config_t type~cylinder_config_t cylinder_config_t type~cylinder_config_t->type~base_config_t type~domain_config_t domain_config_t type~domain_config_t->type~base_config_t type~solver_config_t solver_config_t type~solver_config_t->type~base_config_t type~case_channel_t case_channel_t type~case_channel_t->type~channel_config_t channel_cfg type~base_case_t base_case_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~cylinder_config_t cylinder_cfg type~case_cylinder_t->type~base_case_t type~checkpoint_manager_t checkpoint_manager_t type~checkpoint_manager_t->type~checkpoint_config_t config type~snapshot_manager_t snapshot_manager_t type~snapshot_manager_t->type~checkpoint_config_t config type~io_manager_t io_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~base_case_t->type~io_manager_t checkpoint_mgr type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( read ), public, deferred :: read subroutine read(self, nml_file, nml_string) Prototype Assigns the member variables either from a file or text source. nml_file can be an absolute or relative path\nnml_string is a character string that contains the namelist.\nFor example, nml_string=\"&foobar_nml foo=0, bar='this'/\" Arguments Type Intent Optional Attributes Name class( base_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string","tags":"","url":"type/base_config_t.html"},{"title":"domain_config_t – x3d2 ","text":"type, public, extends( base_config_t ) :: domain_config_t Inherits type~~domain_config_t~~InheritsGraph type~domain_config_t domain_config_t type~base_config_t base_config_t type~domain_config_t->type~base_config_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=30), public :: flow_case_name real(kind=dp), public :: L_global (3) integer, public :: dims_global (3) integer, public :: nproc_dir (3) character(len=20), public :: BC_x (2) character(len=20), public :: BC_y (2) character(len=20), public :: BC_z (2) character(len=20), public :: stretching (3) real(kind=dp), public :: beta (3) Type-Bound Procedures procedure, public :: read => read_domain_nml public  subroutine read_domain_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( domain_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string","tags":"","url":"type/domain_config_t.html"},{"title":"solver_config_t – x3d2 ","text":"type, public, extends( base_config_t ) :: solver_config_t Inherits type~~solver_config_t~~InheritsGraph type~solver_config_t solver_config_t type~base_config_t base_config_t type~solver_config_t->type~base_config_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: Re real(kind=dp), public :: dt logical, public :: ibm_on real(kind=dp), public, dimension(:), allocatable :: pr_species integer, public :: n_iters integer, public :: n_output integer, public :: n_species logical, public :: lowmem_transeq logical, public :: lowmem_fft character(len=3), public :: poisson_solver_type character(len=3), public :: time_intg character(len=30), public :: der1st_scheme character(len=30), public :: der2nd_scheme character(len=30), public :: interpl_scheme character(len=30), public :: stagder_scheme Type-Bound Procedures procedure, public :: read => read_solver_nml public  subroutine read_solver_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( solver_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string","tags":"","url":"type/solver_config_t.html"},{"title":"channel_config_t – x3d2 ","text":"type, public, extends( base_config_t ) :: channel_config_t Inherits type~~channel_config_t~~InheritsGraph type~channel_config_t channel_config_t type~base_config_t base_config_t type~channel_config_t->type~base_config_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~channel_config_t~~InheritedByGraph type~channel_config_t channel_config_t type~case_channel_t case_channel_t type~case_channel_t->type~channel_config_t channel_cfg Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: noise real(kind=dp), public :: omega_rot logical, public :: rotation integer, public :: n_rotate Type-Bound Procedures procedure, public :: read => read_channel_nml public  subroutine read_channel_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( channel_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string","tags":"","url":"type/channel_config_t.html"},{"title":"cylinder_config_t – x3d2 ","text":"type, public, extends( base_config_t ) :: cylinder_config_t Inherits type~~cylinder_config_t~~InheritsGraph type~cylinder_config_t cylinder_config_t type~base_config_t base_config_t type~cylinder_config_t->type~base_config_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~cylinder_config_t~~InheritedByGraph type~cylinder_config_t cylinder_config_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~cylinder_config_t cylinder_cfg Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: init_noise (3) Type-Bound Procedures procedure, public :: read => read_cylinder_nml public  subroutine read_cylinder_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( cylinder_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string","tags":"","url":"type/cylinder_config_t.html"},{"title":"checkpoint_config_t – x3d2 ","text":"type, public, extends( base_config_t ) :: checkpoint_config_t Inherits type~~checkpoint_config_t~~InheritsGraph type~checkpoint_config_t checkpoint_config_t type~base_config_t base_config_t type~checkpoint_config_t->type~base_config_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~checkpoint_config_t~~InheritedByGraph type~checkpoint_config_t checkpoint_config_t type~checkpoint_manager_t checkpoint_manager_t type~checkpoint_manager_t->type~checkpoint_config_t config type~snapshot_manager_t snapshot_manager_t type~snapshot_manager_t->type~checkpoint_config_t config type~io_manager_t io_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~base_case_t base_case_t type~base_case_t->type~io_manager_t checkpoint_mgr type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: checkpoint_freq = 0 Frequency of checkpointing (0 = off) integer, public :: snapshot_freq = 0 Frequency of snapshots (0 = off) logical, public :: keep_checkpoint = .true. If false, only keep latest checkpoint character(len=256), public :: checkpoint_prefix = \"checkpoint\" character(len=256), public :: snapshot_prefix = \"snapshot\" logical, public :: restart_from_checkpoint = .false. character(len=256), public :: restart_file = \"\" integer, public, dimension(3) :: output_stride = [2, 2, 2] Spatial stride for snapshot output logical, public :: snapshot_sp = .false. if true, snapshot in single precision Type-Bound Procedures procedure, public :: read => read_checkpoint_nml public  subroutine read_checkpoint_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( checkpoint_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string","tags":"","url":"type/checkpoint_config_t.html"},{"title":"case_generic_t – x3d2 ","text":"type, public, extends( base_case_t ) :: case_generic_t Inherits type~~case_generic_t~~InheritsGraph type~case_generic_t case_generic_t type~base_case_t base_case_t type~case_generic_t->type~base_case_t type~io_manager_t io_manager_t type~base_case_t->type~io_manager_t checkpoint_mgr type~solver_t solver_t type~base_case_t->type~solver_t solver type~checkpoint_manager_t checkpoint_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~snapshot_manager_t snapshot_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~allocator_t allocator_t type~solver_t->type~allocator_t host_allocator type~base_backend_t base_backend_t type~solver_t->type~base_backend_t backend type~dirps_t dirps_t type~solver_t->type~dirps_t xdirps, ydirps, zdirps type~field_t field_t type~solver_t->type~field_t u, v, w type~flist_t flist_t type~solver_t->type~flist_t species type~ibm_t ibm_t type~solver_t->type~ibm_t ibm type~mesh_t mesh_t type~solver_t->type~mesh_t mesh type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~allocator_t->type~field_t first type~base_backend_t->type~allocator_t allocator type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~checkpoint_config_t checkpoint_config_t type~checkpoint_manager_t->type~checkpoint_config_t config type~field_buffer_map_t field_buffer_map_t type~checkpoint_manager_t->type~field_buffer_map_t field_buffers type~tdsops_t tdsops_t type~dirps_t->type~tdsops_t der1st, der1st_sym, der2nd, der2nd_sym, stagder_v2p, stagder_p2v, interpl_v2p, interpl_p2v type~field_t->type~field_t next type~flist_t->type~field_t ptr type~ibm_t->type~allocator_t host_allocator type~ibm_t->type~base_backend_t backend type~ibm_t->type~field_t ep1 type~ibm_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~snapshot_manager_t->type~checkpoint_config_t config type~snapshot_manager_t->type~field_buffer_map_t field_buffers type~writer_session_t writer_session_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~time_intg_t->type~allocator_t allocator type~time_intg_t->type~base_backend_t backend type~time_intg_t->type~flist_t olds type~vector_calculus_t->type~base_backend_t backend type~base_config_t base_config_t type~checkpoint_config_t->type~base_config_t type~poisson_fft_t->type~mesh_t mesh type~io_session_base_t io_session_base_t type~writer_session_t->type~io_session_base_t type~io_writer_t io_writer_t type~writer_session_t->type~io_writer_t writer type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr Constructor public        interface case_generic_t public  function case_generic_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_generic_t ) Type-Bound Procedures procedure, public :: case_init public  subroutine case_init (self, backend, mesh, host_allocator) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator procedure, public :: case_finalise public  subroutine case_finalise (self) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self procedure, public :: set_init public  subroutine set_init (self, field, field_func) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: field public pure function field_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) procedure, public :: run public  subroutine run (self) Runs the solver forwards in time from t=t_0 to t=T, performing\npostprocessing/IO and reporting diagnostics. Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(inout) :: self procedure, public :: print_enstrophy public  subroutine print_enstrophy (self, u, v, w) Reports the enstrophy Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: print_div_max_mean public  subroutine print_div_max_mean (self, u, v, w) Reports the div(u) at cell centres Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: boundary_conditions => boundary_conditions_generic public  subroutine boundary_conditions_generic (self) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self procedure, public :: initial_conditions => initial_conditions_generic public  subroutine initial_conditions_generic (self) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self procedure, public :: forcings => forcings_generic public  subroutine forcings_generic (self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter procedure, public :: pre_correction => pre_correction_generic public  subroutine pre_correction_generic (self, u, v, w) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w procedure, public :: postprocess => postprocess_generic public  subroutine postprocess_generic (self, iter, t) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t","tags":"","url":"type/case_generic_t.html"},{"title":"reader_session_t – x3d2 ","text":"type, public, extends(../../../io_session_base_t) :: reader_session_t PRIMARY TYPE FOR READING DATA - Use this for all file reading operations\nThis is the only interface users should use for reading data.\nProvides type-safe reading operations with automatic backend selection. Usage example:\n  type(reader_session_t) :: reader_session\n  call reader_session%open(\"checkpoint.bp\", MPI_COMM_WORLD)\n  call reader_session%read_data(\"timestep\", timestep)\n  call reader_session%read_data(\"velocity_u\", u_field, start_dims, count_dims)\n  call reader_session%close() Inherits type~~reader_session_t~~InheritsGraph type~reader_session_t reader_session_t type~io_reader_t io_reader_t type~reader_session_t->type~io_reader_t reader type~io_session_base_t io_session_base_t type~reader_session_t->type~io_session_base_t type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Finalization Procedures final :: reader_session_finaliser private  subroutine reader_session_finaliser(self) Finalisation for reader_session_t\nCalled automatically when a reader_session_t goes out of scope\nEnsures proper cleanup even if user forgets to call close Arguments Type Intent Optional Attributes Name type( reader_session_t ) :: self Type-Bound Procedures procedure, public :: is_session_open private  function is_session_open(self) Arguments Type Intent Optional Attributes Name class(io_session_base_t), intent(in) :: self Return Value logical procedure, public :: is_session_functional private  function is_session_functional(self) Arguments Type Intent Optional Attributes Name class(io_session_base_t), intent(in) :: self Return Value logical procedure, public :: close => session_base_close private  subroutine session_base_close(self) Arguments Type Intent Optional Attributes Name class(io_session_base_t), intent(inout) :: self procedure, public :: open => reader_session_open private  subroutine reader_session_open(self, filename, comm) Arguments Type Intent Optional Attributes Name class( reader_session_t ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(in) :: comm generic, public :: read_data => read_data_i8, read_data_integer, read_data_real, read_data_array_3d private  subroutine read_data_i8(self, variable_name, value) Arguments Type Intent Optional Attributes Name class( reader_session_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name integer(kind=i8), intent(out) :: value private  subroutine read_data_integer(self, variable_name, value) Arguments Type Intent Optional Attributes Name class( reader_session_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name integer, intent(out) :: value private  subroutine read_data_real(self, variable_name, value) Arguments Type Intent Optional Attributes Name class( reader_session_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(out) :: value private  subroutine read_data_array_3d(self, variable_name, array, start_dims, count_dims, shape_dims) Arguments Type Intent Optional Attributes Name class( reader_session_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(inout) :: array (:,:,:) integer(kind=i8), intent(in), optional :: start_dims (3) integer(kind=i8), intent(in), optional :: count_dims (3) integer(kind=i8), intent(in), optional :: shape_dims (3)","tags":"","url":"type/reader_session_t.html"},{"title":"writer_session_t – x3d2 ","text":"type, public, extends(../../../io_session_base_t) :: writer_session_t PRIMARY TYPE FOR WRITING DATA - Use this for all file writing operations\nThis is the only interface users should use for writing data.\nProvides type-safe writing operations with automatic backend selection. Usage example:\n  type(writer_session_t) :: writer_session\n  call writer_session%open(\"output.bp\", MPI_COMM_WORLD)\n  call writer_session%write_data(\"timestep\", current_step)\n  call writer_session%write_data(\"pressure\", p_field, start_dims, count_dims)\n  call writer_session%close()\n  call writer_session%write_attribute(\"ParaView\", \"vtk_xml_content\")\n  call writer_session%close() Inherits type~~writer_session_t~~InheritsGraph type~writer_session_t writer_session_t type~io_session_base_t io_session_base_t type~writer_session_t->type~io_session_base_t type~io_writer_t io_writer_t type~writer_session_t->type~io_writer_t writer type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~writer_session_t~~InheritedByGraph type~writer_session_t writer_session_t type~snapshot_manager_t snapshot_manager_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~io_manager_t io_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~base_case_t base_case_t type~base_case_t->type~io_manager_t checkpoint_mgr type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Finalization Procedures final :: writer_session_finaliser private  subroutine writer_session_finaliser(self) Finalisation for writer_session_t\nCalled automatically when a writer_session_t goes out of scope\nEnsures proper cleanup even if user forgets to call close Arguments Type Intent Optional Attributes Name type( writer_session_t ) :: self Type-Bound Procedures procedure, public :: is_session_open private  function is_session_open(self) Arguments Type Intent Optional Attributes Name class(io_session_base_t), intent(in) :: self Return Value logical procedure, public :: is_session_functional private  function is_session_functional(self) Arguments Type Intent Optional Attributes Name class(io_session_base_t), intent(in) :: self Return Value logical procedure, public :: close => session_base_close private  subroutine session_base_close(self) Arguments Type Intent Optional Attributes Name class(io_session_base_t), intent(inout) :: self procedure, public :: open => writer_session_open private  subroutine writer_session_open(self, filename, comm) Arguments Type Intent Optional Attributes Name class( writer_session_t ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(in) :: comm procedure, public :: begin_step => writer_session_begin_step private  subroutine writer_session_begin_step(self) Begin a new timestep for writing (used for time-series in single file) Arguments Type Intent Optional Attributes Name class( writer_session_t ), intent(inout) :: self procedure, public :: end_step => writer_session_end_step private  subroutine writer_session_end_step(self) End the current timestep for writing Arguments Type Intent Optional Attributes Name class( writer_session_t ), intent(inout) :: self generic, public :: write_data => write_data_i8, write_data_integer, write_data_real, write_data_array_3d private  subroutine write_data_i8(self, variable_name, value) Arguments Type Intent Optional Attributes Name class( writer_session_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name integer(kind=i8), intent(in) :: value private  subroutine write_data_integer(self, variable_name, value) Arguments Type Intent Optional Attributes Name class( writer_session_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name integer, intent(in) :: value private  subroutine write_data_real(self, variable_name, value, use_sp) Arguments Type Intent Optional Attributes Name class( writer_session_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(in) :: value logical, intent(in), optional :: use_sp private  subroutine write_data_array_3d(self, variable_name, array, shape_dims, start_dims, count_dims, use_sp) Arguments Type Intent Optional Attributes Name class( writer_session_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(in) :: array (:,:,:) integer(kind=i8), intent(in) :: shape_dims (3) integer(kind=i8), intent(in) :: start_dims (3) integer(kind=i8), intent(in) :: count_dims (3) logical, intent(in), optional :: use_sp procedure, public :: write_attribute => session_write_attribute private  subroutine session_write_attribute(self, attribute_name, attribute_value) Arguments Type Intent Optional Attributes Name class( writer_session_t ), intent(inout) :: self character(len=*), intent(in) :: attribute_name character(len=*), intent(in) :: attribute_value","tags":"","url":"type/writer_session_t.html"},{"title":"omp_backend_t – x3d2 ","text":"type, public, extends( base_backend_t ) :: omp_backend_t Inherits type~~omp_backend_t~~InheritsGraph type~omp_backend_t omp_backend_t type~base_backend_t base_backend_t type~omp_backend_t->type~base_backend_t type~allocator_t allocator_t type~base_backend_t->type~allocator_t allocator type~mesh_t mesh_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~field_t field_t type~allocator_t->type~field_t first type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~poisson_fft_t->type~mesh_t mesh type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n_halo = 4 DistD2 implementation is hardcoded for 4 halo layers for all backends type( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_e Constructor public        interface omp_backend_t public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self procedure, public :: get_field_data public  subroutine get_field_data (self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) procedure, public :: set_field_data public  subroutine set_field_data (self, f, data, dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian) procedure, public :: alloc_tdsops => alloc_omp_tdsops public  subroutine alloc_omp_tdsops (self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: transeq_x => transeq_x_omp public  subroutine transeq_x_omp (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_y => transeq_y_omp public  subroutine transeq_y_omp (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_z => transeq_z_omp public  subroutine transeq_z_omp (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_species => transeq_species_omp public  subroutine transeq_species_omp (self, dspec, uvw, spec, nu, dirps, sync) Compute the convection and diffusion for the given field\nin the given direction.\nHalo exchange for the given field is necessary\nWhen sync is true, halo exchange of momentum is necessary Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync procedure, public :: tds_solve => tds_solve_omp public  subroutine tds_solve_omp (self, du, u, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops procedure, public :: reorder => reorder_omp public  subroutine reorder_omp (self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction procedure, public :: sum_yintox => sum_yintox_omp public  subroutine sum_yintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure, public :: sum_zintox => sum_zintox_omp public  subroutine sum_zintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure, public :: veccopy => veccopy_omp public  subroutine veccopy_omp (self, dst, src) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src procedure, public :: vecadd => vecadd_omp public  subroutine vecadd_omp (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure, public :: vecmult => vecmult_omp public  subroutine vecmult_omp (self, y, x) m_base_backend Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x procedure, public :: scalar_product => scalar_product_omp public  function scalar_product_omp (self, x, y) result(s) m_base_backend Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure, public :: field_max_mean => field_max_mean_omp public  subroutine field_max_mean_omp (self, max_val, mean_val, f, enforced_data_loc) m_base_backend Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc procedure, public :: field_scale => field_scale_omp public  subroutine field_scale_omp (self, f, a) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a procedure, public :: field_shift => field_shift_omp public  subroutine field_shift_omp (self, f, a) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a procedure, public :: field_set_face => field_set_face_omp public  subroutine field_set_face_omp (self, f, c_start, c_end, face) m_base_backend Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face procedure, public :: field_volume_integral => field_volume_integral_omp public  function field_volume_integral_omp (self, f) result(s) volume integral of a field Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) procedure, public :: copy_data_to_f => copy_data_to_f_omp public  subroutine copy_data_to_f_omp (self, f, data) Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data procedure, public :: copy_f_to_data => copy_f_to_data_omp public  subroutine copy_f_to_data_omp (self, data, f) Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f procedure, public :: init_poisson_fft => init_omp_poisson_fft public  subroutine init_omp_poisson_fft (self, mesh, xdirps, ydirps, zdirps, lowmem) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem procedure, public :: transeq_omp_dist public  subroutine transeq_omp_dist (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps","tags":"","url":"type/omp_backend_t.html"},{"title":"allocator_t – x3d2 ","text":"type, public :: allocator_t An instance of type allocator_t is responsible for the\nmaintenance of a linked list of instances of equal size m_allocator objects: ---- ---- ---- ---- ---- ---- ... -->| id = 1 | data | next |-->| id = 0 | data | next |--> null () ---- ---- ---- ---- ---- ---- the last block's next pointer being non associated. User code can request access to a memory block by using the\ntype bound procedure get_block .  If the list is\nnot empty, a pointer to the first block on the list is\nreturned and the block is detached from the list.  If the list\nis empty (i.e. all initially allocated blocks are currently\nreferenced to) then a new block is allocated before a pointer\nto it is returned. In order to reuse memory it is important that user code\nrelease blocks when they are not needed anymore.  This is done\nby calling the type bound procedure release_block .  The\nreleased block is then pushed in front of the block list. Inherits type~~allocator_t~~InheritsGraph type~allocator_t allocator_t type~field_t field_t type~allocator_t->type~field_t first type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~allocator_t~~InheritedByGraph type~allocator_t allocator_t type~base_backend_t base_backend_t type~base_backend_t->type~allocator_t allocator type~cuda_allocator_t cuda_allocator_t type~cuda_allocator_t->type~allocator_t type~ibm_t ibm_t type~ibm_t->type~allocator_t host_allocator type~ibm_t->type~base_backend_t backend type~solver_t solver_t type~solver_t->type~allocator_t host_allocator type~solver_t->type~base_backend_t backend type~solver_t->type~ibm_t ibm type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~time_intg_t->type~allocator_t allocator type~time_intg_t->type~base_backend_t backend type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~cuda_backend_t cuda_backend_t type~cuda_backend_t->type~base_backend_t type~omp_backend_t omp_backend_t type~omp_backend_t->type~base_backend_t type~vector_calculus_t->type~base_backend_t backend type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ngrid integer, public :: sz integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( field_t ), public, pointer :: first => null() The pointer to the first block on the list.  Non associated if\nthe list is empty Constructor public        interface allocator_t public  function allocator_init (dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( allocator_t ) Type-Bound Procedures procedure, public :: get_block public  function get_block (self, dir, data_loc) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir integer, intent(in), optional :: data_loc Return Value class( field_t ), pointer procedure, public :: release_block public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle procedure, public :: create_block public  function create_block (self, next) result(ptr) Allocate memory for a new block and return a pointer to a new m_allocator object. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer procedure, public :: get_block_ids public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) procedure, public :: destroy public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a m_allocator object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self procedure, public :: get_padded_dims public  function get_padded_dims (self, dir) result(dims) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir Return Value integer, (3) procedure, public :: get_n_groups public  function get_n_groups (self, dir) result(n_groups) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir Return Value integer","tags":"","url":"type/allocator_t.html"},{"title":"vector_calculus_t – x3d2 ","text":"type, public :: vector_calculus_t Defines vector calculus operators Inherits type~~vector_calculus_t~~InheritsGraph type~vector_calculus_t vector_calculus_t type~base_backend_t base_backend_t type~vector_calculus_t->type~base_backend_t backend type~allocator_t allocator_t type~base_backend_t->type~allocator_t allocator type~mesh_t mesh_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~field_t field_t type~allocator_t->type~field_t first type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~poisson_fft_t->type~mesh_t mesh type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~vector_calculus_t~~InheritedByGraph type~vector_calculus_t vector_calculus_t type~solver_t solver_t type~solver_t->type~vector_calculus_t vector_calculus type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( base_backend_t ), public, pointer :: backend Constructor public        interface vector_calculus_t public  function init (backend) result(vector_calculus) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend Return Value type( vector_calculus_t ) Type-Bound Procedures procedure, public :: curl public  subroutine curl (self, o_i_hat, o_j_hat, o_k_hat, u, v, w, x_der1st, y_der1st, z_der1st) Curl of a vector field (u, v, w). Read more… Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w class( tdsops_t ), intent(in) :: x_der1st class( tdsops_t ), intent(in) :: y_der1st class( tdsops_t ), intent(in) :: z_der1st procedure, public :: divergence_v2c public  subroutine divergence_v2c (self, div_u, u, v, w, x_stagder_v2c, x_interpl_v2c, y_stagder_v2c, y_interpl_v2c, z_stagder_v2c, z_interpl_v2c) Divergence of a vector field (u, v, w). Read more… Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w class( tdsops_t ), intent(in) :: x_stagder_v2c class( tdsops_t ), intent(in) :: x_interpl_v2c class( tdsops_t ), intent(in) :: y_stagder_v2c class( tdsops_t ), intent(in) :: y_interpl_v2c class( tdsops_t ), intent(in) :: z_stagder_v2c class( tdsops_t ), intent(in) :: z_interpl_v2c procedure, public :: gradient_c2v public  subroutine gradient_c2v (self, dpdx, dpdy, dpdz, p, x_stagder_c2v, x_interpl_c2v, y_stagder_c2v, y_interpl_c2v, z_stagder_c2v, z_interpl_c2v) Gradient of a scalar field 'p'. Read more… Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: p class( tdsops_t ), intent(in) :: x_stagder_c2v class( tdsops_t ), intent(in) :: x_interpl_c2v class( tdsops_t ), intent(in) :: y_stagder_c2v class( tdsops_t ), intent(in) :: y_interpl_c2v class( tdsops_t ), intent(in) :: z_stagder_c2v class( tdsops_t ), intent(in) :: z_interpl_c2v procedure, public :: laplacian public  subroutine laplacian (self, lapl_u, u, x_der2nd, y_der2nd, z_der2nd) Laplacian of a scalar field 'u'. Read more… Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: lapl_u class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: x_der2nd class( tdsops_t ), intent(in) :: y_der2nd class( tdsops_t ), intent(in) :: z_der2nd","tags":"","url":"type/vector_calculus_t.html"},{"title":"field_buffer_map_t – x3d2 ","text":"type, public :: field_buffer_map_t Inherited by type~~field_buffer_map_t~~InheritedByGraph type~field_buffer_map_t field_buffer_map_t type~checkpoint_manager_t checkpoint_manager_t type~checkpoint_manager_t->type~field_buffer_map_t field_buffers type~snapshot_manager_t snapshot_manager_t type~snapshot_manager_t->type~field_buffer_map_t field_buffers type~io_manager_t io_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~base_case_t base_case_t type~base_case_t->type~io_manager_t checkpoint_mgr type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=32), public :: field_name real(kind=dp), public, dimension(:, :, :), allocatable :: buffer","tags":"","url":"type/field_buffer_map_t.html"},{"title":"field_ptr_t – x3d2 ","text":"type, public :: field_ptr_t Inherits type~~field_ptr_t~~InheritsGraph type~field_ptr_t field_ptr_t type~field_t field_t type~field_ptr_t->type~field_t ptr type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: ptr => null()","tags":"","url":"type/field_ptr_t.html"},{"title":"poisson_fft_t – x3d2 ","text":"type, public, abstract :: poisson_fft_t FFT based Poisson solver Inherits type~~poisson_fft_t~~InheritsGraph type~poisson_fft_t poisson_fft_t type~mesh_t mesh_t type~poisson_fft_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~poisson_fft_t~~InheritedByGraph type~poisson_fft_t poisson_fft_t type~base_backend_t base_backend_t type~base_backend_t->type~poisson_fft_t poisson_fft type~cuda_poisson_fft_t cuda_poisson_fft_t type~cuda_poisson_fft_t->type~poisson_fft_t type~omp_poisson_fft_t omp_poisson_fft_t type~omp_poisson_fft_t->type~poisson_fft_t type~cuda_backend_t cuda_backend_t type~cuda_backend_t->type~base_backend_t type~ibm_t ibm_t type~ibm_t->type~base_backend_t backend type~omp_backend_t omp_backend_t type~omp_backend_t->type~base_backend_t type~solver_t solver_t type~solver_t->type~base_backend_t backend type~solver_t->type~ibm_t ibm type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~time_intg_t->type~base_backend_t backend type~vector_calculus_t->type~base_backend_t backend type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mesh_t ), public, pointer :: mesh => null() integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: x_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: z_sp_st Offset in y and z directions in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants real(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ky Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: exs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: eys Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ezs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2x Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2y Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2z Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: trans_x_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_x_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_im Staggared grid transformation logical, public :: periodic_x Periodicity in x, y, and z logical, public :: periodic_y Periodicity in x, y, and z logical, public :: periodic_z Periodicity in x, y, and z logical, public :: stretched_y = .false. Periodicity in x, y, and z logical, public :: stretched_y_sym Periodicity in x, y, and z real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_im Stretching operator matrices logical, public :: lowmem = .false. lowmem option, only used in CUDA backend procedure( poisson_xxx ), public, pointer :: poisson => null() Procedure pointer to BC specific poisson solvers Type-Bound Procedures procedure( fft_forward ), public, deferred :: fft_forward_010 subroutine fft_forward(self, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure( fft_forward ), public, deferred :: fft_forward_100 subroutine fft_forward(self, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure( fft_forward ), public, deferred :: fft_forward_110 subroutine fft_forward(self, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure( fft_forward ), public, deferred :: fft_forward subroutine fft_forward(self, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure( fft_backward ), public, deferred :: fft_backward_010 subroutine fft_backward(self, f_out) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure( fft_backward ), public, deferred :: fft_backward_100 subroutine fft_backward(self, f_out) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure( fft_backward ), public, deferred :: fft_backward_110 subroutine fft_backward(self, f_out) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure( fft_backward ), public, deferred :: fft_backward subroutine fft_backward(self, f_out) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure( fft_postprocess ), public, deferred :: fft_postprocess_000 subroutine fft_postprocess(self) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self procedure( fft_postprocess ), public, deferred :: fft_postprocess_010 subroutine fft_postprocess(self) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self procedure( fft_postprocess ), public, deferred :: fft_postprocess_100 subroutine fft_postprocess(self) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self procedure( fft_postprocess ), public, deferred :: fft_postprocess_110 subroutine fft_postprocess(self) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self procedure( field_process ), public, deferred :: enforce_periodicity_x subroutine field_process(self, f_out, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure( field_process ), public, deferred :: undo_periodicity_x subroutine field_process(self, f_out, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure( field_process ), public, deferred :: enforce_periodicity_y subroutine field_process(self, f_out, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure( field_process ), public, deferred :: undo_periodicity_y subroutine field_process(self, f_out, f_in) Prototype Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure, public :: base_init public  subroutine base_init (self, mesh, xdirps, ydirps, zdirps, n_spec, n_sp_st) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( mesh_t ), intent(in), target :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in), dimension(3) :: n_spec integer, intent(in), dimension(3) :: n_sp_st procedure, public :: solve_poisson public  subroutine solve_poisson (self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp procedure, public :: stretching_matrix public  subroutine stretching_matrix (self, geo, xdirps, ydirps, zdirps) Stretching necessitates a special operation in spectral space.\nThe coefficients for the operation are stored in matrix form. Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: waves_set public  subroutine waves_set (self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: get_km public  function get_km (self, i, j, k) result(km) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value complex(kind=dp) procedure, public :: get_km_re public  function get_km_re (self, i, j, k) result(re) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) procedure, public :: get_km_im public  function get_km_im (self, i, j, k) result(re) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp)","tags":"","url":"type/poisson_fft_t.html"},{"title":"snapshot_manager_t – x3d2 ","text":"type, public :: snapshot_manager_t Inherits type~~snapshot_manager_t~~InheritsGraph type~snapshot_manager_t snapshot_manager_t type~checkpoint_config_t checkpoint_config_t type~snapshot_manager_t->type~checkpoint_config_t config type~field_buffer_map_t field_buffer_map_t type~snapshot_manager_t->type~field_buffer_map_t field_buffers type~writer_session_t writer_session_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~base_config_t base_config_t type~checkpoint_config_t->type~base_config_t type~io_session_base_t io_session_base_t type~writer_session_t->type~io_session_base_t type~io_writer_t io_writer_t type~writer_session_t->type~io_writer_t writer type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~snapshot_manager_t~~InheritedByGraph type~snapshot_manager_t snapshot_manager_t type~io_manager_t io_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~base_case_t base_case_t type~base_case_t->type~io_manager_t checkpoint_mgr type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( checkpoint_config_t ), public :: config integer, public, dimension(3) :: output_stride = [1, 1, 1] type( field_buffer_map_t ), public, allocatable :: field_buffers (:) integer(kind=i8), public, dimension(3) :: last_shape_dims = 0 integer, public, dimension(3) :: last_stride_factors = 0 integer(kind=i8), public, dimension(3) :: last_output_shape = 0 character(len=4096), public :: vtk_xml = \"\" logical, public :: is_snapshot_file_open = .false. type( writer_session_t ), public :: snapshot_writer logical, public :: convert_to_sp = .false. Flag for single precision snapshots Type-Bound Procedures procedure, public :: init private  subroutine init(self, comm) Initialise snapshot manager Arguments Type Intent Optional Attributes Name class( snapshot_manager_t ), intent(inout) :: self integer, intent(in) :: comm procedure, public :: handle_snapshot_step private  subroutine handle_snapshot_step(self, solver, timestep, comm) Handle snapshot writing at a given timestep Arguments Type Intent Optional Attributes Name class( snapshot_manager_t ), intent(inout) :: self class( solver_t ), intent(in) :: solver integer, intent(in) :: timestep integer, intent(in), optional :: comm procedure, public :: finalise private  subroutine finalise(self) Clean up snapshot manager Arguments Type Intent Optional Attributes Name class( snapshot_manager_t ), intent(inout) :: self","tags":"","url":"type/snapshot_manager_t.html"},{"title":"mesh_t – x3d2 ","text":"type, public :: mesh_t Inherits type~~mesh_t~~InheritsGraph type~mesh_t mesh_t type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mesh_t~~InheritedByGraph type~mesh_t mesh_t type~base_backend_t base_backend_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~ibm_t ibm_t type~ibm_t->type~mesh_t mesh type~ibm_t->type~base_backend_t backend type~poisson_fft_t->type~mesh_t mesh type~solver_t solver_t type~solver_t->type~mesh_t mesh type~solver_t->type~base_backend_t backend type~solver_t->type~ibm_t ibm type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~cuda_backend_t cuda_backend_t type~cuda_backend_t->type~base_backend_t type~cuda_poisson_fft_t cuda_poisson_fft_t type~cuda_poisson_fft_t->type~poisson_fft_t type~omp_backend_t omp_backend_t type~omp_backend_t->type~base_backend_t type~omp_poisson_fft_t omp_poisson_fft_t type~omp_poisson_fft_t->type~poisson_fft_t type~time_intg_t->type~base_backend_t backend type~vector_calculus_t->type~base_backend_t backend type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( geo_t ), public, allocatable :: geo class( grid_t ), public, allocatable :: grid class( par_t ), public, allocatable :: par Constructor public        interface mesh_t public  function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z, stretching, beta, use_2decomp) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z character(len=*), intent(in), optional, dimension(3) :: stretching real(kind=dp), intent(in), optional, dimension(3) :: beta logical, intent(in), optional :: use_2decomp Return Value class( mesh_t ), allocatable Type-Bound Procedures procedure, public :: get_dims public pure function get_dims (self, data_loc) result(dims) Getter for local domain dimensions Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) procedure, public :: get_global_dims public pure function get_global_dims (self, data_loc) result(dims) Getter for local domain dimensions Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) procedure, public :: get_n_dir public pure function get_n_dir (self, dir, data_loc) result(n) Getter for the main dimension a field oriented along dir with data on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer procedure, public :: get_n_phi public pure function get_n_phi (self, phi) result(n) Getter for the main dimension of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer generic, public :: get_n => get_n_dir , get_n_phi public pure function get_n_dir (self, dir, data_loc) result(n) Getter for the main dimension a field oriented along dir with data on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer public pure function get_n_phi (self, phi) result(n) Getter for the main dimension of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer procedure, public :: get_coordinates public pure function get_coordinates (self, i, j, k, data_loc_op) result(coords) Get the coordinates of a vertex with i, j, k local cartesian indices\nAvoid calling this in hot loops Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in), optional :: data_loc_op Return Value real(kind=dp), dimension(3)","tags":"","url":"type/mesh_t.html"},{"title":"case_channel_t – x3d2 ","text":"type, public, extends( base_case_t ) :: case_channel_t Inherits type~~case_channel_t~~InheritsGraph type~case_channel_t case_channel_t type~base_case_t base_case_t type~case_channel_t->type~base_case_t type~channel_config_t channel_config_t type~case_channel_t->type~channel_config_t channel_cfg type~io_manager_t io_manager_t type~base_case_t->type~io_manager_t checkpoint_mgr type~solver_t solver_t type~base_case_t->type~solver_t solver type~base_config_t base_config_t type~channel_config_t->type~base_config_t type~checkpoint_manager_t checkpoint_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~snapshot_manager_t snapshot_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~allocator_t allocator_t type~solver_t->type~allocator_t host_allocator type~base_backend_t base_backend_t type~solver_t->type~base_backend_t backend type~dirps_t dirps_t type~solver_t->type~dirps_t xdirps, ydirps, zdirps type~field_t field_t type~solver_t->type~field_t u, v, w type~flist_t flist_t type~solver_t->type~flist_t species type~ibm_t ibm_t type~solver_t->type~ibm_t ibm type~mesh_t mesh_t type~solver_t->type~mesh_t mesh type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~allocator_t->type~field_t first type~base_backend_t->type~allocator_t allocator type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~checkpoint_config_t checkpoint_config_t type~checkpoint_manager_t->type~checkpoint_config_t config type~field_buffer_map_t field_buffer_map_t type~checkpoint_manager_t->type~field_buffer_map_t field_buffers type~tdsops_t tdsops_t type~dirps_t->type~tdsops_t der1st, der1st_sym, der2nd, der2nd_sym, stagder_v2p, stagder_p2v, interpl_v2p, interpl_p2v type~field_t->type~field_t next type~flist_t->type~field_t ptr type~ibm_t->type~allocator_t host_allocator type~ibm_t->type~base_backend_t backend type~ibm_t->type~field_t ep1 type~ibm_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~snapshot_manager_t->type~checkpoint_config_t config type~snapshot_manager_t->type~field_buffer_map_t field_buffers type~writer_session_t writer_session_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~time_intg_t->type~allocator_t allocator type~time_intg_t->type~base_backend_t backend type~time_intg_t->type~flist_t olds type~vector_calculus_t->type~base_backend_t backend type~checkpoint_config_t->type~base_config_t type~poisson_fft_t->type~mesh_t mesh type~io_session_base_t io_session_base_t type~writer_session_t->type~io_session_base_t type~io_writer_t io_writer_t type~writer_session_t->type~io_writer_t writer type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr type( channel_config_t ), public :: channel_cfg Constructor public        interface case_channel_t public  function case_channel_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_channel_t ) Type-Bound Procedures procedure, public :: case_init public  subroutine case_init (self, backend, mesh, host_allocator) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator procedure, public :: case_finalise public  subroutine case_finalise (self) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self procedure, public :: set_init public  subroutine set_init (self, field, field_func) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: field public pure function field_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) procedure, public :: run public  subroutine run (self) Runs the solver forwards in time from t=t_0 to t=T, performing\npostprocessing/IO and reporting diagnostics. Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(inout) :: self procedure, public :: print_enstrophy public  subroutine print_enstrophy (self, u, v, w) Reports the enstrophy Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: print_div_max_mean public  subroutine print_div_max_mean (self, u, v, w) Reports the div(u) at cell centres Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: boundary_conditions => boundary_conditions_channel public  subroutine boundary_conditions_channel (self) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self procedure, public :: initial_conditions => initial_conditions_channel public  subroutine initial_conditions_channel (self) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self procedure, public :: forcings => forcings_channel public  subroutine forcings_channel (self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter procedure, public :: pre_correction => pre_correction_channel public  subroutine pre_correction_channel (self, u, v, w) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w procedure, public :: postprocess => postprocess_channel public  subroutine postprocess_channel (self, iter, t) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t","tags":"","url":"type/case_channel_t.html"},{"title":"cuda_allocator_t – x3d2 ","text":"type, public, extends( allocator_t ) :: cuda_allocator_t Inherits type~~cuda_allocator_t~~InheritsGraph type~cuda_allocator_t cuda_allocator_t type~allocator_t allocator_t type~cuda_allocator_t->type~allocator_t type~field_t field_t type~allocator_t->type~field_t first type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ngrid integer, public :: sz integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( field_t ), public, pointer :: first => null() The pointer to the first block on the list.  Non associated if\nthe list is empty Constructor public        interface cuda_allocator_t public  function cuda_allocator_init (dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( cuda_allocator_t ) Type-Bound Procedures procedure, public :: get_block public  function get_block (self, dir, data_loc) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir integer, intent(in), optional :: data_loc Return Value class( field_t ), pointer procedure, public :: release_block public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle procedure, public :: get_block_ids public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) procedure, public :: destroy public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a m_allocator object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self procedure, public :: get_padded_dims public  function get_padded_dims (self, dir) result(dims) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir Return Value integer, (3) procedure, public :: get_n_groups public  function get_n_groups (self, dir) result(n_groups) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir Return Value integer procedure, public :: create_block => create_cuda_block public  function create_cuda_block (self, next) result(ptr) Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","url":"type/cuda_allocator_t.html"},{"title":"cuda_field_t – x3d2 ","text":"type, public, extends( field_t ) :: cuda_field_t Inherits type~~cuda_field_t~~InheritsGraph type~cuda_field_t cuda_field_t type~field_t field_t type~cuda_field_t->type~field_t type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, pointer, contiguous :: data (:,:,:) integer, public :: dir integer, public :: data_loc integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. real(kind=dp), public, device, pointer, contiguous :: data_d (:,:,:) Constructor public        interface cuda_field_t public  function cuda_field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) Type-Bound Procedures procedure, public :: set_data_loc public  subroutine set_data_loc (self, data_loc) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: data_loc procedure, public :: fill => fill_cuda public  subroutine fill_cuda (self, c) Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self real(kind=dp), intent(in) :: c procedure, public :: get_shape => get_shape_cuda public  function get_shape_cuda (self) result(dims) Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self Return Value integer, (3) procedure, public :: set_shape => set_shape_cuda public  subroutine set_shape_cuda (self, dims) Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self integer, intent(in) :: dims (3)","tags":"","url":"type/cuda_field_t.html"},{"title":"raw_old_field_buffer_t – x3d2 ","text":"type, public :: raw_old_field_buffer_t Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: data (:,:,:)","tags":"","url":"type/raw_old_field_buffer_t.html"},{"title":"checkpoint_manager_t – x3d2 ","text":"type, public :: checkpoint_manager_t Inherits type~~checkpoint_manager_t~~InheritsGraph type~checkpoint_manager_t checkpoint_manager_t type~checkpoint_config_t checkpoint_config_t type~checkpoint_manager_t->type~checkpoint_config_t config type~field_buffer_map_t field_buffer_map_t type~checkpoint_manager_t->type~field_buffer_map_t field_buffers type~base_config_t base_config_t type~checkpoint_config_t->type~base_config_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~checkpoint_manager_t~~InheritedByGraph type~checkpoint_manager_t checkpoint_manager_t type~io_manager_t io_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~base_case_t base_case_t type~base_case_t->type~io_manager_t checkpoint_mgr type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( checkpoint_config_t ), public :: config integer, public :: last_checkpoint_step = -1 integer, public, dimension(3) :: full_resolution = [1, 1, 1] type( field_buffer_map_t ), public, allocatable :: field_buffers (:) integer(kind=i8), public, dimension(3) :: last_shape_dims = 0 integer, public, dimension(3) :: last_stride_factors = 0 integer(kind=i8), public, dimension(3) :: last_output_shape = 0 Type-Bound Procedures procedure, public :: init private  subroutine init(self, comm) Initialise checkpoint manager Arguments Type Intent Optional Attributes Name class( checkpoint_manager_t ), intent(inout) :: self integer, intent(in) :: comm procedure, public :: handle_restart private  subroutine handle_restart(self, solver, comm) Handle restart from checkpoint Arguments Type Intent Optional Attributes Name class( checkpoint_manager_t ), intent(inout) :: self class( solver_t ), intent(inout) :: solver integer, intent(in), optional :: comm procedure, public :: handle_checkpoint_step private  subroutine handle_checkpoint_step(self, solver, timestep, comm) Handle checkpoint writing at a given timestep Arguments Type Intent Optional Attributes Name class( checkpoint_manager_t ), intent(inout) :: self class( solver_t ), intent(in) :: solver integer, intent(in) :: timestep integer, intent(in), optional :: comm procedure, public :: is_restart private  function is_restart(self) result(restart) Check if this is a restart run Arguments Type Intent Optional Attributes Name class( checkpoint_manager_t ), intent(in) :: self Return Value logical procedure, public :: finalise private  subroutine finalise(self) Clean up checkpoint manager Arguments Type Intent Optional Attributes Name class( checkpoint_manager_t ), intent(inout) :: self","tags":"","url":"type/checkpoint_manager_t.html"},{"title":"cuda_tdsops_t – x3d2 ","text":"type, public, extends( tdsops_t ) :: cuda_tdsops_t CUDA extension of the Tridiagonal Solver Operators class. Regular tdsops_t class is initiated and the coefficient arrays are\ncopied into device arrays so that cuda kernels can use them. Inherits type~~cuda_tdsops_t~~InheritsGraph type~cuda_tdsops_t cuda_tdsops_t type~tdsops_t tdsops_t type~cuda_tdsops_t->type~tdsops_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: thom_f real(kind=dp), public, allocatable, dimension(:) :: thom_s real(kind=dp), public, allocatable, dimension(:) :: thom_w real(kind=dp), public, allocatable, dimension(:) :: thom_p real(kind=dp), public, allocatable :: stretch (:) real(kind=dp), public, allocatable :: stretch_correct (:) real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha Compact scheme coeffs real(kind=dp), public :: a Compact scheme coeffs real(kind=dp), public :: b Compact scheme coeffs real(kind=dp), public :: c = 0._dp Compact scheme coeffs real(kind=dp), public :: d = 0._dp Compact scheme coeffs logical, public :: periodic integer, public :: n_tds Tridiagonal system size integer, public :: n_rhs Right-hand-side builder size integer, public :: move = 0 move between vertices and cell centres integer, public :: n_halo number of halo points real(kind=dp), public, device, allocatable :: dist_fw_dev (:) real(kind=dp), public, device, allocatable :: dist_bw_dev (:) real(kind=dp), public, device, allocatable :: dist_sa_dev (:) real(kind=dp), public, device, allocatable :: dist_sc_dev (:) real(kind=dp), public, device, allocatable :: dist_af_dev (:) real(kind=dp), public, device, allocatable :: thom_f_dev (:) real(kind=dp), public, device, allocatable :: thom_s_dev (:) real(kind=dp), public, device, allocatable :: thom_w_dev (:) real(kind=dp), public, device, allocatable :: thom_p_dev (:) real(kind=dp), public, device, allocatable :: stretch_dev (:) real(kind=dp), public, device, allocatable :: stretch_correct_dev (:) real(kind=dp), public, device, allocatable :: coeffs_dev (:) real(kind=dp), public, device, allocatable :: coeffs_s_dev (:,:) real(kind=dp), public, device, allocatable :: coeffs_e_dev (:,:) Constructor public        interface cuda_tdsops_t public  function cuda_tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function Type-Bound Procedures procedure, public :: stagder_1st public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym procedure, public :: interpl_mid public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym procedure, public :: deriv_2nd public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: deriv_1st public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym procedure, public :: preprocess_thom public  subroutine preprocess_thom (self, b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: b procedure, public :: preprocess_dist public  subroutine preprocess_dist (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b","tags":"","url":"type/cuda_tdsops_t.html"},{"title":"solver_t – x3d2 ","text":"type, public :: solver_t solver class defines the Incompact3D algorithm at a very high level. Procedures defined here that are part of the Incompact3D algorithm\nare: transeq, divergence, poisson, and gradient. The operations these high level procedures require are provided by\nthe relavant backend implementations. transeq procedure obtains the derivations in x, y, and z directions\nusing the transeq_x, transeq_y, and transeq_z operations provided by\nthe backend.\nThere are two different algorithms available for this operation, a\ndistributed algorithm and the Thomas algorithm. At the solver class\nlevel it isn't known which algorithm will be executed, that is decided\nat run time and therefore backend implementations are responsible for\nexecuting the right subroutines. Allocator is responsible from giving us a field sized array when\nrequested. For example, when the derivations in x direction are\ncompleted and we are ready for the y directional derivatives, we need\nthree fields to reorder and store the velocities in y direction. Also,\nwe need three more fields for storing the results, and the get_block\nmethod of the allocator is used to arrange all these memory\nassignments. Later, when a field is no more required, release_block\nmethod of the allocator can be used to make this field available\nfor later use. Inherits type~~solver_t~~InheritsGraph type~solver_t solver_t type~allocator_t allocator_t type~solver_t->type~allocator_t host_allocator type~base_backend_t base_backend_t type~solver_t->type~base_backend_t backend type~dirps_t dirps_t type~solver_t->type~dirps_t xdirps, ydirps, zdirps type~field_t field_t type~solver_t->type~field_t u, v, w type~flist_t flist_t type~solver_t->type~flist_t species type~ibm_t ibm_t type~solver_t->type~ibm_t ibm type~mesh_t mesh_t type~solver_t->type~mesh_t mesh type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~allocator_t->type~field_t first type~base_backend_t->type~allocator_t allocator type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~tdsops_t tdsops_t type~dirps_t->type~tdsops_t der1st, der1st_sym, der2nd, der2nd_sym, stagder_v2p, stagder_p2v, interpl_v2p, interpl_p2v type~field_t->type~field_t next type~flist_t->type~field_t ptr type~ibm_t->type~allocator_t host_allocator type~ibm_t->type~base_backend_t backend type~ibm_t->type~field_t ep1 type~ibm_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~time_intg_t->type~allocator_t allocator type~time_intg_t->type~base_backend_t backend type~time_intg_t->type~flist_t olds type~vector_calculus_t->type~base_backend_t backend type~poisson_fft_t->type~mesh_t mesh Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~solver_t~~InheritedByGraph type~solver_t solver_t type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt real(kind=dp), public :: nu real(kind=dp), public, dimension(:), allocatable :: nu_species integer, public :: n_iters integer, public :: n_output integer, public :: current_iter = 0 integer, public :: ngrid integer, public :: nvars = 3 integer, public :: nspecies = 0 class( field_t ), public, pointer :: u class( field_t ), public, pointer :: v class( field_t ), public, pointer :: w type( flist_t ), public, dimension(:), pointer :: species => null() class( base_backend_t ), public, pointer :: backend type( mesh_t ), public, pointer :: mesh type( time_intg_t ), public :: time_integrator type( allocator_t ), public, pointer :: host_allocator type( dirps_t ), public, pointer :: xdirps type( dirps_t ), public, pointer :: ydirps type( dirps_t ), public, pointer :: zdirps type( vector_calculus_t ), public :: vector_calculus type( ibm_t ), public :: ibm logical, public :: ibm_on procedure( poisson_solver ), public, pointer :: poisson => null() procedure( transport_equation ), public, pointer :: transeq => null() Constructor public        interface solver_t public  function init (backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t ) Type-Bound Procedures procedure, public :: transeq_species public  subroutine transeq_species (self, rhs, variables) Skew-symmetric form of convection-diffusion terms in the\nspecies equation.\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(in) :: variables (:) procedure, public :: pressure_correction public  subroutine pressure_correction (self, u, v, w) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w procedure, public :: divergence_v2p public  subroutine divergence_v2p (self, div_u, u, v, w) Wrapper for divergence_v2p Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: gradient_p2v public  subroutine gradient_p2v (self, dpdx, dpdy, dpdz, pressure) Wrapper for gradient_p2v Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure procedure, public :: curl public  subroutine curl (self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Wrapper for curl Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w","tags":"","url":"type/solver_t.html"},{"title":"geo_t – x3d2 ","text":"type, public :: geo_t Stores geometry information Inherited by type~~geo_t~~InheritedByGraph type~geo_t geo_t type~mesh_t mesh_t type~mesh_t->type~geo_t geo type~base_backend_t base_backend_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~ibm_t ibm_t type~ibm_t->type~mesh_t mesh type~ibm_t->type~base_backend_t backend type~poisson_fft_t->type~mesh_t mesh type~solver_t solver_t type~solver_t->type~mesh_t mesh type~solver_t->type~base_backend_t backend type~solver_t->type~ibm_t ibm type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~cuda_backend_t cuda_backend_t type~cuda_backend_t->type~base_backend_t type~cuda_poisson_fft_t cuda_poisson_fft_t type~cuda_poisson_fft_t->type~poisson_fft_t type~omp_backend_t omp_backend_t type~omp_backend_t->type~base_backend_t type~omp_poisson_fft_t omp_poisson_fft_t type~omp_poisson_fft_t->type~poisson_fft_t type~time_intg_t->type~base_backend_t backend type~vector_calculus_t->type~base_backend_t backend type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: origin (3) Origin: coordinates of vertex (1, 1, 1) real(kind=dp), public :: d (3) size of a cell in each direction for a uniform mesh real(kind=dp), public :: L (3) Global dimensions of the domain in each direction real(kind=dp), public, allocatable, dimension(:, :) :: vert_coords Global coordinates at vertices real(kind=dp), public, allocatable, dimension(:, :) :: midp_coords Global coordinates at midpoints character(len=20), public, dimension(3) :: stretching Stretching type logical, public :: stretched (3) Stretching real(kind=dp), public :: alpha (3) Stretching parameters real(kind=dp), public :: beta (3) Stretching parameters real(kind=dp), public, allocatable, dimension(:, :) :: vert_ds Stretching factors at vertices real(kind=dp), public, allocatable, dimension(:, :) :: vert_ds2 Stretching factors at vertices real(kind=dp), public, allocatable, dimension(:, :) :: vert_d2s Stretching factors at vertices real(kind=dp), public, allocatable, dimension(:, :) :: midp_ds Stretching factors at midpoints real(kind=dp), public, allocatable, dimension(:, :) :: midp_ds2 Stretching factors at midpoints real(kind=dp), public, allocatable, dimension(:, :) :: midp_d2s Stretching factors at midpoints Type-Bound Procedures procedure, public :: obtain_coordinates public  subroutine obtain_coordinates (self, vert_dims, cell_dims, n_offset) Obtains global coordinates for all the vertices and midpoints Arguments Type Intent Optional Attributes Name class( geo_t ) :: self integer, intent(in) :: vert_dims (3) integer, intent(in) :: cell_dims (3) integer, intent(in) :: n_offset (3)","tags":"","url":"type/geo_t.html"},{"title":"grid_t – x3d2 ","text":"type, public :: grid_t Stores grid information Inherited by type~~grid_t~~InheritedByGraph type~grid_t grid_t type~mesh_t mesh_t type~mesh_t->type~grid_t grid type~base_backend_t base_backend_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~ibm_t ibm_t type~ibm_t->type~mesh_t mesh type~ibm_t->type~base_backend_t backend type~poisson_fft_t->type~mesh_t mesh type~solver_t solver_t type~solver_t->type~mesh_t mesh type~solver_t->type~base_backend_t backend type~solver_t->type~ibm_t ibm type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~cuda_backend_t cuda_backend_t type~cuda_backend_t->type~base_backend_t type~cuda_poisson_fft_t cuda_poisson_fft_t type~cuda_poisson_fft_t->type~poisson_fft_t type~omp_backend_t omp_backend_t type~omp_backend_t->type~base_backend_t type~omp_poisson_fft_t omp_poisson_fft_t type~omp_poisson_fft_t->type~poisson_fft_t type~time_intg_t->type~base_backend_t backend type~vector_calculus_t->type~base_backend_t backend type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, dimension(3) :: global_vert_dims integer, public, dimension(3) :: global_cell_dims integer, public, dimension(3) :: vert_dims integer, public, dimension(3) :: cell_dims logical, public, dimension(3) :: periodic_BC integer, public, dimension(3, 2) :: BCs_global integer, public, dimension(3, 2) :: BCs Type-Bound Procedures procedure, public :: copy_cell2vert_dims public pure subroutine copy_cell2vert_dims (self, par) Copies cell_dims information to vert_dims taking\nperiodicity into account Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: self type( par_t ), intent(in) :: par procedure, public :: copy_vert2cell_dims public pure subroutine copy_vert2cell_dims (self, par) Copies vert_dims information to cell_dims taking\nperiodicity into account Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: self type( par_t ), intent(in) :: par","tags":"","url":"type/grid_t.html"},{"title":"par_t – x3d2 ","text":"type, public :: par_t Stores parallel domain related information Inherited by type~~par_t~~InheritedByGraph type~par_t par_t type~mesh_t mesh_t type~mesh_t->type~par_t par type~base_backend_t base_backend_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~ibm_t ibm_t type~ibm_t->type~mesh_t mesh type~ibm_t->type~base_backend_t backend type~poisson_fft_t->type~mesh_t mesh type~solver_t solver_t type~solver_t->type~mesh_t mesh type~solver_t->type~base_backend_t backend type~solver_t->type~ibm_t ibm type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~cuda_backend_t cuda_backend_t type~cuda_backend_t->type~base_backend_t type~cuda_poisson_fft_t cuda_poisson_fft_t type~cuda_poisson_fft_t->type~poisson_fft_t type~omp_backend_t omp_backend_t type~omp_backend_t->type~base_backend_t type~omp_poisson_fft_t omp_poisson_fft_t type~omp_poisson_fft_t->type~poisson_fft_t type~time_intg_t->type~base_backend_t backend type~vector_calculus_t->type~base_backend_t backend type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: nrank integer, public :: nproc integer, public, dimension(3) :: nrank_dir integer, public, dimension(3) :: nproc_dir integer, public, dimension(3) :: n_offset integer, public, dimension(3) :: pnext integer, public, dimension(3) :: pprev Type-Bound Procedures procedure, public :: is_root public pure function is_root (self) result(is_root_rank) Returns wether or not the current rank is the root rank Arguments Type Intent Optional Attributes Name class( par_t ), intent(in) :: self Return Value logical procedure, public :: compute_rank_pos_from_global public pure subroutine compute_rank_pos_from_global (self, global_ranks) From the global rank maps, fills in the rank position as well\nas the previous and next rank in the par structure Arguments Type Intent Optional Attributes Name class( par_t ), intent(inout) :: self integer, intent(in), dimension(:, :, :) :: global_ranks","tags":"","url":"type/par_t.html"},{"title":"cuda_poisson_fft_t – x3d2 ","text":"type, public, extends( poisson_fft_t ) :: cuda_poisson_fft_t FFT based Poisson solver Inherits type~~cuda_poisson_fft_t~~InheritsGraph type~cuda_poisson_fft_t cuda_poisson_fft_t cudaLibXtDesc cudaLibXtDesc type~cuda_poisson_fft_t->cudaLibXtDesc xtdesc type~poisson_fft_t poisson_fft_t type~cuda_poisson_fft_t->type~poisson_fft_t type~mesh_t mesh_t type~poisson_fft_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mesh_t ), public, pointer :: mesh => null() integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: x_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: z_sp_st Offset in y and z directions in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants real(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ky Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: exs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: eys Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ezs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2x Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2y Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2z Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: trans_x_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_x_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_im Staggared grid transformation logical, public :: periodic_x Periodicity in x, y, and z logical, public :: periodic_y Periodicity in x, y, and z logical, public :: periodic_z Periodicity in x, y, and z logical, public :: stretched_y = .false. Periodicity in x, y, and z logical, public :: stretched_y_sym Periodicity in x, y, and z real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_im Stretching operator matrices logical, public :: lowmem = .false. lowmem option, only used in CUDA backend procedure( poisson_xxx ), public, pointer :: poisson => null() Procedure pointer to BC specific poisson solvers complex(kind=dp), public, device, allocatable, dimension(:, :, :) :: waves_dev Local domain sized array storing the spectral equivalence constants real(kind=dp), public, device, allocatable, dimension(:) :: ax_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: bx_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: ay_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: by_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: az_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: bz_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_odd_re_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_odd_im_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_even_re_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_even_im_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_re_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_im_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_odd_re_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_odd_im_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_even_re_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_even_im_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_re_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_im_dev Stretching operator matrices integer, public :: plan3D_fw Forward and backward FFT transform plans integer, public :: plan3D_bw Forward and backward FFT transform plans logical, public :: use_cufftmp = .true. Flag to indicate whether cuFFTMp is used type(cudaLibXtDesc), public, pointer :: xtdesc cuFFTMp object manages decomposition and data storage complex(kind=dp), public, device, allocatable, dimension(:, :, :) :: c_dev Standard cuFFT storage real(kind=dp), public, device, allocatable, dimension(:, :, :) :: r_dev cuFFT real workspace (input/output of R2C/C2R) Constructor public        interface cuda_poisson_fft_t private  function init(mesh, xdirps, ydirps, zdirps, lowmem) result(poisson_fft) if stretching in y is 'bottom' Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem Return Value type( cuda_poisson_fft_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self, mesh, xdirps, ydirps, zdirps, n_spec, n_sp_st) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( mesh_t ), intent(in), target :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in), dimension(3) :: n_spec integer, intent(in), dimension(3) :: n_sp_st procedure, public :: solve_poisson public  subroutine solve_poisson (self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp procedure, public :: stretching_matrix public  subroutine stretching_matrix (self, geo, xdirps, ydirps, zdirps) Stretching necessitates a special operation in spectral space.\nThe coefficients for the operation are stored in matrix form. Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: waves_set public  subroutine waves_set (self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: get_km public  function get_km (self, i, j, k) result(km) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value complex(kind=dp) procedure, public :: get_km_re public  function get_km_re (self, i, j, k) result(re) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) procedure, public :: get_km_im public  function get_km_im (self, i, j, k) result(re) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) procedure, public :: fft_forward => fft_forward_cuda public  subroutine fft_forward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f procedure, public :: fft_forward_010 => fft_forward_cuda public  subroutine fft_forward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f procedure, public :: fft_forward_100 => fft_forward_100_cuda public  subroutine fft_forward_100_cuda (self, f) Forward FFT for non-periodic-X case\nWe transpose X<->Y so that the non-periodic direction becomes the\n\"Y\" direction in the transposed space, then use the same FFT approach as 010 Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f procedure, public :: fft_forward_110 => fft_forward_cuda public  subroutine fft_forward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f procedure, public :: fft_backward => fft_backward_cuda public  subroutine fft_backward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f procedure, public :: fft_backward_010 => fft_backward_cuda public  subroutine fft_backward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f procedure, public :: fft_backward_100 => fft_backward_100_cuda public  subroutine fft_backward_100_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f procedure, public :: fft_backward_110 => fft_backward_cuda public  subroutine fft_backward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f procedure, public :: fft_postprocess_000 => fft_postprocess_000_cuda public  subroutine fft_postprocess_000_cuda (self) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self procedure, public :: fft_postprocess_010 => fft_postprocess_010_cuda public  subroutine fft_postprocess_010_cuda (self) if stretching in y is 'bottom' Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self procedure, public :: fft_postprocess_100 => fft_postprocess_100_cuda public  subroutine fft_postprocess_100_cuda (self) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self procedure, public :: fft_postprocess_110 => fft_postprocess_110_cuda public  subroutine fft_postprocess_110_cuda (self) if stretching in y is 'bottom' Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self procedure, public :: enforce_periodicity_x => enforce_periodicity_x_cuda public  subroutine enforce_periodicity_x_cuda (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure, public :: undo_periodicity_x => undo_periodicity_x_cuda public  subroutine undo_periodicity_x_cuda (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure, public :: enforce_periodicity_y => enforce_periodicity_y_cuda public  subroutine enforce_periodicity_y_cuda (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure, public :: undo_periodicity_y => undo_periodicity_y_cuda public  subroutine undo_periodicity_y_cuda (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"type/cuda_poisson_fft_t.html"},{"title":"base_case_t – x3d2 ","text":"type, public, abstract :: base_case_t Inherits type~~base_case_t~~InheritsGraph type~base_case_t base_case_t type~io_manager_t io_manager_t type~base_case_t->type~io_manager_t checkpoint_mgr type~solver_t solver_t type~base_case_t->type~solver_t solver type~checkpoint_manager_t checkpoint_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~snapshot_manager_t snapshot_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~allocator_t allocator_t type~solver_t->type~allocator_t host_allocator type~base_backend_t base_backend_t type~solver_t->type~base_backend_t backend type~dirps_t dirps_t type~solver_t->type~dirps_t xdirps, ydirps, zdirps type~field_t field_t type~solver_t->type~field_t u, v, w type~flist_t flist_t type~solver_t->type~flist_t species type~ibm_t ibm_t type~solver_t->type~ibm_t ibm type~mesh_t mesh_t type~solver_t->type~mesh_t mesh type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~allocator_t->type~field_t first type~base_backend_t->type~allocator_t allocator type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~checkpoint_config_t checkpoint_config_t type~checkpoint_manager_t->type~checkpoint_config_t config type~field_buffer_map_t field_buffer_map_t type~checkpoint_manager_t->type~field_buffer_map_t field_buffers type~tdsops_t tdsops_t type~dirps_t->type~tdsops_t der1st, der1st_sym, der2nd, der2nd_sym, stagder_v2p, stagder_p2v, interpl_v2p, interpl_p2v type~field_t->type~field_t next type~flist_t->type~field_t ptr type~ibm_t->type~allocator_t host_allocator type~ibm_t->type~base_backend_t backend type~ibm_t->type~field_t ep1 type~ibm_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~snapshot_manager_t->type~checkpoint_config_t config type~snapshot_manager_t->type~field_buffer_map_t field_buffers type~writer_session_t writer_session_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~time_intg_t->type~allocator_t allocator type~time_intg_t->type~base_backend_t backend type~time_intg_t->type~flist_t olds type~vector_calculus_t->type~base_backend_t backend type~base_config_t base_config_t type~checkpoint_config_t->type~base_config_t type~poisson_fft_t->type~mesh_t mesh type~io_session_base_t io_session_base_t type~writer_session_t->type~io_session_base_t type~io_writer_t io_writer_t type~writer_session_t->type~io_writer_t writer type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~base_case_t~~InheritedByGraph type~base_case_t base_case_t type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr Type-Bound Procedures procedure( boundary_conditions ), public, deferred :: boundary_conditions subroutine boundary_conditions(self) Prototype Applies case-specific boundary coinditions Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self procedure( initial_conditions ), public, deferred :: initial_conditions subroutine initial_conditions(self) Prototype Sets case-specific initial conditions Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self procedure( forcings ), public, deferred :: forcings subroutine forcings(self, du, dv, dw, iter) Prototype Applies case-specific or model realated forcings after transeq Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter procedure( pre_correction ), public, deferred :: pre_correction subroutine pre_correction(self, u, v, w) Prototype Applies case-specific pre-correction to the velocity fields before\npressure correction Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w procedure( postprocess ), public, deferred :: postprocess subroutine postprocess(self, iter, t) Prototype Triggers case-specific postprocessings at user specified intervals Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t procedure, public :: case_init public  subroutine case_init (self, backend, mesh, host_allocator) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator procedure, public :: case_finalise public  subroutine case_finalise (self) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self procedure, public :: set_init public  subroutine set_init (self, field, field_func) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: field public pure function field_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) procedure, public :: run public  subroutine run (self) Runs the solver forwards in time from t=t_0 to t=T, performing\npostprocessing/IO and reporting diagnostics. Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(inout) :: self procedure, public :: print_enstrophy public  subroutine print_enstrophy (self, u, v, w) Reports the enstrophy Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: print_div_max_mean public  subroutine print_div_max_mean (self, u, v, w) Reports the div(u) at cell centres Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w","tags":"","url":"type/base_case_t.html"},{"title":"case_tgv_t – x3d2 ","text":"type, public, extends( base_case_t ) :: case_tgv_t Inherits type~~case_tgv_t~~InheritsGraph type~case_tgv_t case_tgv_t type~base_case_t base_case_t type~case_tgv_t->type~base_case_t type~io_manager_t io_manager_t type~base_case_t->type~io_manager_t checkpoint_mgr type~solver_t solver_t type~base_case_t->type~solver_t solver type~checkpoint_manager_t checkpoint_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~snapshot_manager_t snapshot_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~allocator_t allocator_t type~solver_t->type~allocator_t host_allocator type~base_backend_t base_backend_t type~solver_t->type~base_backend_t backend type~dirps_t dirps_t type~solver_t->type~dirps_t xdirps, ydirps, zdirps type~field_t field_t type~solver_t->type~field_t u, v, w type~flist_t flist_t type~solver_t->type~flist_t species type~ibm_t ibm_t type~solver_t->type~ibm_t ibm type~mesh_t mesh_t type~solver_t->type~mesh_t mesh type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~allocator_t->type~field_t first type~base_backend_t->type~allocator_t allocator type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~checkpoint_config_t checkpoint_config_t type~checkpoint_manager_t->type~checkpoint_config_t config type~field_buffer_map_t field_buffer_map_t type~checkpoint_manager_t->type~field_buffer_map_t field_buffers type~tdsops_t tdsops_t type~dirps_t->type~tdsops_t der1st, der1st_sym, der2nd, der2nd_sym, stagder_v2p, stagder_p2v, interpl_v2p, interpl_p2v type~field_t->type~field_t next type~flist_t->type~field_t ptr type~ibm_t->type~allocator_t host_allocator type~ibm_t->type~base_backend_t backend type~ibm_t->type~field_t ep1 type~ibm_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~snapshot_manager_t->type~checkpoint_config_t config type~snapshot_manager_t->type~field_buffer_map_t field_buffers type~writer_session_t writer_session_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~time_intg_t->type~allocator_t allocator type~time_intg_t->type~base_backend_t backend type~time_intg_t->type~flist_t olds type~vector_calculus_t->type~base_backend_t backend type~base_config_t base_config_t type~checkpoint_config_t->type~base_config_t type~poisson_fft_t->type~mesh_t mesh type~io_session_base_t io_session_base_t type~writer_session_t->type~io_session_base_t type~io_writer_t io_writer_t type~writer_session_t->type~io_writer_t writer type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr Constructor public        interface case_tgv_t public  function case_tgv_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_tgv_t ) Type-Bound Procedures procedure, public :: case_init public  subroutine case_init (self, backend, mesh, host_allocator) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator procedure, public :: case_finalise public  subroutine case_finalise (self) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self procedure, public :: set_init public  subroutine set_init (self, field, field_func) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: field public pure function field_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) procedure, public :: run public  subroutine run (self) Runs the solver forwards in time from t=t_0 to t=T, performing\npostprocessing/IO and reporting diagnostics. Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(inout) :: self procedure, public :: print_enstrophy public  subroutine print_enstrophy (self, u, v, w) Reports the enstrophy Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: print_div_max_mean public  subroutine print_div_max_mean (self, u, v, w) Reports the div(u) at cell centres Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: boundary_conditions => boundary_conditions_tgv public  subroutine boundary_conditions_tgv (self) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self procedure, public :: initial_conditions => initial_conditions_tgv public  subroutine initial_conditions_tgv (self) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self procedure, public :: forcings => forcings_tgv public  subroutine forcings_tgv (self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter procedure, public :: pre_correction => pre_correction_tgv public  subroutine pre_correction_tgv (self, u, v, w) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w procedure, public :: postprocess => postprocess_tgv public  subroutine postprocess_tgv (self, iter, t) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t","tags":"","url":"type/case_tgv_t.html"},{"title":"omp_poisson_fft_t – x3d2 ","text":"type, public, extends( poisson_fft_t ) :: omp_poisson_fft_t FFT based Poisson solver Inherits type~~omp_poisson_fft_t~~InheritsGraph type~omp_poisson_fft_t omp_poisson_fft_t type~poisson_fft_t poisson_fft_t type~omp_poisson_fft_t->type~poisson_fft_t type~mesh_t mesh_t type~poisson_fft_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mesh_t ), public, pointer :: mesh => null() integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: x_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: z_sp_st Offset in y and z directions in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants real(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ky Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: exs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: eys Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ezs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2x Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2y Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2z Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: trans_x_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_x_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_im Staggared grid transformation logical, public :: periodic_x Periodicity in x, y, and z logical, public :: periodic_y Periodicity in x, y, and z logical, public :: periodic_z Periodicity in x, y, and z logical, public :: stretched_y = .false. Periodicity in x, y, and z logical, public :: stretched_y_sym Periodicity in x, y, and z real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_im Stretching operator matrices logical, public :: lowmem = .false. lowmem option, only used in CUDA backend procedure( poisson_xxx ), public, pointer :: poisson => null() Procedure pointer to BC specific poisson solvers complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_x complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_y complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_z Constructor public        interface omp_poisson_fft_t private  function init(mesh, xdirps, ydirps, zdirps, lowmem) result(poisson_fft) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(in) :: mesh class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem Return Value type( omp_poisson_fft_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self, mesh, xdirps, ydirps, zdirps, n_spec, n_sp_st) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( mesh_t ), intent(in), target :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in), dimension(3) :: n_spec integer, intent(in), dimension(3) :: n_sp_st procedure, public :: solve_poisson public  subroutine solve_poisson (self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp procedure, public :: stretching_matrix public  subroutine stretching_matrix (self, geo, xdirps, ydirps, zdirps) Stretching necessitates a special operation in spectral space.\nThe coefficients for the operation are stored in matrix form. Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: waves_set public  subroutine waves_set (self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps procedure, public :: get_km public  function get_km (self, i, j, k) result(km) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value complex(kind=dp) procedure, public :: get_km_re public  function get_km_re (self, i, j, k) result(re) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) procedure, public :: get_km_im public  function get_km_im (self, i, j, k) result(re) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) procedure, public :: fft_forward => fft_forward_omp public  subroutine fft_forward_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure, public :: fft_forward_010 => fft_forward_omp public  subroutine fft_forward_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure, public :: fft_forward_100 => fft_forward_100_omp public  subroutine fft_forward_100_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure, public :: fft_forward_110 => fft_forward_110_omp public  subroutine fft_forward_110_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in procedure, public :: fft_backward => fft_backward_omp public  subroutine fft_backward_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure, public :: fft_backward_010 => fft_backward_omp public  subroutine fft_backward_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure, public :: fft_backward_100 => fft_backward_100_omp public  subroutine fft_backward_100_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure, public :: fft_backward_110 => fft_backward_110_omp public  subroutine fft_backward_110_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out procedure, public :: fft_postprocess_000 => fft_postprocess_000_omp public  subroutine fft_postprocess_000_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self procedure, public :: fft_postprocess_010 => fft_postprocess_010_omp public  subroutine fft_postprocess_010_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self procedure, public :: fft_postprocess_100 => fft_postprocess_100_omp public  subroutine fft_postprocess_100_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self procedure, public :: fft_postprocess_110 => fft_postprocess_110_omp public  subroutine fft_postprocess_110_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self procedure, public :: enforce_periodicity_x => enforce_periodicity_x_omp public  subroutine enforce_periodicity_x_omp (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure, public :: undo_periodicity_x => undo_periodicity_x_omp public  subroutine undo_periodicity_x_omp (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure, public :: enforce_periodicity_y => enforce_periodicity_y_omp public  subroutine enforce_periodicity_y_omp (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in procedure, public :: undo_periodicity_y => undo_periodicity_y_omp public  subroutine undo_periodicity_y_omp (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"type/omp_poisson_fft_t.html"},{"title":"ibm_t – x3d2 ","text":"type, public :: ibm_t Inherits type~~ibm_t~~InheritsGraph type~ibm_t ibm_t type~allocator_t allocator_t type~ibm_t->type~allocator_t host_allocator type~base_backend_t base_backend_t type~ibm_t->type~base_backend_t backend type~field_t field_t type~ibm_t->type~field_t ep1 type~mesh_t mesh_t type~ibm_t->type~mesh_t mesh type~allocator_t->type~field_t first type~base_backend_t->type~allocator_t allocator type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~field_t->type~field_t next type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~poisson_fft_t->type~mesh_t mesh Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~ibm_t~~InheritedByGraph type~ibm_t ibm_t type~solver_t solver_t type~solver_t->type~ibm_t ibm type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( base_backend_t ), public, pointer :: backend => null() class( mesh_t ), public, pointer :: mesh => null() type( allocator_t ), public, pointer :: host_allocator => null() integer, public :: iibm = 0 class( field_t ), public, pointer :: ep1 => null() Constructor public        interface ibm_t private  function init(backend, mesh, host_allocator) result(ibm) Initialize the basic IBM Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( ibm_t ) Type-Bound Procedures procedure, public :: body private  subroutine body(self, u, v, w) Apply basic IBM before the pressure solver Arguments Type Intent Optional Attributes Name class( ibm_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w","tags":"","url":"type/ibm_t.html"},{"title":"base_backend_t – x3d2 ","text":"type, public, abstract :: base_backend_t base_backend class defines all the abstract operations that the\nsolver class requires. For example, transport equation in solver class evaluates the\nderivatives in x, y, and z directions, and reorders the input\nfields as required. Then finally, combines all the directional\nderivatives to obtain the divergence of U*. All these high level operations solver class executes are\ndefined here using the abstract interfaces. Every backend\nimplementation extends the present abstact backend class to\ndefine the specifics of these operations based on the target\narchitecture. Inherits type~~base_backend_t~~InheritsGraph type~base_backend_t base_backend_t type~allocator_t allocator_t type~base_backend_t->type~allocator_t allocator type~mesh_t mesh_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~field_t field_t type~allocator_t->type~field_t first type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~poisson_fft_t->type~mesh_t mesh type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~base_backend_t~~InheritedByGraph type~base_backend_t base_backend_t type~cuda_backend_t cuda_backend_t type~cuda_backend_t->type~base_backend_t type~ibm_t ibm_t type~ibm_t->type~base_backend_t backend type~omp_backend_t omp_backend_t type~omp_backend_t->type~base_backend_t type~solver_t solver_t type~solver_t->type~base_backend_t backend type~solver_t->type~ibm_t ibm type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~time_intg_t->type~base_backend_t backend type~vector_calculus_t->type~base_backend_t backend type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n_halo = 4 DistD2 implementation is hardcoded for 4 halo layers for all backends type( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft Type-Bound Procedures procedure( transeq_ders ), public, deferred :: transeq_x subroutine transeq_ders(self, du, dv, dw, u, v, w, nu, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure( transeq_ders ), public, deferred :: transeq_y subroutine transeq_ders(self, du, dv, dw, u, v, w, nu, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure( transeq_ders ), public, deferred :: transeq_z subroutine transeq_ders(self, du, dv, dw, u, v, w, nu, dirps) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure( transeq_ders_spec ), public, deferred :: transeq_species subroutine transeq_ders_spec(self, dspec, uvw, spec, nu, dirps, sync) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync procedure( tds_solve ), public, deferred :: tds_solve subroutine tds_solve(self, du, u, tdsops) Prototype transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to tds_solve to the\ncorrect algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops procedure( reorder ), public, deferred :: reorder subroutine reorder(self, u_, u, direction) Prototype reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction procedure( sum_intox ), public, deferred :: sum_yintox subroutine sum_intox(self, u, u_) Prototype sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure( sum_intox ), public, deferred :: sum_zintox subroutine sum_intox(self, u, u_) Prototype sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ procedure( veccopy ), public, deferred :: veccopy subroutine veccopy(self, dst, src) Prototype copy vectors: y = x Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src procedure( vecadd ), public, deferred :: vecadd subroutine vecadd(self, a, x, b, y) Prototype adds two vectors together: y = a x + b y Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure( vecmult ), public, deferred :: vecmult subroutine vecmult(self, y, x) Prototype pointwise multiplication between two vectors: y(:) = y(:) * x(:) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x procedure( scalar_product ), public, deferred :: scalar_product function scalar_product(self, x, y) result(s) Prototype Calculates the scalar product of two input fields Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure( field_max_mean ), public, deferred :: field_max_mean subroutine field_max_mean(self, max_val, mean_val, f, enforced_data_loc) Prototype Obtains maximum and mean values in a field Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc procedure( field_ops ), public, deferred :: field_scale subroutine field_ops(self, f, a) Prototype Scales or shifts a field by a Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a procedure( field_ops ), public, deferred :: field_shift subroutine field_ops(self, f, a) Prototype Scales or shifts a field by a Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a procedure( field_reduce ), public, deferred :: field_volume_integral function field_reduce(self, f) result(s) Prototype Reduces field to a scalar, example: volume integral Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) procedure( field_set_face ), public, deferred :: field_set_face subroutine field_set_face(self, f, c_start, c_end, face) Prototype A field is a subdomain with a rectangular cuboid shape.\nIt has 6 faces, and these faces are either a subdomain boundary\nor a global domain boundary based on the location of the subdomain.\nThis subroutine allows us to set any of these faces to a value,\n'c_start' and 'c_end' for faces at opposite sides.\n'face' is one of X_FACE, Y_FACE, Z_FACE from common.f90 Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face procedure( copy_data_to_f ), public, deferred :: copy_data_to_f subroutine copy_data_to_f(self, f, data) Prototype Copy the specialist data structure from device or host back\nto a regular 3D data array in host memory. Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data procedure( copy_f_to_data ), public, deferred :: copy_f_to_data subroutine copy_f_to_data(self, data, f) Prototype Copy a regular 3D array in host memory into the specialist\ndata structure field that lives on device or host Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f procedure( alloc_tdsops ), public, deferred :: alloc_tdsops subroutine alloc_tdsops(self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Prototype Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure( init_poisson_fft ), public, deferred :: init_poisson_fft subroutine init_poisson_fft(self, mesh, xdirps, ydirps, zdirps, lowmem) Prototype Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem procedure, public :: base_init public  subroutine base_init (self) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self procedure, public :: get_field_data public  subroutine get_field_data (self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) procedure, public :: set_field_data public  subroutine set_field_data (self, f, data, dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian)","tags":"","url":"type/base_backend_t.html"},{"title":"field_t – x3d2 ","text":"type, public :: field_t Memory block type holding both a data field and a pointer\nto the next block.  The field_t type also holds a integer refcount that counts the number of references to this\nfield.  User code is currently responsible for incrementing\nthe reference count. Inherited by type~~field_t~~InheritedByGraph type~field_t field_t type~field_t->type~field_t next type~allocator_t allocator_t type~allocator_t->type~field_t first type~cuda_field_t cuda_field_t type~cuda_field_t->type~field_t type~field_ptr_t field_ptr_t type~field_ptr_t->type~field_t ptr type~flist_t flist_t type~flist_t->type~field_t ptr type~ibm_t ibm_t type~ibm_t->type~field_t ep1 type~ibm_t->type~allocator_t host_allocator type~base_backend_t base_backend_t type~ibm_t->type~base_backend_t backend type~solver_t solver_t type~solver_t->type~field_t u, v, w type~solver_t->type~allocator_t host_allocator type~solver_t->type~flist_t species type~solver_t->type~ibm_t ibm type~solver_t->type~base_backend_t backend type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~base_backend_t->type~allocator_t allocator type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~cuda_allocator_t cuda_allocator_t type~cuda_allocator_t->type~allocator_t type~time_intg_t->type~allocator_t allocator type~time_intg_t->type~flist_t olds type~time_intg_t->type~base_backend_t backend type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t type~cuda_backend_t cuda_backend_t type~cuda_backend_t->type~base_backend_t type~omp_backend_t omp_backend_t type~omp_backend_t->type~base_backend_t type~vector_calculus_t->type~base_backend_t backend Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, pointer, contiguous :: data (:,:,:) integer, public :: dir integer, public :: data_loc integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. Constructor public        interface field_t public  function field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) Type-Bound Procedures procedure, public :: fill public  subroutine fill (self, c) Arguments Type Intent Optional Attributes Name class( field_t ) :: self real(kind=dp), intent(in) :: c procedure, public :: get_shape public  function get_shape (self) result(dims) Arguments Type Intent Optional Attributes Name class( field_t ) :: self Return Value integer, (3) procedure, public :: set_shape public  subroutine set_shape (self, dims) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: dims (3) procedure, public :: set_data_loc public  subroutine set_data_loc (self, data_loc) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: data_loc","tags":"","url":"type/field_t.html"},{"title":"flist_t – x3d2 ","text":"type, public :: flist_t Use for creating a list of field pointers Inherits type~~flist_t~~InheritsGraph type~flist_t flist_t type~field_t field_t type~flist_t->type~field_t ptr type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~flist_t~~InheritedByGraph type~flist_t flist_t type~solver_t solver_t type~solver_t->type~flist_t species type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~time_intg_t->type~flist_t olds type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: ptr","tags":"","url":"type/flist_t.html"},{"title":"case_cylinder_t – x3d2 ","text":"type, public, extends( base_case_t ) :: case_cylinder_t Inherits type~~case_cylinder_t~~InheritsGraph type~case_cylinder_t case_cylinder_t type~base_case_t base_case_t type~case_cylinder_t->type~base_case_t type~cylinder_config_t cylinder_config_t type~case_cylinder_t->type~cylinder_config_t cylinder_cfg type~io_manager_t io_manager_t type~base_case_t->type~io_manager_t checkpoint_mgr type~solver_t solver_t type~base_case_t->type~solver_t solver type~base_config_t base_config_t type~cylinder_config_t->type~base_config_t type~checkpoint_manager_t checkpoint_manager_t type~io_manager_t->type~checkpoint_manager_t checkpoint_mgr type~snapshot_manager_t snapshot_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~allocator_t allocator_t type~solver_t->type~allocator_t host_allocator type~base_backend_t base_backend_t type~solver_t->type~base_backend_t backend type~dirps_t dirps_t type~solver_t->type~dirps_t xdirps, ydirps, zdirps type~field_t field_t type~solver_t->type~field_t u, v, w type~flist_t flist_t type~solver_t->type~flist_t species type~ibm_t ibm_t type~solver_t->type~ibm_t ibm type~mesh_t mesh_t type~solver_t->type~mesh_t mesh type~time_intg_t time_intg_t type~solver_t->type~time_intg_t time_integrator type~vector_calculus_t vector_calculus_t type~solver_t->type~vector_calculus_t vector_calculus type~allocator_t->type~field_t first type~base_backend_t->type~allocator_t allocator type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~checkpoint_config_t checkpoint_config_t type~checkpoint_manager_t->type~checkpoint_config_t config type~field_buffer_map_t field_buffer_map_t type~checkpoint_manager_t->type~field_buffer_map_t field_buffers type~tdsops_t tdsops_t type~dirps_t->type~tdsops_t der1st, der1st_sym, der2nd, der2nd_sym, stagder_v2p, stagder_p2v, interpl_v2p, interpl_p2v type~field_t->type~field_t next type~flist_t->type~field_t ptr type~ibm_t->type~allocator_t host_allocator type~ibm_t->type~base_backend_t backend type~ibm_t->type~field_t ep1 type~ibm_t->type~mesh_t mesh type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~snapshot_manager_t->type~checkpoint_config_t config type~snapshot_manager_t->type~field_buffer_map_t field_buffers type~writer_session_t writer_session_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~time_intg_t->type~allocator_t allocator type~time_intg_t->type~base_backend_t backend type~time_intg_t->type~flist_t olds type~vector_calculus_t->type~base_backend_t backend type~checkpoint_config_t->type~base_config_t type~poisson_fft_t->type~mesh_t mesh type~io_session_base_t io_session_base_t type~writer_session_t->type~io_session_base_t type~io_writer_t io_writer_t type~writer_session_t->type~io_writer_t writer type~io_file_t io_file_t type~io_session_base_t->type~io_file_t file Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr type( cylinder_config_t ), public :: cylinder_cfg Constructor public        interface case_cylinder_t public  function case_cylinder_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_cylinder_t ) Type-Bound Procedures procedure, public :: case_init public  subroutine case_init (self, backend, mesh, host_allocator) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator procedure, public :: case_finalise public  subroutine case_finalise (self) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self procedure, public :: set_init public  subroutine set_init (self, field, field_func) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: field public pure function field_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) procedure, public :: run public  subroutine run (self) Runs the solver forwards in time from t=t_0 to t=T, performing\npostprocessing/IO and reporting diagnostics. Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(inout) :: self procedure, public :: print_enstrophy public  subroutine print_enstrophy (self, u, v, w) Reports the enstrophy Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: print_div_max_mean public  subroutine print_div_max_mean (self, u, v, w) Reports the div(u) at cell centres Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w procedure, public :: boundary_conditions => boundary_conditions_cylinder public  subroutine boundary_conditions_cylinder (self) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self procedure, public :: initial_conditions => initial_conditions_cylinder public  subroutine initial_conditions_cylinder (self) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self procedure, public :: forcings => forcings_cylinder public  subroutine forcings_cylinder (self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter procedure, public :: pre_correction => pre_correction_cylinder public  subroutine pre_correction_cylinder (self, u, v, w) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w procedure, public :: postprocess => postprocess_cylinder public  subroutine postprocess_cylinder (self, iter, t) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t","tags":"","url":"type/case_cylinder_t.html"},{"title":"cuda_backend_t – x3d2 ","text":"type, public, extends( base_backend_t ) :: cuda_backend_t Inherits type~~cuda_backend_t~~InheritsGraph type~cuda_backend_t cuda_backend_t dim3 dim3 type~cuda_backend_t->dim3 xblocks, xthreads, yblocks, ythreads, zblocks, zthreads type~base_backend_t base_backend_t type~cuda_backend_t->type~base_backend_t type~allocator_t allocator_t type~base_backend_t->type~allocator_t allocator type~mesh_t mesh_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~field_t field_t type~allocator_t->type~field_t first type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~poisson_fft_t->type~mesh_t mesh type~field_t->type~field_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n_halo = 4 DistD2 implementation is hardcoded for 4 halo layers for all backends type( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_e_dev type(dim3), public :: xblocks type(dim3), public :: xthreads type(dim3), public :: yblocks type(dim3), public :: ythreads type(dim3), public :: zblocks type(dim3), public :: zthreads Constructor public        interface cuda_backend_t public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) Type-Bound Procedures procedure, public :: base_init public  subroutine base_init (self) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self procedure, public :: get_field_data public  subroutine get_field_data (self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) procedure, public :: set_field_data public  subroutine set_field_data (self, f, data, dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian) procedure, public :: alloc_tdsops => alloc_cuda_tdsops public  subroutine alloc_cuda_tdsops (self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: transeq_x => transeq_x_cuda public  subroutine transeq_x_cuda (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_y => transeq_y_cuda public  subroutine transeq_y_cuda (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_z => transeq_z_cuda public  subroutine transeq_z_cuda (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps procedure, public :: transeq_species => transeq_species_cuda public  subroutine transeq_species_cuda (self, dspec, uvw, spec, nu, dirps, sync) Compute the convection and diffusion for the given field\nin the given direction.\nHalo exchange for the given field is necessary\nWhen sync is true, halo exchange of momentum is necessary Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync procedure, public :: tds_solve => tds_solve_cuda public  subroutine tds_solve_cuda (self, du, u, tdsops) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops procedure, public :: reorder => reorder_cuda public  subroutine reorder_cuda (self, u_o, u_i, direction) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction procedure, public :: sum_yintox => sum_yintox_cuda public  subroutine sum_yintox_cuda (self, u, u_y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y procedure, public :: sum_zintox => sum_zintox_cuda public  subroutine sum_zintox_cuda (self, u, u_z) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z procedure, public :: veccopy => veccopy_cuda public  subroutine veccopy_cuda (self, dst, src) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src procedure, public :: vecadd => vecadd_cuda public  subroutine vecadd_cuda (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y procedure, public :: vecmult => vecmult_cuda public  subroutine vecmult_cuda (self, y, x) m_base_backend Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x procedure, public :: scalar_product => scalar_product_cuda public  function scalar_product_cuda (self, x, y) result(s) m_base_backend Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) procedure, public :: field_max_mean => field_max_mean_cuda public  subroutine field_max_mean_cuda (self, max_val, mean_val, f, enforced_data_loc) m_base_backend Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc procedure, public :: field_scale => field_scale_cuda public  subroutine field_scale_cuda (self, f, a) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a procedure, public :: field_shift => field_shift_cuda public  subroutine field_shift_cuda (self, f, a) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a procedure, public :: field_set_face => field_set_face_cuda public  subroutine field_set_face_cuda (self, f, c_start, c_end, face) m_base_backend Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face procedure, public :: field_volume_integral => field_volume_integral_cuda public  function field_volume_integral_cuda (self, f) result(s) volume integral of a field Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) procedure, public :: copy_data_to_f => copy_data_to_f_cuda public  subroutine copy_data_to_f_cuda (self, f, data) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(inout), dimension(:, :, :) :: data procedure, public :: copy_f_to_data => copy_f_to_data_cuda public  subroutine copy_f_to_data_cuda (self, data, f) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f procedure, public :: init_poisson_fft => init_cuda_poisson_fft public  subroutine init_cuda_poisson_fft (self, mesh, xdirps, ydirps, zdirps, lowmem) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem procedure, public :: transeq_cuda_dist public  subroutine transeq_cuda_dist (self, du, dv, dw, u, v, w, nu, dirps, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads procedure, public :: transeq_cuda_thom public  subroutine transeq_cuda_thom (self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps procedure, public :: tds_solve_dist public  subroutine tds_solve_dist (self, du, u, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","url":"type/cuda_backend_t.html"},{"title":"tdsops_t – x3d2 ","text":"type, public :: tdsops_t Tridiagonal Solver Operators class. Operator arrays are preprocessed in this class based on the arguments\nprovided. dist_fw and dist_bw are used in the first phase of the\ndistributed tridiagonal solver algorithm. dist_sa and dist_sc are used\nin the final substitution phase. See the kernels_dist.f90 files in the\nrelevant backend folders.\ncoeff arrays define the specific rules of building the RHS\ncorresponding to the tridiagonal system to be solved, and used only in\nthe first phase of the distributed algorithm when building the RHS.\nIf a boundary condition is defined then coeffs_s and coeffs_e differ\nfrom coeffs array and define the RHS rule for the first and last 4\nentries in the tridiagonal system (n_halo = 4). This class does not know about the current rank or its relative\nlocation among other ranks. All the operator arrays here are used when\nexecuting a distributed tridiagonal solver phase one or two. Inherited by type~~tdsops_t~~InheritedByGraph type~tdsops_t tdsops_t type~cuda_tdsops_t cuda_tdsops_t type~cuda_tdsops_t->type~tdsops_t type~dirps_t dirps_t type~dirps_t->type~tdsops_t der1st, der1st_sym, der2nd, der2nd_sym, stagder_v2p, stagder_p2v, interpl_v2p, interpl_p2v type~solver_t solver_t type~solver_t->type~dirps_t xdirps, ydirps, zdirps type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: thom_f real(kind=dp), public, allocatable, dimension(:) :: thom_s real(kind=dp), public, allocatable, dimension(:) :: thom_w real(kind=dp), public, allocatable, dimension(:) :: thom_p real(kind=dp), public, allocatable :: stretch (:) real(kind=dp), public, allocatable :: stretch_correct (:) real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha Compact scheme coeffs real(kind=dp), public :: a Compact scheme coeffs real(kind=dp), public :: b Compact scheme coeffs real(kind=dp), public :: c = 0._dp Compact scheme coeffs real(kind=dp), public :: d = 0._dp Compact scheme coeffs logical, public :: periodic integer, public :: n_tds Tridiagonal system size integer, public :: n_rhs Right-hand-side builder size integer, public :: move = 0 move between vertices and cell centres integer, public :: n_halo number of halo points Constructor public        interface tdsops_t public  function tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n_tds', 'delta', 'operation', 'scheme', 'bc_start', and 'bc_end' are\nnecessary arguments. The remaining arguments are optional. 'stretch' is for obtaining the correct derivations in a stretched mesh\n'stretch_correct' is for correcting the second derivative with the first 'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are BC_HALO. 'sym' is relevant when the BC is free-slip. If sym is .true. then it\nmeans the field we operate on is assumed to be an even function\n(symmetric, cos type) accross the boundary. If it is .false. it means\nthe field is assumed to be an odd function (anti-symmetric, sin type). 'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds Tridiagonal system size real(kind=dp), intent(in) :: delta Grid spacing character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start Boundary Cond. integer, intent(in) :: bc_end Boundary Cond. real(kind=dp), intent(in), optional :: stretch (:) Stretching coefficients real(kind=dp), intent(in), optional :: stretch_correct (:) Stretch correction integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Type-Bound Procedures procedure, public :: stagder_1st public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym procedure, public :: interpl_mid public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym procedure, public :: deriv_2nd public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu procedure, public :: deriv_1st public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym procedure, public :: preprocess_thom public  subroutine preprocess_thom (self, b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: b procedure, public :: preprocess_dist public  subroutine preprocess_dist (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b","tags":"","url":"type/tdsops_t.html"},{"title":"dirps_t – x3d2 ","text":"type, public :: dirps_t Directional tridiagonal solver container. This class contains the preprocessed tridiagonal solvers for operating\nin each coordinate direction. Inherits type~~dirps_t~~InheritsGraph type~dirps_t dirps_t type~tdsops_t tdsops_t type~dirps_t->type~tdsops_t der1st, der1st_sym, der2nd, der2nd_sym, stagder_v2p, stagder_p2v, interpl_v2p, interpl_p2v Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~dirps_t~~InheritedByGraph type~dirps_t dirps_t type~solver_t solver_t type~solver_t->type~dirps_t xdirps, ydirps, zdirps type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( tdsops_t ), public, allocatable :: der1st class( tdsops_t ), public, allocatable :: der1st_sym class( tdsops_t ), public, allocatable :: der2nd class( tdsops_t ), public, allocatable :: der2nd_sym class( tdsops_t ), public, allocatable :: stagder_v2p class( tdsops_t ), public, allocatable :: stagder_p2v class( tdsops_t ), public, allocatable :: interpl_v2p class( tdsops_t ), public, allocatable :: interpl_p2v integer, public :: dir","tags":"","url":"type/dirps_t.html"},{"title":"time_intg_t – x3d2 ","text":"type, public :: time_intg_t Inherits type~~time_intg_t~~InheritsGraph type~time_intg_t time_intg_t type~allocator_t allocator_t type~time_intg_t->type~allocator_t allocator type~base_backend_t base_backend_t type~time_intg_t->type~base_backend_t backend type~flist_t flist_t type~time_intg_t->type~flist_t olds type~field_t field_t type~allocator_t->type~field_t first type~base_backend_t->type~allocator_t allocator type~mesh_t mesh_t type~base_backend_t->type~mesh_t mesh type~poisson_fft_t poisson_fft_t type~base_backend_t->type~poisson_fft_t poisson_fft type~flist_t->type~field_t ptr type~field_t->type~field_t next type~geo_t geo_t type~mesh_t->type~geo_t geo type~grid_t grid_t type~mesh_t->type~grid_t grid type~par_t par_t type~mesh_t->type~par_t par type~poisson_fft_t->type~mesh_t mesh Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~time_intg_t~~InheritedByGraph type~time_intg_t time_intg_t type~solver_t solver_t type~solver_t->type~time_intg_t time_integrator type~base_case_t base_case_t type~base_case_t->type~solver_t solver type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: method integer, public :: istep integer, public :: istage integer, public :: order integer, public :: nstep integer, public :: nstage integer, public :: nvars integer, public :: nolds real(kind=dp), public :: coeffs (4,4) real(kind=dp), public :: rk_b (4,4) real(kind=dp), public :: rk_a (3,3,4) character(len=3), public :: sname type( flist_t ), public, allocatable :: olds (:,:) class( base_backend_t ), public, pointer :: backend class( allocator_t ), public, pointer :: allocator procedure( stepper_func ), public, pointer :: step => null() Constructor public        interface time_intg_t public  function init (backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in) :: nvars Return Value type( time_intg_t ) Type-Bound Procedures procedure, public :: finalize public  subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self procedure, public :: runge_kutta private  subroutine runge_kutta(self, curr, deriv, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self type( flist_t ), intent(inout) :: curr (:) type( flist_t ), intent(in) :: deriv (:) real(kind=dp), intent(in) :: dt procedure, public :: adams_bashforth private  subroutine adams_bashforth(self, curr, deriv, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self type( flist_t ), intent(inout) :: curr (:) type( flist_t ), intent(in) :: deriv (:) real(kind=dp), intent(in) :: dt","tags":"","url":"type/time_intg_t.html"},{"title":"io_file_t – x3d2 ","text":"type, public :: io_file_t Base file handle for I/O operations Inherited by type~~io_file_t~~InheritedByGraph type~io_file_t io_file_t type~io_session_base_t io_session_base_t type~io_session_base_t->type~io_file_t file type~reader_session_t reader_session_t type~reader_session_t->type~io_session_base_t type~writer_session_t writer_session_t type~writer_session_t->type~io_session_base_t type~snapshot_manager_t snapshot_manager_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~io_manager_t io_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~base_case_t base_case_t type~base_case_t->type~io_manager_t checkpoint_mgr type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: close => base_close private  subroutine base_close(self) Arguments Type Intent Optional Attributes Name class( io_file_t ), intent(inout) :: self procedure, public :: begin_step => base_begin_step private  subroutine base_begin_step(self) Arguments Type Intent Optional Attributes Name class( io_file_t ), intent(inout) :: self procedure, public :: end_step => base_end_step private  subroutine base_end_step(self) Arguments Type Intent Optional Attributes Name class( io_file_t ), intent(inout) :: self procedure, public :: is_file_functional => base_is_file_functional private  function base_is_file_functional(self) result(is_functional) Arguments Type Intent Optional Attributes Name class( io_file_t ), intent(in) :: self Return Value logical","tags":"","url":"type/io_file_t.html"},{"title":"io_reader_t – x3d2 ","text":"type, public :: io_reader_t Base I/O reader type for polymorphic usage Inherited by type~~io_reader_t~~InheritedByGraph type~io_reader_t io_reader_t type~reader_session_t reader_session_t type~reader_session_t->type~io_reader_t reader Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: init => base_reader_init private  subroutine base_reader_init(self, comm, name) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(inout) :: self integer, intent(in) :: comm character(len=*), intent(in) :: name procedure, public :: open => base_reader_open private  function base_reader_open(self, filename, mode, comm) result(file_handle) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(in) :: mode integer, intent(in) :: comm Return Value class( io_file_t ), allocatable procedure, public :: finalise => base_reader_finalise private  subroutine base_reader_finalise(self) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(inout) :: self generic, public :: read_data => read_data_i8, read_data_integer, read_data_real, read_data_array_3d private  subroutine read_data_i8_dummy(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class(io_dummy_reader_t), intent(inout) :: self character(len=*), intent(in) :: variable_name integer(kind=i8), intent(out) :: value class( io_file_t ), intent(inout) :: file_handle private  subroutine read_data_integer_dummy(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class(io_dummy_reader_t), intent(inout) :: self character(len=*), intent(in) :: variable_name integer, intent(out) :: value class( io_file_t ), intent(inout) :: file_handle private  subroutine read_data_real_dummy(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class(io_dummy_reader_t), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(out) :: value class( io_file_t ), intent(inout) :: file_handle private  subroutine read_data_array_3d_dummy(self, variable_name, array, file_handle, shape_dims, start_dims, count_dims) Arguments Type Intent Optional Attributes Name class(io_dummy_reader_t), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(inout) :: array (:,:,:) class( io_file_t ), intent(inout) :: file_handle integer(kind=i8), intent(in), optional :: shape_dims (3) integer(kind=i8), intent(in), optional :: start_dims (3) integer(kind=i8), intent(in), optional :: count_dims (3) procedure, public :: read_data_i8 private  subroutine read_data_i8(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name integer(kind=i8), intent(out) :: value class( io_file_t ), intent(inout) :: file_handle procedure, public :: read_data_integer private  subroutine read_data_integer(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name integer, intent(out) :: value class( io_file_t ), intent(inout) :: file_handle procedure, public :: read_data_real private  subroutine read_data_real(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(out) :: value class( io_file_t ), intent(inout) :: file_handle procedure, public :: read_data_array_3d private  subroutine read_data_array_3d(self, variable_name, array, file_handle, shape_dims, start_dims, count_dims) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(inout) :: array (:,:,:) class( io_file_t ), intent(inout) :: file_handle integer(kind=i8), intent(in), optional :: shape_dims (3) integer(kind=i8), intent(in), optional :: start_dims (3) integer(kind=i8), intent(in), optional :: count_dims (3)","tags":"","url":"type/io_reader_t.html"},{"title":"io_writer_t – x3d2 ","text":"type, public :: io_writer_t Base I/O writer type for polymorphic usage Inherited by type~~io_writer_t~~InheritedByGraph type~io_writer_t io_writer_t type~writer_session_t writer_session_t type~writer_session_t->type~io_writer_t writer type~snapshot_manager_t snapshot_manager_t type~snapshot_manager_t->type~writer_session_t snapshot_writer type~io_manager_t io_manager_t type~io_manager_t->type~snapshot_manager_t snapshot_mgr type~base_case_t base_case_t type~base_case_t->type~io_manager_t checkpoint_mgr type~case_channel_t case_channel_t type~case_channel_t->type~base_case_t type~case_cylinder_t case_cylinder_t type~case_cylinder_t->type~base_case_t type~case_generic_t case_generic_t type~case_generic_t->type~base_case_t type~case_tgv_t case_tgv_t type~case_tgv_t->type~base_case_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: init => base_writer_init private  subroutine base_writer_init(self, comm, name) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self integer, intent(in) :: comm character(len=*), intent(in) :: name procedure, public :: open => base_writer_open private  function base_writer_open(self, filename, mode, comm) result(file_handle) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(in) :: mode integer, intent(in) :: comm Return Value class( io_file_t ), allocatable procedure, public :: finalise => base_writer_finalise private  subroutine base_writer_finalise(self) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self generic, public :: write_data => write_data_i8, write_data_integer, write_data_real, write_data_array_3d private  subroutine write_data_i8_dummy(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class(io_dummy_writer_t), intent(inout) :: self character(len=*), intent(in) :: variable_name integer(kind=i8), intent(in) :: value class( io_file_t ), intent(inout) :: file_handle private  subroutine write_data_integer_dummy(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class(io_dummy_writer_t), intent(inout) :: self character(len=*), intent(in) :: variable_name integer, intent(in) :: value class( io_file_t ), intent(inout) :: file_handle private  subroutine write_data_real_dummy(self, variable_name, value, file_handle, use_sp) Arguments Type Intent Optional Attributes Name class(io_dummy_writer_t), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(in) :: value class( io_file_t ), intent(inout) :: file_handle logical, intent(in), optional :: use_sp private  subroutine write_data_array_3d_dummy(self, variable_name, array, file_handle, shape_dims, start_dims, count_dims, use_sp) Arguments Type Intent Optional Attributes Name class(io_dummy_writer_t), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(in) :: array (:,:,:) class( io_file_t ), intent(inout) :: file_handle integer(kind=i8), intent(in) :: shape_dims (3) integer(kind=i8), intent(in) :: start_dims (3) integer(kind=i8), intent(in) :: count_dims (3) logical, intent(in), optional :: use_sp procedure, public :: write_data_i8 private  subroutine write_data_i8(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name integer(kind=i8), intent(in) :: value class( io_file_t ), intent(inout) :: file_handle procedure, public :: write_data_integer private  subroutine write_data_integer(self, variable_name, value, file_handle) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name integer, intent(in) :: value class( io_file_t ), intent(inout) :: file_handle procedure, public :: write_data_real private  subroutine write_data_real(self, variable_name, value, file_handle, use_sp) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(in) :: value class( io_file_t ), intent(inout) :: file_handle logical, intent(in), optional :: use_sp procedure, public :: write_data_array_3d private  subroutine write_data_array_3d(self, variable_name, array, file_handle, shape_dims, start_dims, count_dims, use_sp) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self character(len=*), intent(in) :: variable_name real(kind=dp), intent(in) :: array (:,:,:) class( io_file_t ), intent(inout) :: file_handle integer(kind=i8), intent(in) :: shape_dims (3) integer(kind=i8), intent(in) :: start_dims (3) integer(kind=i8), intent(in) :: count_dims (3) logical, intent(in), optional :: use_sp generic, public :: write_attribute => write_attribute_string, write_attribute_array_1d_real private  subroutine write_attribute_string_dummy(self, attribute_name, value, file_handle) Arguments Type Intent Optional Attributes Name class(io_dummy_writer_t), intent(inout) :: self character(len=*), intent(in) :: attribute_name character(len=*), intent(in) :: value class( io_file_t ), intent(inout) :: file_handle private  subroutine write_attribute_array_1d_real_dummy(self, attribute_name, values, file_handle) Arguments Type Intent Optional Attributes Name class(io_dummy_writer_t), intent(inout) :: self character(len=*), intent(in) :: attribute_name real(kind=dp), intent(in) :: values (:) class( io_file_t ), intent(inout) :: file_handle procedure, public :: write_attribute_string private  subroutine write_attribute_string(self, attribute_name, value, file_handle) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self character(len=*), intent(in) :: attribute_name character(len=*), intent(in) :: value class( io_file_t ), intent(inout) :: file_handle procedure, public :: write_attribute_array_1d_real private  subroutine write_attribute_array_1d_real(self, attribute_name, values, file_handle) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(inout) :: self character(len=*), intent(in) :: attribute_name real(kind=dp), intent(in) :: values (:) class( io_file_t ), intent(inout) :: file_handle","tags":"","url":"type/io_writer_t.html"},{"title":"read – x3d2","text":"interface public  subroutine read(self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( base_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string Description Assigns the member variables either from a file or text source. nml_file can be an absolute or relative path\nnml_string is a character string that contains the namelist.\nFor example, nml_string=\"&foobar_nml foo=0, bar='this'/\"","tags":"","url":"interface/read.html"},{"title":"fft_forward – x3d2","text":"interface public  subroutine fft_forward(self, f_in) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in","tags":"","url":"interface/fft_forward.html"},{"title":"fft_backward – x3d2","text":"interface public  subroutine fft_backward(self, f_out) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out","tags":"","url":"interface/fft_backward.html"},{"title":"fft_postprocess – x3d2","text":"interface public  subroutine fft_postprocess(self) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self","tags":"","url":"interface/fft_postprocess.html"},{"title":"poisson_xxx – x3d2","text":"interface public  subroutine poisson_xxx(self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp","tags":"","url":"interface/poisson_xxx.html"},{"title":"field_process – x3d2","text":"interface public  subroutine field_process(self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"interface/field_process.html"},{"title":"poisson_solver – x3d2","text":"interface public  subroutine poisson_solver(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u","tags":"","url":"interface/poisson_solver.html"},{"title":"transport_equation – x3d2","text":"interface public  subroutine transport_equation(self, rhs, variables) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(inout) :: variables (:)","tags":"","url":"interface/transport_equation.html"},{"title":"boundary_conditions – x3d2","text":"interface public  subroutine boundary_conditions(self) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self Description Applies case-specific boundary coinditions","tags":"","url":"interface/boundary_conditions.html"},{"title":"initial_conditions – x3d2","text":"interface public  subroutine initial_conditions(self) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self Description Sets case-specific initial conditions","tags":"","url":"interface/initial_conditions.html"},{"title":"forcings – x3d2","text":"interface public  subroutine forcings(self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter Description Applies case-specific or model realated forcings after transeq","tags":"","url":"interface/forcings.html"},{"title":"pre_correction – x3d2","text":"interface public  subroutine pre_correction(self, u, v, w) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w Description Applies case-specific pre-correction to the velocity fields before\npressure correction","tags":"","url":"interface/pre_correction.html"},{"title":"postprocess – x3d2","text":"interface public  subroutine postprocess(self, iter, t) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t Description Triggers case-specific postprocessings at user specified intervals","tags":"","url":"interface/postprocess.html"},{"title":"transeq_ders – x3d2","text":"interface public  subroutine transeq_ders(self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps Description transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm.","tags":"","url":"interface/transeq_ders.html"},{"title":"transeq_ders_spec – x3d2","text":"interface public  subroutine transeq_ders_spec(self, dspec, uvw, spec, nu, dirps, sync) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync Description transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm.","tags":"","url":"interface/transeq_ders_spec.html"},{"title":"tds_solve – x3d2","text":"interface public  subroutine tds_solve(self, du, u, tdsops) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops Description transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to tds_solve to the\ncorrect algorithm.","tags":"","url":"interface/tds_solve.html"},{"title":"reorder – x3d2","text":"interface public  subroutine reorder(self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction Description reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast.","tags":"","url":"interface/reorder.html"},{"title":"sum_intox – x3d2","text":"interface public  subroutine sum_intox(self, u, u_) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ Description sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields.","tags":"","url":"interface/sum_intox.html"},{"title":"veccopy – x3d2","text":"interface public  subroutine veccopy(self, dst, src) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src Description copy vectors: y = x","tags":"","url":"interface/veccopy.html"},{"title":"vecadd – x3d2","text":"interface public  subroutine vecadd(self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y Description adds two vectors together: y = a x + b y","tags":"","url":"interface/vecadd.html"},{"title":"vecmult – x3d2","text":"interface public  subroutine vecmult(self, y, x) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x Description pointwise multiplication between two vectors: y(:) = y(:) * x(:)","tags":"","url":"interface/vecmult.html"},{"title":"scalar_product – x3d2","text":"interface public  function scalar_product(self, x, y) result(s) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Description Calculates the scalar product of two input fields","tags":"","url":"interface/scalar_product.html"},{"title":"field_ops – x3d2","text":"interface public  subroutine field_ops(self, f, a) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a Description Scales or shifts a field by a","tags":"","url":"interface/field_ops.html"},{"title":"field_reduce – x3d2","text":"interface public  function field_reduce(self, f) result(s) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) Description Reduces field to a scalar, example: volume integral","tags":"","url":"interface/field_reduce.html"},{"title":"field_max_mean – x3d2","text":"interface public  subroutine field_max_mean(self, max_val, mean_val, f, enforced_data_loc) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc Description Obtains maximum and mean values in a field","tags":"","url":"interface/field_max_mean.html"},{"title":"field_set_face – x3d2","text":"interface public  subroutine field_set_face(self, f, c_start, c_end, face) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face Description A field is a subdomain with a rectangular cuboid shape.\nIt has 6 faces, and these faces are either a subdomain boundary\nor a global domain boundary based on the location of the subdomain.\nThis subroutine allows us to set any of these faces to a value,\n'c_start' and 'c_end' for faces at opposite sides.\n'face' is one of X_FACE, Y_FACE, Z_FACE from common.f90","tags":"","url":"interface/field_set_face.html"},{"title":"copy_data_to_f – x3d2","text":"interface public  subroutine copy_data_to_f(self, f, data) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data Description Copy the specialist data structure from device or host back\nto a regular 3D data array in host memory.","tags":"","url":"interface/copy_data_to_f.html"},{"title":"copy_f_to_data – x3d2","text":"interface public  subroutine copy_f_to_data(self, data, f) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f Description Copy a regular 3D array in host memory into the specialist\ndata structure field that lives on device or host","tags":"","url":"interface/copy_f_to_data.html"},{"title":"alloc_tdsops – x3d2","text":"interface public  subroutine alloc_tdsops(self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","url":"interface/alloc_tdsops.html"},{"title":"init_poisson_fft – x3d2","text":"interface public  subroutine init_poisson_fft(self, mesh, xdirps, ydirps, zdirps, lowmem) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem","tags":"","url":"interface/init_poisson_fft.html"},{"title":"stepper_func – x3d2","text":"interface public  subroutine stepper_func(self, curr, deriv, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self type( flist_t ), intent(inout) :: curr (:) type( flist_t ), intent(in) :: deriv (:) real(kind=dp), intent(in) :: dt","tags":"","url":"interface/stepper_func.html"},{"title":"exec_thom_tds_compact – x3d2","text":"public  subroutine exec_thom_tds_compact(du, u, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u type( cuda_tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads Calls proc~~exec_thom_tds_compact~~CallsGraph proc~exec_thom_tds_compact m_cuda_exec_thom::exec_thom_tds_compact proc~der_univ_thom m_cuda_kernels_thom::der_univ_thom proc~exec_thom_tds_compact->proc~der_univ_thom proc~der_univ_thom_per m_cuda_kernels_thom::der_univ_thom_per proc~exec_thom_tds_compact->proc~der_univ_thom_per Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/exec_thom_tds_compact.html"},{"title":"read_domain_nml – x3d2","text":"public  subroutine read_domain_nml(self, nml_file, nml_string) Type Bound domain_config_t Arguments Type Intent Optional Attributes Name class( domain_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string Namelists Namelist domain_settings Variables Name Type Default Description flow_case_name character(len=20) None L_global real(kind=dp) None dims_global integer None nproc_dir integer None BC_x character(len=20) None BC_y character(len=20) None BC_z character(len=20) None stretching character(len=20) ['uniform', 'uniform', 'uniform'] beta real(kind=dp) None","tags":"","url":"proc/read_domain_nml.html"},{"title":"read_solver_nml – x3d2","text":"public  subroutine read_solver_nml(self, nml_file, nml_string) Type Bound solver_config_t Arguments Type Intent Optional Attributes Name class( solver_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string Namelists Namelist solver_params Variables Name Type Default Description Re real(kind=dp) None dt real(kind=dp) None n_iters integer None n_output integer None poisson_solver_type character(len=3) 'FFT' n_species integer 0 pr_species real(kind=dp) 1._dp lowmem_transeq logical .false. triggers the low memory implementations lowmem_fft logical .false. triggers the low memory implementations time_intg character(len=3) None der1st_scheme character(len=30) 'compact6' der2nd_scheme character(len=30) 'compact6' interpl_scheme character(len=30) 'classic' stagder_scheme character(len=30) 'compact6' ibm_on logical .false.","tags":"","url":"proc/read_solver_nml.html"},{"title":"read_channel_nml – x3d2","text":"public  subroutine read_channel_nml(self, nml_file, nml_string) Type Bound channel_config_t Arguments Type Intent Optional Attributes Name class( channel_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string Namelists Namelist channel_nml Variables Name Type Default Description noise real(kind=dp) None rotation logical None omega_rot real(kind=dp) None n_rotate integer None","tags":"","url":"proc/read_channel_nml.html"},{"title":"read_cylinder_nml – x3d2","text":"public  subroutine read_cylinder_nml(self, nml_file, nml_string) Type Bound cylinder_config_t Arguments Type Intent Optional Attributes Name class( cylinder_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string Namelists Namelist cylinder_nml Variables Name Type Default Description init_noise real(kind=dp) None","tags":"","url":"proc/read_cylinder_nml.html"},{"title":"read_checkpoint_nml – x3d2","text":"public  subroutine read_checkpoint_nml(self, nml_file, nml_string) Type Bound checkpoint_config_t Arguments Type Intent Optional Attributes Name class( checkpoint_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string Namelists Namelist checkpoint_params Variables Name Type Default Description checkpoint_freq integer 0 snapshot_freq integer 0 keep_checkpoint logical .false. checkpoint_prefix character(len=256) \"checkpoint\" snapshot_prefix character(len=256) \"snapshot\" restart_from_checkpoint logical .false. restart_file character(len=256) \"\" output_stride integer [1, 1, 1] snapshot_sp logical .false.","tags":"","url":"proc/read_checkpoint_nml.html"},{"title":"case_generic_init – x3d2","text":"public  function case_generic_init(backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_generic_t ) Calls proc~~case_generic_init~~CallsGraph proc~case_generic_init m_case_generic::case_generic_init proc~case_init m_base_case::base_case_t%case_init proc~case_generic_init->proc~case_init initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_argument m_common::get_argument proc~init~5->proc~get_argument proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~case_generic_init~~CalledByGraph proc~case_generic_init m_case_generic::case_generic_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/case_generic_init.html"},{"title":"boundary_conditions_generic – x3d2","text":"public  subroutine boundary_conditions_generic(self) Type Bound case_generic_t Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self","tags":"","url":"proc/boundary_conditions_generic.html"},{"title":"initial_conditions_generic – x3d2","text":"public  subroutine initial_conditions_generic(self) Type Bound case_generic_t Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self Calls proc~~initial_conditions_generic~~CallsGraph proc~initial_conditions_generic m_case_generic::case_generic_t%initial_conditions_generic proc~fill m_field::field_t%fill proc~initial_conditions_generic->proc~fill proc~set_data_loc m_field::field_t%set_data_loc proc~initial_conditions_generic->proc~set_data_loc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/initial_conditions_generic.html"},{"title":"forcings_generic – x3d2","text":"public  subroutine forcings_generic(self, du, dv, dw, iter) Type Bound case_generic_t Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter","tags":"","url":"proc/forcings_generic.html"},{"title":"pre_correction_generic – x3d2","text":"public  subroutine pre_correction_generic(self, u, v, w) Type Bound case_generic_t Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w","tags":"","url":"proc/pre_correction_generic.html"},{"title":"postprocess_generic – x3d2","text":"public  subroutine postprocess_generic(self, iter, t) Type Bound case_generic_t Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t Calls proc~~postprocess_generic~~CallsGraph proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~is_root m_mesh_content::par_t%is_root proc~postprocess_generic->proc~is_root proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~postprocess_generic->proc~print_div_max_mean proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~postprocess_generic->proc~print_enstrophy proc~print_div_max_mean->proc~is_root field_max_mean field_max_mean proc~print_div_max_mean->field_max_mean proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~print_div_max_mean->proc~divergence_v2p proc~get_block m_allocator::allocator_t%get_block proc~print_div_max_mean->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~print_div_max_mean->proc~release_block proc~print_enstrophy->proc~is_root proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~print_enstrophy->proc~get_block proc~print_enstrophy->proc~release_block scalar_product scalar_product proc~print_enstrophy->scalar_product proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl~2->proc~curl proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~curl->proc~get_block proc~curl->proc~release_block reorder reorder proc~curl->reorder tds_solve tds_solve proc~curl->tds_solve vecadd vecadd proc~curl->vecadd proc~divergence_v2c->proc~get_block proc~divergence_v2c->proc~release_block proc~divergence_v2c->reorder proc~divergence_v2c->tds_solve proc~divergence_v2c->vecadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/postprocess_generic.html"},{"title":"case_generic_t – x3d2","text":"public interface case_generic_t Calls interface~~case_generic_t~~CallsGraph interface~case_generic_t m_case_generic::case_generic_t proc~case_generic_init m_case_generic::case_generic_init interface~case_generic_t->proc~case_generic_init proc~case_init m_base_case::base_case_t%case_init proc~case_generic_init->proc~case_init initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_argument m_common::get_argument proc~init~5->proc~get_argument proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function case_generic_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_generic_t )","tags":"","url":"interface/case_generic_t.html"},{"title":"process_spectral_000 – x3d2","text":"public  subroutine process_spectral_000(div_u, waves, nx_spec, ny_spec, nz_spec, x_sp_st, y_sp_st, z_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-process div U* in spectral space for all periodic BCs. Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in) :: nx_spec Grid size in spectral space integer, intent(in) :: ny_spec Grid size in spectral space integer, intent(in) :: nz_spec Grid size in spectral space integer, intent(in) :: x_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: y_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: z_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: nx Global cell size integer, intent(in) :: ny Global cell size integer, intent(in) :: nz Global cell size real(kind=dp), intent(in), dimension(:) :: ax real(kind=dp), intent(in), dimension(:) :: bx real(kind=dp), intent(in), dimension(:) :: ay real(kind=dp), intent(in), dimension(:) :: by real(kind=dp), intent(in), dimension(:) :: az real(kind=dp), intent(in), dimension(:) :: bz Called by proc~~process_spectral_000~~CalledByGraph proc~process_spectral_000 m_omp_spectral::process_spectral_000 proc~fft_postprocess_000_omp m_omp_poisson_fft::omp_poisson_fft_t%fft_postprocess_000_omp proc~fft_postprocess_000_omp->proc~process_spectral_000 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/process_spectral_000.html"},{"title":"process_spectral_010 – x3d2","text":"public  subroutine process_spectral_010(div_u, waves, nx_spec, ny_spec, nz_spec, x_sp_st, y_sp_st, z_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-process div U* in spectral space, for non-periodic BC in y-dir. Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in) :: nx_spec Grid size in spectral space integer, intent(in) :: ny_spec Grid size in spectral space integer, intent(in) :: nz_spec Grid size in spectral space integer, intent(in) :: x_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: y_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: z_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: nx Global cell size integer, intent(in) :: ny Global cell size integer, intent(in) :: nz Global cell size real(kind=dp), intent(in), dimension(:) :: ax real(kind=dp), intent(in), dimension(:) :: bx real(kind=dp), intent(in), dimension(:) :: ay real(kind=dp), intent(in), dimension(:) :: by real(kind=dp), intent(in), dimension(:) :: az real(kind=dp), intent(in), dimension(:) :: bz Called by proc~~process_spectral_010~~CalledByGraph proc~process_spectral_010 m_omp_spectral::process_spectral_010 proc~fft_postprocess_010_omp m_omp_poisson_fft::omp_poisson_fft_t%fft_postprocess_010_omp proc~fft_postprocess_010_omp->proc~process_spectral_010 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/process_spectral_010.html"},{"title":"sendrecv_fields – x3d2","text":"public  subroutine sendrecv_fields(f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next Calls proc~~sendrecv_fields~~CallsGraph proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sendrecv_fields~~CalledByGraph proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~exec_dist_tds_compact~2 m_omp_exec_dist::exec_dist_tds_compact proc~exec_dist_tds_compact~2->proc~sendrecv_fields proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~exec_dist_transeq_compact->proc~sendrecv_fields proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~tds_solve_dist->proc~sendrecv_fields proc~tds_solve_dist->proc~exec_dist_tds_compact~2 proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~sendrecv_fields proc~transeq_omp_dist->proc~exec_dist_transeq_compact proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~sendrecv_fields proc~transeq_species_omp->proc~exec_dist_transeq_compact proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~tds_solve_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sendrecv_fields.html"},{"title":"init – x3d2","text":"public  function init(mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) Calls proc~~init~~CallsGraph proc~init m_omp_backend::init proc~base_init~2 m_base_backend::base_backend_t%base_init proc~init->proc~base_init~2 proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~init->proc~get_n_groups Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init~~CalledByGraph proc~init m_omp_backend::init interface~omp_backend_t m_omp_backend::omp_backend_t interface~omp_backend_t->proc~init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/init.html"},{"title":"scalar_product_omp – x3d2","text":"public  function scalar_product_omp(self, x, y) result(s) m_base_backend Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Calls proc~~scalar_product_omp~~CallsGraph proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp mpi_allreduce mpi_allreduce proc~scalar_product_omp->mpi_allreduce proc~get_block m_allocator::allocator_t%get_block proc~scalar_product_omp->proc~get_block proc~get_dims m_mesh::mesh_t%get_dims proc~scalar_product_omp->proc~get_dims proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~scalar_product_omp->proc~get_field_data proc~release_block m_allocator::allocator_t%release_block proc~scalar_product_omp->proc~release_block proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~get_field_data->proc~get_block proc~get_field_data->proc~release_block copy_f_to_data copy_f_to_data proc~get_field_data->copy_f_to_data proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~get_field_data->proc~get_rdr_from_dirs reorder reorder proc~get_field_data->reorder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/scalar_product_omp.html"},{"title":"field_volume_integral_omp – x3d2","text":"public  function field_volume_integral_omp(self, f) result(s) volume integral of a field Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) Calls proc~~field_volume_integral_omp~~CallsGraph proc~field_volume_integral_omp m_omp_backend::omp_backend_t%field_volume_integral_omp mpi_allreduce mpi_allreduce proc~field_volume_integral_omp->mpi_allreduce proc~get_dims m_mesh::mesh_t%get_dims proc~field_volume_integral_omp->proc~get_dims proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_volume_integral_omp.html"},{"title":"alloc_omp_tdsops – x3d2","text":"public  subroutine alloc_omp_tdsops(self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","url":"proc/alloc_omp_tdsops.html"},{"title":"transeq_x_omp – x3d2","text":"public  subroutine transeq_x_omp(self, du, dv, dw, u, v, w, nu, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps Calls proc~~transeq_x_omp~~CallsGraph proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_x_omp->proc~transeq_omp_dist none~get_n m_mesh::mesh_t%get_n proc~transeq_omp_dist->none~get_n proc~copy_into_buffers m_omp_backend::copy_into_buffers proc~transeq_omp_dist->proc~copy_into_buffers proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~transeq_omp_dist->proc~exec_dist_transeq_compact proc~get_block m_allocator::allocator_t%get_block proc~transeq_omp_dist->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_omp_dist->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_omp_dist->proc~release_block proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~transeq_omp_dist->proc~sendrecv_fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_omp_dist->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi proc~exec_dist_transeq_compact->proc~sendrecv_fields proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_transeq_compact->proc~der_univ_dist proc~der_univ_fused_subs m_omp_kernels_dist::der_univ_fused_subs proc~exec_dist_transeq_compact->proc~der_univ_fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_x_omp.html"},{"title":"transeq_y_omp – x3d2","text":"public  subroutine transeq_y_omp(self, du, dv, dw, u, v, w, nu, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps Calls proc~~transeq_y_omp~~CallsGraph proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_y_omp->proc~transeq_omp_dist none~get_n m_mesh::mesh_t%get_n proc~transeq_omp_dist->none~get_n proc~copy_into_buffers m_omp_backend::copy_into_buffers proc~transeq_omp_dist->proc~copy_into_buffers proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~transeq_omp_dist->proc~exec_dist_transeq_compact proc~get_block m_allocator::allocator_t%get_block proc~transeq_omp_dist->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_omp_dist->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_omp_dist->proc~release_block proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~transeq_omp_dist->proc~sendrecv_fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_omp_dist->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi proc~exec_dist_transeq_compact->proc~sendrecv_fields proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_transeq_compact->proc~der_univ_dist proc~der_univ_fused_subs m_omp_kernels_dist::der_univ_fused_subs proc~exec_dist_transeq_compact->proc~der_univ_fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_y_omp.html"},{"title":"transeq_z_omp – x3d2","text":"public  subroutine transeq_z_omp(self, du, dv, dw, u, v, w, nu, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps Calls proc~~transeq_z_omp~~CallsGraph proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_z_omp->proc~transeq_omp_dist none~get_n m_mesh::mesh_t%get_n proc~transeq_omp_dist->none~get_n proc~copy_into_buffers m_omp_backend::copy_into_buffers proc~transeq_omp_dist->proc~copy_into_buffers proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~transeq_omp_dist->proc~exec_dist_transeq_compact proc~get_block m_allocator::allocator_t%get_block proc~transeq_omp_dist->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_omp_dist->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_omp_dist->proc~release_block proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~transeq_omp_dist->proc~sendrecv_fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_omp_dist->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi proc~exec_dist_transeq_compact->proc~sendrecv_fields proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_transeq_compact->proc~der_univ_dist proc~der_univ_fused_subs m_omp_kernels_dist::der_univ_fused_subs proc~exec_dist_transeq_compact->proc~der_univ_fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_z_omp.html"},{"title":"transeq_species_omp – x3d2","text":"public  subroutine transeq_species_omp(self, dspec, uvw, spec, nu, dirps, sync) Compute the convection and diffusion for the given field\nin the given direction.\nHalo exchange for the given field is necessary\nWhen sync is true, halo exchange of momentum is necessary Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync Calls proc~~transeq_species_omp~~CallsGraph proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~copy_into_buffers m_omp_backend::copy_into_buffers proc~transeq_species_omp->proc~copy_into_buffers proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~transeq_species_omp->proc~exec_dist_transeq_compact proc~get_block m_allocator::allocator_t%get_block proc~transeq_species_omp->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_species_omp->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_species_omp->proc~release_block proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~transeq_species_omp->proc~sendrecv_fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_species_omp->proc~set_data_loc proc~exec_dist_transeq_compact->proc~sendrecv_fields proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_transeq_compact->proc~der_univ_dist proc~der_univ_fused_subs m_omp_kernels_dist::der_univ_fused_subs proc~exec_dist_transeq_compact->proc~der_univ_fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_species_omp.html"},{"title":"transeq_omp_dist – x3d2","text":"public  subroutine transeq_omp_dist(self, du, dv, dw, u, v, w, nu, dirps) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps Calls proc~~transeq_omp_dist~~CallsGraph proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist none~get_n m_mesh::mesh_t%get_n proc~transeq_omp_dist->none~get_n proc~copy_into_buffers m_omp_backend::copy_into_buffers proc~transeq_omp_dist->proc~copy_into_buffers proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~transeq_omp_dist->proc~exec_dist_transeq_compact proc~get_block m_allocator::allocator_t%get_block proc~transeq_omp_dist->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_omp_dist->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_omp_dist->proc~release_block proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~transeq_omp_dist->proc~sendrecv_fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_omp_dist->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi proc~exec_dist_transeq_compact->proc~sendrecv_fields proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_transeq_compact->proc~der_univ_dist proc~der_univ_fused_subs m_omp_kernels_dist::der_univ_fused_subs proc~exec_dist_transeq_compact->proc~der_univ_fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transeq_omp_dist~~CalledByGraph proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_omp_dist.html"},{"title":"tds_solve_omp – x3d2","text":"public  subroutine tds_solve_omp(self, du, u, tdsops) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops Calls proc~~tds_solve_omp~~CallsGraph proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~move_data_loc m_common::move_data_loc proc~tds_solve_omp->proc~move_data_loc proc~set_data_loc m_field::field_t%set_data_loc proc~tds_solve_omp->proc~set_data_loc proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~tds_solve_omp->proc~tds_solve_dist proc~copy_into_buffers m_omp_backend::copy_into_buffers proc~tds_solve_dist->proc~copy_into_buffers proc~exec_dist_tds_compact~2 m_omp_exec_dist::exec_dist_tds_compact proc~tds_solve_dist->proc~exec_dist_tds_compact~2 proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~tds_solve_dist->proc~get_n_groups proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~tds_solve_dist->proc~sendrecv_fields proc~exec_dist_tds_compact~2->proc~sendrecv_fields proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_tds_compact~2->proc~der_univ_dist proc~der_univ_subs m_omp_kernels_dist::der_univ_subs proc~exec_dist_tds_compact~2->proc~der_univ_subs mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/tds_solve_omp.html"},{"title":"tds_solve_dist – x3d2","text":"public  subroutine tds_solve_dist(self, du, u, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops Calls proc~~tds_solve_dist~~CallsGraph proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~copy_into_buffers m_omp_backend::copy_into_buffers proc~tds_solve_dist->proc~copy_into_buffers proc~exec_dist_tds_compact~2 m_omp_exec_dist::exec_dist_tds_compact proc~tds_solve_dist->proc~exec_dist_tds_compact~2 proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~tds_solve_dist->proc~get_n_groups proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~tds_solve_dist->proc~sendrecv_fields proc~exec_dist_tds_compact~2->proc~sendrecv_fields proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_tds_compact~2->proc~der_univ_dist proc~der_univ_subs m_omp_kernels_dist::der_univ_subs proc~exec_dist_tds_compact~2->proc~der_univ_subs mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tds_solve_dist~~CalledByGraph proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~tds_solve_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/tds_solve_dist.html"},{"title":"reorder_omp – x3d2","text":"public  subroutine reorder_omp(self, u_, u, direction) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction Calls proc~~reorder_omp~~CallsGraph proc~reorder_omp m_omp_backend::omp_backend_t%reorder_omp proc~get_dirs_from_rdr m_common::get_dirs_from_rdr proc~reorder_omp->proc~get_dirs_from_rdr proc~get_index_reordering m_ordering::get_index_reordering proc~reorder_omp->proc~get_index_reordering proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~reorder_omp->proc~get_padded_dims proc~set_data_loc m_field::field_t%set_data_loc proc~reorder_omp->proc~set_data_loc proc~get_index_dir m_ordering::get_index_dir proc~get_index_reordering->proc~get_index_dir proc~get_index_ijk m_ordering::get_index_ijk proc~get_index_reordering->proc~get_index_ijk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_omp.html"},{"title":"sum_yintox_omp – x3d2","text":"public  subroutine sum_yintox_omp(self, u, u_) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ Calls proc~~sum_yintox_omp~~CallsGraph proc~sum_yintox_omp m_omp_backend::omp_backend_t%sum_yintox_omp proc~sum_intox_omp m_omp_backend::sum_intox_omp proc~sum_yintox_omp->proc~sum_intox_omp proc~get_index_reordering m_ordering::get_index_reordering proc~sum_intox_omp->proc~get_index_reordering proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~sum_intox_omp->proc~get_padded_dims proc~get_index_dir m_ordering::get_index_dir proc~get_index_reordering->proc~get_index_dir proc~get_index_ijk m_ordering::get_index_ijk proc~get_index_reordering->proc~get_index_ijk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sum_yintox_omp.html"},{"title":"sum_zintox_omp – x3d2","text":"public  subroutine sum_zintox_omp(self, u, u_) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ Calls proc~~sum_zintox_omp~~CallsGraph proc~sum_zintox_omp m_omp_backend::omp_backend_t%sum_zintox_omp proc~sum_intox_omp m_omp_backend::sum_intox_omp proc~sum_zintox_omp->proc~sum_intox_omp proc~get_index_reordering m_ordering::get_index_reordering proc~sum_intox_omp->proc~get_index_reordering proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~sum_intox_omp->proc~get_padded_dims proc~get_index_dir m_ordering::get_index_dir proc~get_index_reordering->proc~get_index_dir proc~get_index_ijk m_ordering::get_index_ijk proc~get_index_reordering->proc~get_index_ijk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sum_zintox_omp.html"},{"title":"sum_intox_omp – x3d2","text":"public  subroutine sum_intox_omp(self, u, u_, dir_to) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ integer, intent(in) :: dir_to Calls proc~~sum_intox_omp~~CallsGraph proc~sum_intox_omp m_omp_backend::sum_intox_omp proc~get_index_reordering m_ordering::get_index_reordering proc~sum_intox_omp->proc~get_index_reordering proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~sum_intox_omp->proc~get_padded_dims proc~get_index_dir m_ordering::get_index_dir proc~get_index_reordering->proc~get_index_dir proc~get_index_ijk m_ordering::get_index_ijk proc~get_index_reordering->proc~get_index_ijk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_intox_omp~~CalledByGraph proc~sum_intox_omp m_omp_backend::sum_intox_omp proc~sum_yintox_omp m_omp_backend::omp_backend_t%sum_yintox_omp proc~sum_yintox_omp->proc~sum_intox_omp proc~sum_zintox_omp m_omp_backend::omp_backend_t%sum_zintox_omp proc~sum_zintox_omp->proc~sum_intox_omp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sum_intox_omp.html"},{"title":"veccopy_omp – x3d2","text":"public  subroutine veccopy_omp(self, dst, src) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src","tags":"","url":"proc/veccopy_omp.html"},{"title":"vecadd_omp – x3d2","text":"public  subroutine vecadd_omp(self, a, x, b, y) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y","tags":"","url":"proc/vecadd_omp.html"},{"title":"vecmult_omp – x3d2","text":"public  subroutine vecmult_omp(self, y, x) m_base_backend Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x","tags":"","url":"proc/vecmult_omp.html"},{"title":"copy_into_buffers – x3d2","text":"public  subroutine copy_into_buffers(u_send_s, u_send_e, u, n, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), dimension(:, :, :) :: u integer, intent(in) :: n integer, intent(in) :: n_groups Called by proc~~copy_into_buffers~~CalledByGraph proc~copy_into_buffers m_omp_backend::copy_into_buffers proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~tds_solve_dist->proc~copy_into_buffers proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~copy_into_buffers proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~copy_into_buffers proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~tds_solve_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/copy_into_buffers.html"},{"title":"field_max_mean_omp – x3d2","text":"public  subroutine field_max_mean_omp(self, max_val, mean_val, f, enforced_data_loc) m_base_backend Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc Calls proc~~field_max_mean_omp~~CallsGraph proc~field_max_mean_omp m_omp_backend::omp_backend_t%field_max_mean_omp mpi_allreduce mpi_allreduce proc~field_max_mean_omp->mpi_allreduce proc~get_dims m_mesh::mesh_t%get_dims proc~field_max_mean_omp->proc~get_dims proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~field_max_mean_omp->proc~get_global_dims proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~field_max_mean_omp->proc~get_padded_dims proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_max_mean_omp.html"},{"title":"field_scale_omp – x3d2","text":"public  subroutine field_scale_omp(self, f, a) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a","tags":"","url":"proc/field_scale_omp.html"},{"title":"field_shift_omp – x3d2","text":"public  subroutine field_shift_omp(self, f, a) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a","tags":"","url":"proc/field_shift_omp.html"},{"title":"field_set_face_omp – x3d2","text":"public  subroutine field_set_face_omp(self, f, c_start, c_end, face) m_base_backend Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face Calls proc~~field_set_face_omp~~CallsGraph proc~field_set_face_omp m_omp_backend::omp_backend_t%field_set_face_omp proc~get_dims m_mesh::mesh_t%get_dims proc~field_set_face_omp->proc~get_dims proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_set_face_omp.html"},{"title":"copy_data_to_f_omp – x3d2","text":"public  subroutine copy_data_to_f_omp(self, f, data) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data","tags":"","url":"proc/copy_data_to_f_omp.html"},{"title":"copy_f_to_data_omp – x3d2","text":"public  subroutine copy_f_to_data_omp(self, data, f) Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f","tags":"","url":"proc/copy_f_to_data_omp.html"},{"title":"init_omp_poisson_fft – x3d2","text":"public  subroutine init_omp_poisson_fft(self, mesh, xdirps, ydirps, zdirps, lowmem) Uses m_omp_poisson_fft proc~~init_omp_poisson_fft~~UsesGraph proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft module~m_omp_poisson_fft m_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft decomp_2d_constants decomp_2d_constants module~m_omp_poisson_fft->decomp_2d_constants decomp_2d_fft decomp_2d_fft module~m_omp_poisson_fft->decomp_2d_fft module~m_common m_common module~m_omp_poisson_fft->module~m_common module~m_field m_field module~m_omp_poisson_fft->module~m_field module~m_mesh m_mesh module~m_omp_poisson_fft->module~m_mesh module~m_omp_spectral m_omp_spectral module~m_omp_poisson_fft->module~m_omp_spectral module~m_poisson_fft m_poisson_fft module~m_omp_poisson_fft->module~m_poisson_fft module~m_tdsops m_tdsops module~m_omp_poisson_fft->module~m_tdsops mpi mpi module~m_common->mpi module~m_field->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field iso_fortran_env iso_fortran_env module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_mesh->mpi module~m_omp_spectral->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound omp_backend_t Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem","tags":"","url":"proc/init_omp_poisson_fft.html"},{"title":"omp_backend_t – x3d2","text":"public interface omp_backend_t Calls interface~~omp_backend_t~~CallsGraph interface~omp_backend_t m_omp_backend::omp_backend_t proc~init m_omp_backend::init interface~omp_backend_t->proc~init proc~base_init~2 m_base_backend::base_backend_t%base_init proc~init->proc~base_init~2 proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~init->proc~get_n_groups Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t )","tags":"","url":"interface/omp_backend_t.html"},{"title":"get_default_backend – x3d2","text":"public  function get_default_backend() result(backend) Arguments None Return Value integer","tags":"","url":"proc/get_default_backend.html"},{"title":"allocate_io_reader – x3d2","text":"public  subroutine allocate_io_reader(reader) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(out), allocatable :: reader","tags":"","url":"proc/allocate_io_reader.html"},{"title":"allocate_io_writer – x3d2","text":"public  subroutine allocate_io_writer(writer) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(out), allocatable :: writer","tags":"","url":"proc/allocate_io_writer.html"},{"title":"allocator_init – x3d2","text":"public  function allocator_init(dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( allocator_t ) Called by proc~~allocator_init~~CalledByGraph proc~allocator_init m_allocator::allocator_init interface~allocator_t m_allocator::allocator_t interface~allocator_t->proc~allocator_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/allocator_init.html"},{"title":"create_block – x3d2","text":"public  function create_block(self, next) result(ptr) Allocate memory for a new block and return a pointer to a new m_allocator object. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer Called by proc~~create_block~~CalledByGraph proc~create_block m_allocator::allocator_t%create_block proc~get_block m_allocator::allocator_t%get_block proc~get_block->proc~create_block proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl->proc~get_block proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2c->proc~get_block proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~get_field_data->proc~get_block proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_c2v->proc~get_block proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~get_block proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~initial_conditions_channel->proc~set_field_data proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~get_block proc~initial_conditions_cylinder->proc~set_field_data proc~init~10 m_time_integrator::init proc~init~10->proc~get_block proc~init~5 m_solver::init proc~init~5->proc~get_block proc~laplacian m_vector_calculus::vector_calculus_t%laplacian proc~laplacian->proc~get_block proc~poisson_fft m_solver::poisson_fft proc~poisson_fft->proc~get_block proc~pressure_correction m_solver::solver_t%pressure_correction proc~pressure_correction->proc~get_block proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~pressure_correction->proc~divergence_v2p proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~pressure_correction->proc~gradient_p2v proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~print_div_max_mean->proc~get_block proc~print_div_max_mean->proc~divergence_v2p proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~print_enstrophy->proc~get_block proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~get_block proc~run m_base_case::base_case_t%run proc~run->proc~get_block proc~run->proc~pressure_correction none~handle_io_step m_io_manager::io_manager_t%handle_io_step proc~run->none~handle_io_step proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp proc~scalar_product_omp->proc~get_block proc~scalar_product_omp->proc~get_field_data proc~set_field_data->proc~get_block proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~get_block proc~set_init->proc~set_field_data proc~setup_field_arrays m_io_field_utils::setup_field_arrays proc~setup_field_arrays->proc~get_block proc~setup_field_arrays->proc~get_field_data proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~get_block proc~transeq_default m_solver::transeq_default proc~transeq_default->proc~get_block proc~transeq_species m_solver::solver_t%transeq_species proc~transeq_default->proc~transeq_species proc~transeq_lowmem m_solver::transeq_lowmem proc~transeq_lowmem->proc~get_block proc~transeq_lowmem->proc~transeq_species proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~get_block proc~transeq_species->proc~get_block proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~get_block proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~get_block interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 interface~time_intg_t m_time_integrator::time_intg_t interface~time_intg_t->proc~init~10 none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~setup_field_arrays none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~set_field_data none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~setup_field_arrays proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart proc~curl~2->proc~curl proc~divergence_v2p->proc~divergence_v2c proc~gradient_p2v->proc~gradient_c2v proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_div_max_mean proc~postprocess_channel->proc~print_enstrophy proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_div_max_mean proc~postprocess_cylinder->proc~print_enstrophy proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_div_max_mean proc~postprocess_generic->proc~print_enstrophy proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_div_max_mean proc~postprocess_tgv->proc~print_enstrophy proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist program~xcompact xcompact program~xcompact->proc~run none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step none~handle_restart->none~handle_restart~2 proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/create_block.html"},{"title":"get_block – x3d2","text":"public  function get_block(self, dir, data_loc) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Example f%data => get_block() Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir integer, intent(in), optional :: data_loc Return Value class( field_t ), pointer Calls proc~~get_block~~CallsGraph proc~get_block m_allocator::allocator_t%get_block proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_block~~CalledByGraph proc~get_block m_allocator::allocator_t%get_block proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl->proc~get_block proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2c->proc~get_block proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~get_field_data->proc~get_block proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_c2v->proc~get_block proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~get_block proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~initial_conditions_channel->proc~set_field_data proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~get_block proc~initial_conditions_cylinder->proc~set_field_data proc~init~10 m_time_integrator::init proc~init~10->proc~get_block proc~init~5 m_solver::init proc~init~5->proc~get_block proc~laplacian m_vector_calculus::vector_calculus_t%laplacian proc~laplacian->proc~get_block proc~poisson_fft m_solver::poisson_fft proc~poisson_fft->proc~get_block proc~pressure_correction m_solver::solver_t%pressure_correction proc~pressure_correction->proc~get_block proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~pressure_correction->proc~divergence_v2p proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~pressure_correction->proc~gradient_p2v proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~print_div_max_mean->proc~get_block proc~print_div_max_mean->proc~divergence_v2p proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~print_enstrophy->proc~get_block proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~get_block proc~run m_base_case::base_case_t%run proc~run->proc~get_block proc~run->proc~pressure_correction none~handle_io_step m_io_manager::io_manager_t%handle_io_step proc~run->none~handle_io_step proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp proc~scalar_product_omp->proc~get_block proc~scalar_product_omp->proc~get_field_data proc~set_field_data->proc~get_block proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~get_block proc~set_init->proc~set_field_data proc~setup_field_arrays m_io_field_utils::setup_field_arrays proc~setup_field_arrays->proc~get_block proc~setup_field_arrays->proc~get_field_data proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~get_block proc~transeq_default m_solver::transeq_default proc~transeq_default->proc~get_block proc~transeq_species m_solver::solver_t%transeq_species proc~transeq_default->proc~transeq_species proc~transeq_lowmem m_solver::transeq_lowmem proc~transeq_lowmem->proc~get_block proc~transeq_lowmem->proc~transeq_species proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~get_block proc~transeq_species->proc~get_block proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~get_block proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~get_block interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 interface~time_intg_t m_time_integrator::time_intg_t interface~time_intg_t->proc~init~10 none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~setup_field_arrays none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~set_field_data none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~setup_field_arrays proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart proc~curl~2->proc~curl proc~divergence_v2p->proc~divergence_v2c proc~gradient_p2v->proc~gradient_c2v proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_div_max_mean proc~postprocess_channel->proc~print_enstrophy proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_div_max_mean proc~postprocess_cylinder->proc~print_enstrophy proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_div_max_mean proc~postprocess_generic->proc~print_enstrophy proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_div_max_mean proc~postprocess_tgv->proc~print_enstrophy proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist program~xcompact xcompact program~xcompact->proc~run none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step none~handle_restart->none~handle_restart~2 proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_block.html"},{"title":"get_block_ids – x3d2","text":"public  function get_block_ids(self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:)","tags":"","url":"proc/get_block_ids.html"},{"title":"get_padded_dims – x3d2","text":"public  function get_padded_dims(self, dir) result(dims) Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir Return Value integer, (3) Called by proc~~get_padded_dims~~CalledByGraph proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~field_max_mean_cuda m_cuda_backend::cuda_backend_t%field_max_mean_cuda proc~field_max_mean_cuda->proc~get_padded_dims proc~field_max_mean_omp m_omp_backend::omp_backend_t%field_max_mean_omp proc~field_max_mean_omp->proc~get_padded_dims proc~field_volume_integral_cuda m_cuda_backend::cuda_backend_t%field_volume_integral_cuda proc~field_volume_integral_cuda->proc~get_padded_dims proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~get_padded_dims proc~reorder_omp m_omp_backend::omp_backend_t%reorder_omp proc~reorder_omp->proc~get_padded_dims proc~scalar_product_cuda m_cuda_backend::cuda_backend_t%scalar_product_cuda proc~scalar_product_cuda->proc~get_padded_dims proc~sum_intox_omp m_omp_backend::sum_intox_omp proc~sum_intox_omp->proc~get_padded_dims proc~sum_yintox_cuda m_cuda_backend::cuda_backend_t%sum_yintox_cuda proc~sum_yintox_cuda->proc~get_padded_dims proc~sum_zintox_cuda m_cuda_backend::cuda_backend_t%sum_zintox_cuda proc~sum_zintox_cuda->proc~get_padded_dims proc~sum_yintox_omp m_omp_backend::omp_backend_t%sum_yintox_omp proc~sum_yintox_omp->proc~sum_intox_omp proc~sum_zintox_omp m_omp_backend::omp_backend_t%sum_zintox_omp proc~sum_zintox_omp->proc~sum_intox_omp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_padded_dims.html"},{"title":"get_n_groups – x3d2","text":"public  function get_n_groups(self, dir) result(n_groups) Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir Return Value integer Called by proc~~get_n_groups~~CalledByGraph proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~init m_omp_backend::init proc~init->proc~get_n_groups proc~init~9 m_cuda_backend::init proc~init~9->proc~get_n_groups proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~get_n_groups proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_cuda->proc~tds_solve_dist~2 proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~tds_solve_dist->proc~get_n_groups proc~tds_solve_dist~2->proc~get_n_groups proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~get_n_groups proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~get_n_groups proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~get_n_groups proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~get_n_groups interface~cuda_backend_t m_cuda_backend::cuda_backend_t interface~cuda_backend_t->proc~init~9 interface~omp_backend_t m_omp_backend::omp_backend_t interface~omp_backend_t->proc~init proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~tds_solve_dist proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_n_groups.html"},{"title":"release_block – x3d2","text":"public  subroutine release_block(self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle Called by proc~~release_block~~CalledByGraph proc~release_block m_allocator::allocator_t%release_block proc~cleanup_field_arrays m_io_field_utils::cleanup_field_arrays proc~cleanup_field_arrays->proc~release_block proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl->proc~release_block proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2c->proc~release_block proc~finalize m_time_integrator::time_intg_t%finalize proc~finalize->proc~release_block proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~get_field_data->proc~release_block proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_c2v->proc~release_block proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~release_block proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~initial_conditions_channel->proc~set_field_data proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~release_block proc~initial_conditions_cylinder->proc~set_field_data proc~laplacian m_vector_calculus::vector_calculus_t%laplacian proc~laplacian->proc~release_block proc~poisson_fft m_solver::poisson_fft proc~poisson_fft->proc~release_block proc~pressure_correction m_solver::solver_t%pressure_correction proc~pressure_correction->proc~release_block proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~pressure_correction->proc~divergence_v2p proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~pressure_correction->proc~gradient_p2v proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~print_div_max_mean->proc~release_block proc~print_div_max_mean->proc~divergence_v2p proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~print_enstrophy->proc~release_block proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~release_block proc~run m_base_case::base_case_t%run proc~run->proc~release_block proc~run->proc~pressure_correction none~handle_io_step m_io_manager::io_manager_t%handle_io_step proc~run->none~handle_io_step proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp proc~scalar_product_omp->proc~release_block proc~scalar_product_omp->proc~get_field_data proc~set_field_data->proc~release_block proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~release_block proc~set_init->proc~set_field_data proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~release_block proc~transeq_default m_solver::transeq_default proc~transeq_default->proc~release_block proc~transeq_species m_solver::solver_t%transeq_species proc~transeq_default->proc~transeq_species proc~transeq_lowmem m_solver::transeq_lowmem proc~transeq_lowmem->proc~release_block proc~transeq_lowmem->proc~transeq_species proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~release_block proc~transeq_species->proc~release_block proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~release_block proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~release_block none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~cleanup_field_arrays proc~setup_field_arrays m_io_field_utils::setup_field_arrays none~handle_checkpoint_step->proc~setup_field_arrays none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~set_field_data none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~cleanup_field_arrays none~handle_snapshot_step->proc~setup_field_arrays proc~curl~2->proc~curl proc~divergence_v2p->proc~divergence_v2c proc~gradient_p2v->proc~gradient_c2v proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_div_max_mean proc~postprocess_channel->proc~print_enstrophy proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_div_max_mean proc~postprocess_cylinder->proc~print_enstrophy proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_div_max_mean proc~postprocess_generic->proc~print_enstrophy proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_div_max_mean proc~postprocess_tgv->proc~print_enstrophy proc~setup_field_arrays->proc~get_field_data proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist program~xcompact xcompact program~xcompact->proc~run none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step none~handle_restart m_io_manager::io_manager_t%handle_restart none~handle_restart->none~handle_restart~2 proc~case_init m_base_case::base_case_t%case_init proc~case_init->none~handle_restart proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/release_block.html"},{"title":"destroy – x3d2","text":"public  subroutine destroy(self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a m_allocator object automatically\ndeallocates its internal allocatable data array. Type Bound allocator_t Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self","tags":"","url":"proc/destroy.html"},{"title":"allocator_t – x3d2","text":"public interface allocator_t Calls interface~~allocator_t~~CallsGraph interface~allocator_t m_allocator::allocator_t proc~allocator_init m_allocator::allocator_init interface~allocator_t->proc~allocator_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function allocator_init (dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( allocator_t )","tags":"","url":"interface/allocator_t.html"},{"title":"init – x3d2","text":"public  function init(backend) result(vector_calculus) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend Return Value type( vector_calculus_t ) Called by proc~~init~2~~CalledByGraph proc~init~2 m_vector_calculus::init interface~vector_calculus_t m_vector_calculus::vector_calculus_t interface~vector_calculus_t->proc~init~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/init~2.html"},{"title":"curl – x3d2","text":"public  subroutine curl(self, o_i_hat, o_j_hat, o_k_hat, u, v, w, x_der1st, y_der1st, z_der1st) Curl of a vector field (u, v, w). Evaluated at the data_loc defined by u, v, w fields. All the input and output fields are in DIR_X layout. Type Bound vector_calculus_t Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w class( tdsops_t ), intent(in) :: x_der1st class( tdsops_t ), intent(in) :: y_der1st class( tdsops_t ), intent(in) :: z_der1st Calls proc~~curl~~CallsGraph proc~curl m_vector_calculus::vector_calculus_t%curl proc~get_block m_allocator::allocator_t%get_block proc~curl->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~curl->proc~release_block reorder reorder proc~curl->reorder tds_solve tds_solve proc~curl->tds_solve vecadd vecadd proc~curl->vecadd proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~curl~~CalledByGraph proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl~2 m_solver::solver_t%curl proc~curl~2->proc~curl proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~print_enstrophy->proc~curl~2 proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_enstrophy proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_enstrophy proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_enstrophy proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_enstrophy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/curl.html"},{"title":"divergence_v2c – x3d2","text":"public  subroutine divergence_v2c(self, div_u, u, v, w, x_stagder_v2c, x_interpl_v2c, y_stagder_v2c, y_interpl_v2c, z_stagder_v2c, z_interpl_v2c) Divergence of a vector field (u, v, w). Evaluated at the cell centers (data_loc=CELL)\nInput fields are at vertices (data_loc=VERT) Input fields are in DIR_X data layout.\nOutput field is in DIR_Z data layout. Type Bound vector_calculus_t Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w class( tdsops_t ), intent(in) :: x_stagder_v2c class( tdsops_t ), intent(in) :: x_interpl_v2c class( tdsops_t ), intent(in) :: y_stagder_v2c class( tdsops_t ), intent(in) :: y_interpl_v2c class( tdsops_t ), intent(in) :: z_stagder_v2c class( tdsops_t ), intent(in) :: z_interpl_v2c Calls proc~~divergence_v2c~~CallsGraph proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~get_block m_allocator::allocator_t%get_block proc~divergence_v2c->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~divergence_v2c->proc~release_block reorder reorder proc~divergence_v2c->reorder tds_solve tds_solve proc~divergence_v2c->tds_solve vecadd vecadd proc~divergence_v2c->vecadd proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~divergence_v2c~~CalledByGraph proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~divergence_v2p->proc~divergence_v2c proc~pressure_correction m_solver::solver_t%pressure_correction proc~pressure_correction->proc~divergence_v2p proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~print_div_max_mean->proc~divergence_v2p proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_div_max_mean proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_div_max_mean proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_div_max_mean proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_div_max_mean proc~run m_base_case::base_case_t%run proc~run->proc~pressure_correction program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/divergence_v2c.html"},{"title":"gradient_c2v – x3d2","text":"public  subroutine gradient_c2v(self, dpdx, dpdy, dpdz, p, x_stagder_c2v, x_interpl_c2v, y_stagder_c2v, y_interpl_c2v, z_stagder_c2v, z_interpl_c2v) Gradient of a scalar field 'p'. Evaluated at the vertices (data_loc=VERT)\nInput field is at cell centers (data_loc=CELL) Input field is in DIR_Z data layout.\nOutput fields (dpdx, dpdy, dpdz) are in DIR_X data layout. Type Bound vector_calculus_t Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: p class( tdsops_t ), intent(in) :: x_stagder_c2v class( tdsops_t ), intent(in) :: x_interpl_c2v class( tdsops_t ), intent(in) :: y_stagder_c2v class( tdsops_t ), intent(in) :: y_interpl_c2v class( tdsops_t ), intent(in) :: z_stagder_c2v class( tdsops_t ), intent(in) :: z_interpl_c2v Calls proc~~gradient_c2v~~CallsGraph proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~get_block m_allocator::allocator_t%get_block proc~gradient_c2v->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~gradient_c2v->proc~release_block reorder reorder proc~gradient_c2v->reorder tds_solve tds_solve proc~gradient_c2v->tds_solve proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gradient_c2v~~CalledByGraph proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~gradient_p2v->proc~gradient_c2v proc~pressure_correction m_solver::solver_t%pressure_correction proc~pressure_correction->proc~gradient_p2v proc~run m_base_case::base_case_t%run proc~run->proc~pressure_correction program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gradient_c2v.html"},{"title":"laplacian – x3d2","text":"public  subroutine laplacian(self, lapl_u, u, x_der2nd, y_der2nd, z_der2nd) Laplacian of a scalar field 'u'. Evaluated at the data_loc defined by the input u field Input and output fields are in DIR_X layout. Type Bound vector_calculus_t Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: lapl_u class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: x_der2nd class( tdsops_t ), intent(in) :: y_der2nd class( tdsops_t ), intent(in) :: z_der2nd Calls proc~~laplacian~~CallsGraph proc~laplacian m_vector_calculus::vector_calculus_t%laplacian proc~get_block m_allocator::allocator_t%get_block proc~laplacian->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~laplacian->proc~release_block reorder reorder proc~laplacian->reorder sum_yintox sum_yintox proc~laplacian->sum_yintox sum_zintox sum_zintox proc~laplacian->sum_zintox tds_solve tds_solve proc~laplacian->tds_solve proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/laplacian.html"},{"title":"vector_calculus_t – x3d2","text":"public interface vector_calculus_t Calls interface~~vector_calculus_t~~CallsGraph interface~vector_calculus_t m_vector_calculus::vector_calculus_t proc~init~2 m_vector_calculus::init interface~vector_calculus_t->proc~init~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function init (backend) result(vector_calculus) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend Return Value type( vector_calculus_t )","tags":"","url":"interface/vector_calculus_t.html"},{"title":"stride_data – x3d2","text":"public  function stride_data(input_data, dims, stride, output_dims_out) result(output_data) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :, :) :: input_data integer, intent(in), dimension(3) :: dims integer, intent(in), dimension(3) :: stride integer, intent(out), dimension(3) :: output_dims_out Return Value real(kind=dp), dimension(:, :, :), allocatable","tags":"","url":"proc/stride_data.html"},{"title":"stride_data_to_buffer – x3d2","text":"public  subroutine stride_data_to_buffer(input_data, dims, stride, out_buffer, output_dims_out) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :, :) :: input_data integer, intent(in), dimension(3) :: dims integer, intent(in), dimension(3) :: stride real(kind=dp), intent(inout), dimension(:, :, :), allocatable :: out_buffer integer, intent(out), dimension(3) :: output_dims_out Called by proc~~stride_data_to_buffer~~CalledByGraph proc~stride_data_to_buffer m_io_field_utils::stride_data_to_buffer proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer proc~write_single_field_to_buffer->proc~stride_data_to_buffer none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~write_single_field_to_buffer none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~write_single_field_to_buffer none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/stride_data_to_buffer.html"},{"title":"get_output_dimensions – x3d2","text":"public  subroutine get_output_dimensions(shape_dims, start_dims, count_dims, stride_factors, output_shape, output_start, output_count, output_dims_local, last_shape_dims, last_stride_factors, last_output_shape) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in), dimension(3) :: shape_dims integer(kind=i8), intent(in), dimension(3) :: start_dims integer(kind=i8), intent(in), dimension(3) :: count_dims integer, intent(in), dimension(3) :: stride_factors integer(kind=i8), intent(out), dimension(3) :: output_shape integer(kind=i8), intent(out), dimension(3) :: output_start integer(kind=i8), intent(out), dimension(3) :: output_count integer, intent(out), dimension(3) :: output_dims_local integer(kind=i8), intent(inout), optional, dimension(3) :: last_shape_dims integer, intent(inout), optional, dimension(3) :: last_stride_factors integer(kind=i8), intent(inout), optional, dimension(3) :: last_output_shape Called by proc~~get_output_dimensions~~CalledByGraph proc~get_output_dimensions m_io_field_utils::get_output_dimensions none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~get_output_dimensions proc~prepare_field_buffers m_io_field_utils::prepare_field_buffers none~handle_checkpoint_step->proc~prepare_field_buffers proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer none~handle_checkpoint_step->proc~write_single_field_to_buffer none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~get_output_dimensions none~handle_snapshot_step->proc~prepare_field_buffers none~handle_snapshot_step->proc~write_single_field_to_buffer proc~prepare_field_buffers->proc~get_output_dimensions proc~write_single_field_to_buffer->proc~get_output_dimensions none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_output_dimensions.html"},{"title":"generate_coordinates – x3d2","text":"public  subroutine generate_coordinates(solver, writer, file, shape_dims, start_dims, count_dims, data_loc, coords_x, coords_y, coords_z) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: solver class( io_writer_t ), intent(inout) :: writer class( io_file_t ), intent(inout) :: file integer(kind=i8), intent(in), dimension(3) :: shape_dims integer(kind=i8), intent(in), dimension(3) :: start_dims integer(kind=i8), intent(in), dimension(3) :: count_dims integer, intent(in) :: data_loc real(kind=dp), intent(inout), dimension(:, :, :), allocatable :: coords_x real(kind=dp), intent(inout), dimension(:, :, :), allocatable :: coords_y real(kind=dp), intent(inout), dimension(:, :, :), allocatable :: coords_z Calls proc~~generate_coordinates~~CallsGraph proc~generate_coordinates m_io_field_utils::generate_coordinates none~write_data~2 m_io_base::io_writer_t%write_data proc~generate_coordinates->none~write_data~2 proc~get_coordinates m_mesh::mesh_t%get_coordinates proc~generate_coordinates->proc~get_coordinates Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_coordinates.html"},{"title":"setup_field_arrays – x3d2","text":"public  subroutine setup_field_arrays(solver, field_names, field_ptrs, host_fields) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: solver character(len=*), intent(in), dimension(:) :: field_names type( field_ptr_t ), intent(out), allocatable :: field_ptrs (:) type( field_ptr_t ), intent(out), allocatable :: host_fields (:) Calls proc~~setup_field_arrays~~CallsGraph proc~setup_field_arrays m_io_field_utils::setup_field_arrays proc~get_block m_allocator::allocator_t%get_block proc~setup_field_arrays->proc~get_block proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~setup_field_arrays->proc~get_field_data proc~is_root m_mesh_content::par_t%is_root proc~setup_field_arrays->proc~is_root proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_field_data->proc~get_block copy_f_to_data copy_f_to_data proc~get_field_data->copy_f_to_data proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~get_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~get_field_data->proc~release_block reorder reorder proc~get_field_data->reorder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~setup_field_arrays~~CalledByGraph proc~setup_field_arrays m_io_field_utils::setup_field_arrays none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~setup_field_arrays none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~setup_field_arrays none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/setup_field_arrays.html"},{"title":"cleanup_field_arrays – x3d2","text":"public  subroutine cleanup_field_arrays(solver, field_ptrs, host_fields) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: solver type( field_ptr_t ), intent(inout), allocatable :: field_ptrs (:) type( field_ptr_t ), intent(inout), allocatable :: host_fields (:) Calls proc~~cleanup_field_arrays~~CallsGraph proc~cleanup_field_arrays m_io_field_utils::cleanup_field_arrays proc~release_block m_allocator::allocator_t%release_block proc~cleanup_field_arrays->proc~release_block Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cleanup_field_arrays~~CalledByGraph proc~cleanup_field_arrays m_io_field_utils::cleanup_field_arrays none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~cleanup_field_arrays none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~cleanup_field_arrays none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cleanup_field_arrays.html"},{"title":"prepare_field_buffers – x3d2","text":"public  subroutine prepare_field_buffers(solver, stride_factors, field_names, data_loc, field_buffers, last_shape_dims, last_stride_factors, last_output_shape) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: solver integer, intent(in), dimension(3) :: stride_factors character(len=*), intent(in), dimension(:) :: field_names integer, intent(in) :: data_loc type( field_buffer_map_t ), intent(inout), allocatable :: field_buffers (:) integer(kind=i8), intent(inout), dimension(3) :: last_shape_dims integer, intent(inout), dimension(3) :: last_stride_factors integer(kind=i8), intent(inout), dimension(3) :: last_output_shape Calls proc~~prepare_field_buffers~~CallsGraph proc~prepare_field_buffers m_io_field_utils::prepare_field_buffers proc~get_dims m_mesh::mesh_t%get_dims proc~prepare_field_buffers->proc~get_dims proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~prepare_field_buffers->proc~get_global_dims proc~get_output_dimensions m_io_field_utils::get_output_dimensions proc~prepare_field_buffers->proc~get_output_dimensions proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~prepare_field_buffers~~CalledByGraph proc~prepare_field_buffers m_io_field_utils::prepare_field_buffers none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~prepare_field_buffers none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~prepare_field_buffers none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/prepare_field_buffers.html"},{"title":"write_single_field_to_buffer – x3d2","text":"public  subroutine write_single_field_to_buffer(field_name, host_field, solver, stride_factors, data_loc, field_buffers, last_shape_dims, last_stride_factors, last_output_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: field_name class( field_t ), pointer :: host_field class( solver_t ), intent(in) :: solver integer, intent(in), dimension(3) :: stride_factors integer, intent(in) :: data_loc type( field_buffer_map_t ), intent(inout) :: field_buffers (:) integer(kind=i8), intent(inout), dimension(3) :: last_shape_dims integer, intent(inout), dimension(3) :: last_stride_factors integer(kind=i8), intent(inout), dimension(3) :: last_output_shape Calls proc~~write_single_field_to_buffer~~CallsGraph proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer proc~get_dims m_mesh::mesh_t%get_dims proc~write_single_field_to_buffer->proc~get_dims proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~write_single_field_to_buffer->proc~get_global_dims proc~get_output_dimensions m_io_field_utils::get_output_dimensions proc~write_single_field_to_buffer->proc~get_output_dimensions proc~stride_data_to_buffer m_io_field_utils::stride_data_to_buffer proc~write_single_field_to_buffer->proc~stride_data_to_buffer proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_single_field_to_buffer~~CalledByGraph proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~write_single_field_to_buffer none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~write_single_field_to_buffer none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/write_single_field_to_buffer.html"},{"title":"cleanup_field_buffers – x3d2","text":"public  subroutine cleanup_field_buffers(field_buffers) Arguments Type Intent Optional Attributes Name type( field_buffer_map_t ), intent(inout), allocatable :: field_buffers (:) Called by proc~~cleanup_field_buffers~~CalledByGraph proc~cleanup_field_buffers m_io_field_utils::cleanup_field_buffers none~finalise~7 m_checkpoint_manager::checkpoint_manager_t%finalise none~finalise~7->proc~cleanup_field_buffers none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~cleanup_field_buffers none~finalise m_io_manager::io_manager_t%finalise none~finalise->none~finalise~7 none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step proc~case_finalise m_base_case::base_case_t%case_finalise proc~case_finalise->none~finalise proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step proc~run->proc~case_finalise program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cleanup_field_buffers.html"},{"title":"is_avail_2decomp – x3d2","text":"public  function is_avail_2decomp() result(avail) Arguments None Return Value logical Called by proc~~is_avail_2decomp~~CalledByGraph proc~is_avail_2decomp m_decomp::is_avail_2decomp proc~mesh_init m_mesh::mesh_init proc~mesh_init->proc~is_avail_2decomp interface~mesh_t m_mesh::mesh_t interface~mesh_t->proc~mesh_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/is_avail_2decomp.html"},{"title":"decomposition_2decomp – x3d2","text":"public  subroutine decomposition_2decomp(grid, par) Uses m_mesh_content decomp_2d decomp_2d_mpi proc~~decomposition_2decomp~~UsesGraph proc~decomposition_2decomp m_decomp::decomposition_2decomp decomp_2d decomp_2d proc~decomposition_2decomp->decomp_2d decomp_2d_mpi decomp_2d_mpi proc~decomposition_2decomp->decomp_2d_mpi module~m_mesh_content m_mesh_content proc~decomposition_2decomp->module~m_mesh_content module~m_common m_common module~m_mesh_content->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Performs 2D mesh decomposition using 2decomp&fft Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: grid class( par_t ), intent(inout) :: par Calls proc~~decomposition_2decomp~~CallsGraph proc~decomposition_2decomp m_decomp::decomposition_2decomp decomp_2d_init decomp_2d_init proc~decomposition_2decomp->decomp_2d_init mpi_allreduce mpi_allreduce proc~decomposition_2decomp->mpi_allreduce mpi_cart_coords mpi_cart_coords proc~decomposition_2decomp->mpi_cart_coords mpi_comm_rank mpi_comm_rank proc~decomposition_2decomp->mpi_comm_rank proc~compute_rank_pos_from_global m_mesh_content::par_t%compute_rank_pos_from_global proc~decomposition_2decomp->proc~compute_rank_pos_from_global proc~copy_vert2cell_dims m_mesh_content::grid_t%copy_vert2cell_dims proc~decomposition_2decomp->proc~copy_vert2cell_dims proc~is_root m_mesh_content::par_t%is_root proc~decomposition_2decomp->proc~is_root xsize xsize proc~decomposition_2decomp->xsize xstart xstart proc~decomposition_2decomp->xstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~decomposition_2decomp~~CalledByGraph proc~decomposition_2decomp m_decomp::decomposition_2decomp proc~mesh_init m_mesh::mesh_init proc~mesh_init->proc~decomposition_2decomp interface~mesh_t m_mesh::mesh_t interface~mesh_t->proc~mesh_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/decomposition_2decomp.html"},{"title":"sendrecv_fields – x3d2","text":"public  subroutine sendrecv_fields(f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next Calls proc~~sendrecv_fields~2~~CallsGraph proc~sendrecv_fields~2 m_cuda_sendrecv::sendrecv_fields mpi_irecv mpi_irecv proc~sendrecv_fields~2->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields~2->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields~2->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sendrecv_fields~2~~CalledByGraph proc~sendrecv_fields~2 m_cuda_sendrecv::sendrecv_fields proc~exec_dist_tds_compact m_cuda_exec_dist::exec_dist_tds_compact proc~exec_dist_tds_compact->proc~sendrecv_fields~2 proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_dist~2->proc~sendrecv_fields~2 proc~tds_solve_dist~2->proc~exec_dist_tds_compact proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~sendrecv_fields~2 proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~tds_solve_dist~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sendrecv_fields~2.html"},{"title":"sendrecv_3fields – x3d2","text":"public  subroutine sendrecv_3fields(f1_recv_s, f1_recv_e, f2_recv_s, f2_recv_e, f3_recv_s, f3_recv_e, f1_send_s, f1_send_e, f2_send_s, f2_send_e, f3_send_s, f3_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next Calls proc~~sendrecv_3fields~~CallsGraph proc~sendrecv_3fields m_cuda_sendrecv::sendrecv_3fields mpi_irecv mpi_irecv proc~sendrecv_3fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_3fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_3fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sendrecv_3fields~~CalledByGraph proc~sendrecv_3fields m_cuda_sendrecv::sendrecv_3fields proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~exec_dist_transeq_3fused->proc~sendrecv_3fields proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~sendrecv_3fields proc~transeq_cuda_dist->proc~exec_dist_transeq_3fused proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~exec_dist_transeq_3fused proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sendrecv_3fields.html"},{"title":"copy – x3d2","text":"public  subroutine copy(n, dst, src) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: n real(kind=dp), intent(out), device, dimension(:, :, :) :: dst real(kind=dp), intent(in), device, dimension(:, :, :) :: src","tags":"","url":"proc/copy.html"},{"title":"axpby – x3d2","text":"public  subroutine axpby(n, alpha, x, beta, y) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: n real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), value :: beta real(kind=dp), intent(inout), device, dimension(:, :, :) :: y Called by proc~~axpby~~CalledByGraph proc~axpby m_cuda_kernels_fieldops::axpby proc~vecadd_cuda m_cuda_backend::cuda_backend_t%vecadd_cuda proc~vecadd_cuda->proc~axpby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/axpby.html"},{"title":"pwmul – x3d2","text":"public  subroutine pwmul(y, x, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: y real(kind=dp), intent(in), device, dimension(:, :, :) :: x integer, intent(in), value :: n Called by proc~~pwmul~~CalledByGraph proc~pwmul m_cuda_kernels_fieldops::pwmul proc~vecmult_cuda m_cuda_backend::cuda_backend_t%vecmult_cuda proc~vecmult_cuda->proc~pwmul Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/pwmul.html"},{"title":"buffer_copy – x3d2","text":"public  subroutine buffer_copy(u_send_s, u_send_e, u, n, n_halo) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_s real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n integer, intent(in), value :: n_halo Called by proc~~buffer_copy~~CalledByGraph proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~copy_into_buffers~2->proc~buffer_copy proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_dist~2->proc~copy_into_buffers~2 proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~copy_into_buffers~2 proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~copy_into_buffers~2 proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~tds_solve_dist~2 proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/buffer_copy.html"},{"title":"field_scale – x3d2","text":"public  subroutine field_scale(f, alpha, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: f real(kind=dp), intent(in), value :: alpha integer, intent(in), value :: n Called by proc~~field_scale~~CalledByGraph proc~field_scale m_cuda_kernels_fieldops::field_scale proc~field_scale_cuda m_cuda_backend::cuda_backend_t%field_scale_cuda proc~field_scale_cuda->proc~field_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_scale.html"},{"title":"field_shift – x3d2","text":"public  subroutine field_shift(f, const, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: f real(kind=dp), intent(in), value :: const integer, intent(in), value :: n Called by proc~~field_shift~~CalledByGraph proc~field_shift m_cuda_kernels_fieldops::field_shift proc~field_shift_cuda m_cuda_backend::cuda_backend_t%field_shift_cuda proc~field_shift_cuda->proc~field_shift Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_shift.html"},{"title":"scalar_product – x3d2","text":"public  subroutine scalar_product(s, x, y, n, n_i_pad, n_j) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: s real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), device, dimension(:, :, :) :: y integer, intent(in), value :: n integer, intent(in), value :: n_i_pad integer, intent(in), value :: n_j Calls proc~~scalar_product~~CallsGraph proc~scalar_product m_cuda_kernels_fieldops::scalar_product atomicadd atomicadd proc~scalar_product->atomicadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~scalar_product~~CalledByGraph proc~scalar_product m_cuda_kernels_fieldops::scalar_product proc~scalar_product_cuda m_cuda_backend::cuda_backend_t%scalar_product_cuda proc~scalar_product_cuda->proc~scalar_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/scalar_product.html"},{"title":"field_max_sum – x3d2","text":"public  subroutine field_max_sum(max_f, sum_f, f, n, n_i_pad, n_j) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: max_f real(kind=dp), intent(inout), device :: sum_f real(kind=dp), intent(in), device, dimension(:, :, :) :: f integer, intent(in), value :: n integer, intent(in), value :: n_i_pad integer, intent(in), value :: n_j Calls proc~~field_max_sum~~CallsGraph proc~field_max_sum m_cuda_kernels_fieldops::field_max_sum atomicadd atomicadd proc~field_max_sum->atomicadd atomicmax atomicmax proc~field_max_sum->atomicmax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~field_max_sum~~CalledByGraph proc~field_max_sum m_cuda_kernels_fieldops::field_max_sum proc~field_max_mean_cuda m_cuda_backend::cuda_backend_t%field_max_mean_cuda proc~field_max_mean_cuda->proc~field_max_sum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_max_sum.html"},{"title":"field_set_y_face – x3d2","text":"public  subroutine field_set_y_face(f, c_start, c_end, nx, ny, nz) Set domain Y_FACE to a constant\nc_start at the bottom and c_end at the top Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: f real(kind=dp), intent(in), value :: c_start real(kind=dp), intent(in), value :: c_end integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz Called by proc~~field_set_y_face~~CalledByGraph proc~field_set_y_face m_cuda_kernels_fieldops::field_set_y_face proc~field_set_face_cuda m_cuda_backend::cuda_backend_t%field_set_face_cuda proc~field_set_face_cuda->proc~field_set_y_face Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_set_y_face.html"},{"title":"volume_integral – x3d2","text":"public  subroutine volume_integral(s, f, n, n_i_pad, n_j) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: s real(kind=dp), intent(in), device, dimension(:, :, :) :: f integer, intent(in), value :: n integer, intent(in), value :: n_i_pad integer, intent(in), value :: n_j Calls proc~~volume_integral~~CallsGraph proc~volume_integral m_cuda_kernels_fieldops::volume_integral atomicadd atomicadd proc~volume_integral->atomicadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~volume_integral~~CalledByGraph proc~volume_integral m_cuda_kernels_fieldops::volume_integral proc~field_volume_integral_cuda m_cuda_backend::cuda_backend_t%field_volume_integral_cuda proc~field_volume_integral_cuda->proc~volume_integral Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/volume_integral.html"},{"title":"get_km_re – x3d2","text":"public  function get_km_re(self, i, j, k) result(re) Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) Calls proc~~get_km_re~~CallsGraph proc~get_km_re m_poisson_fft::poisson_fft_t%get_km_re proc~get_km m_poisson_fft::poisson_fft_t%get_km proc~get_km_re->proc~get_km proc~get_real m_poisson_fft::get_real proc~get_km_re->proc~get_real proc~get_km->proc~get_real proc~get_imag m_poisson_fft::get_imag proc~get_km->proc~get_imag Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_km_re~~CalledByGraph proc~get_km_re m_poisson_fft::poisson_fft_t%get_km_re proc~stretching_matrix m_poisson_fft::poisson_fft_t%stretching_matrix proc~stretching_matrix->proc~get_km_re proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~stretching_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_km_re.html"},{"title":"get_km_im – x3d2","text":"public  function get_km_im(self, i, j, k) result(re) Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) Calls proc~~get_km_im~~CallsGraph proc~get_km_im m_poisson_fft::poisson_fft_t%get_km_im proc~get_imag m_poisson_fft::get_imag proc~get_km_im->proc~get_imag proc~get_km m_poisson_fft::poisson_fft_t%get_km proc~get_km_im->proc~get_km proc~get_km->proc~get_imag proc~get_real m_poisson_fft::get_real proc~get_km->proc~get_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_km_im~~CalledByGraph proc~get_km_im m_poisson_fft::poisson_fft_t%get_km_im proc~stretching_matrix m_poisson_fft::poisson_fft_t%stretching_matrix proc~stretching_matrix->proc~get_km_im proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~stretching_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_km_im.html"},{"title":"get_km – x3d2","text":"public  function get_km(self, i, j, k) result(km) Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value complex(kind=dp) Calls proc~~get_km~~CallsGraph proc~get_km m_poisson_fft::poisson_fft_t%get_km proc~get_imag m_poisson_fft::get_imag proc~get_km->proc~get_imag proc~get_real m_poisson_fft::get_real proc~get_km->proc~get_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_km~~CalledByGraph proc~get_km m_poisson_fft::poisson_fft_t%get_km proc~get_km_im m_poisson_fft::poisson_fft_t%get_km_im proc~get_km_im->proc~get_km proc~get_km_re m_poisson_fft::poisson_fft_t%get_km_re proc~get_km_re->proc~get_km proc~stretching_matrix m_poisson_fft::poisson_fft_t%stretching_matrix proc~stretching_matrix->proc~get_km proc~stretching_matrix->proc~get_km_im proc~stretching_matrix->proc~get_km_re proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~stretching_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_km.html"},{"title":"get_real – x3d2","text":"public  function get_real(complx) result(re) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: complx Return Value real(kind=dp) Called by proc~~get_real~~CalledByGraph proc~get_real m_poisson_fft::get_real proc~get_km m_poisson_fft::poisson_fft_t%get_km proc~get_km->proc~get_real proc~get_km_re m_poisson_fft::poisson_fft_t%get_km_re proc~get_km_re->proc~get_real proc~get_km_re->proc~get_km proc~stretching_matrix m_poisson_fft::poisson_fft_t%stretching_matrix proc~stretching_matrix->proc~get_real proc~stretching_matrix->proc~get_km proc~stretching_matrix->proc~get_km_re proc~get_km_im m_poisson_fft::poisson_fft_t%get_km_im proc~stretching_matrix->proc~get_km_im proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~stretching_matrix proc~get_km_im->proc~get_km Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_real.html"},{"title":"get_imag – x3d2","text":"public  function get_imag(complx) result(im) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: complx Return Value real(kind=dp) Called by proc~~get_imag~~CalledByGraph proc~get_imag m_poisson_fft::get_imag proc~get_km m_poisson_fft::poisson_fft_t%get_km proc~get_km->proc~get_imag proc~get_km_im m_poisson_fft::poisson_fft_t%get_km_im proc~get_km_im->proc~get_imag proc~get_km_im->proc~get_km proc~stretching_matrix m_poisson_fft::poisson_fft_t%stretching_matrix proc~stretching_matrix->proc~get_imag proc~stretching_matrix->proc~get_km proc~stretching_matrix->proc~get_km_im proc~get_km_re m_poisson_fft::poisson_fft_t%get_km_re proc~stretching_matrix->proc~get_km_re proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~stretching_matrix proc~get_km_re->proc~get_km Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_imag.html"},{"title":"base_init – x3d2","text":"public  subroutine base_init(self, mesh, xdirps, ydirps, zdirps, n_spec, n_sp_st) Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( mesh_t ), intent(in), target :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in), dimension(3) :: n_spec integer, intent(in), dimension(3) :: n_sp_st Calls proc~~base_init~~CallsGraph proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~get_dims m_mesh::mesh_t%get_dims proc~base_init->proc~get_dims proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~base_init->proc~get_global_dims proc~stretching_matrix m_poisson_fft::poisson_fft_t%stretching_matrix proc~base_init->proc~stretching_matrix proc~waves_set m_poisson_fft::poisson_fft_t%waves_set proc~base_init->proc~waves_set proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_imag m_poisson_fft::get_imag proc~stretching_matrix->proc~get_imag proc~get_km m_poisson_fft::poisson_fft_t%get_km proc~stretching_matrix->proc~get_km proc~get_km_im m_poisson_fft::poisson_fft_t%get_km_im proc~stretching_matrix->proc~get_km_im proc~get_km_re m_poisson_fft::poisson_fft_t%get_km_re proc~stretching_matrix->proc~get_km_re proc~get_real m_poisson_fft::get_real proc~stretching_matrix->proc~get_real proc~wave_numbers m_poisson_fft::wave_numbers proc~waves_set->proc~wave_numbers proc~get_km->proc~get_imag proc~get_km->proc~get_real proc~get_km_im->proc~get_imag proc~get_km_im->proc~get_km proc~get_km_re->proc~get_km proc~get_km_re->proc~get_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/base_init.html"},{"title":"solve_poisson – x3d2","text":"public  subroutine solve_poisson(self, f, temp) Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp Called by proc~~solve_poisson~~CalledByGraph proc~solve_poisson m_poisson_fft::poisson_fft_t%solve_poisson proc~poisson_fft m_solver::poisson_fft proc~poisson_fft->proc~solve_poisson Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/solve_poisson.html"},{"title":"poisson_000 – x3d2","text":"public  subroutine poisson_000(self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp Calls proc~~poisson_000~~CallsGraph proc~poisson_000 m_poisson_fft::poisson_000 fft_backward fft_backward proc~poisson_000->fft_backward fft_forward fft_forward proc~poisson_000->fft_forward fft_postprocess_000 fft_postprocess_000 proc~poisson_000->fft_postprocess_000 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/poisson_000.html"},{"title":"poisson_010 – x3d2","text":"public  subroutine poisson_010(self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp Calls proc~~poisson_010~~CallsGraph proc~poisson_010 m_poisson_fft::poisson_010 enforce_periodicity_y enforce_periodicity_y proc~poisson_010->enforce_periodicity_y fft_backward_010 fft_backward_010 proc~poisson_010->fft_backward_010 fft_forward_010 fft_forward_010 proc~poisson_010->fft_forward_010 fft_postprocess_010 fft_postprocess_010 proc~poisson_010->fft_postprocess_010 undo_periodicity_y undo_periodicity_y proc~poisson_010->undo_periodicity_y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/poisson_010.html"},{"title":"poisson_100 – x3d2","text":"public  subroutine poisson_100(self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp Calls proc~~poisson_100~~CallsGraph proc~poisson_100 m_poisson_fft::poisson_100 enforce_periodicity_x enforce_periodicity_x proc~poisson_100->enforce_periodicity_x fft_backward_100 fft_backward_100 proc~poisson_100->fft_backward_100 fft_forward_100 fft_forward_100 proc~poisson_100->fft_forward_100 fft_postprocess_100 fft_postprocess_100 proc~poisson_100->fft_postprocess_100 undo_periodicity_x undo_periodicity_x proc~poisson_100->undo_periodicity_x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/poisson_100.html"},{"title":"poisson_110 – x3d2","text":"public  subroutine poisson_110(self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp Calls proc~~poisson_110~~CallsGraph proc~poisson_110 m_poisson_fft::poisson_110 enforce_periodicity_x enforce_periodicity_x proc~poisson_110->enforce_periodicity_x enforce_periodicity_y enforce_periodicity_y proc~poisson_110->enforce_periodicity_y fft_backward_110 fft_backward_110 proc~poisson_110->fft_backward_110 fft_forward_110 fft_forward_110 proc~poisson_110->fft_forward_110 fft_postprocess_110 fft_postprocess_110 proc~poisson_110->fft_postprocess_110 undo_periodicity_x undo_periodicity_x proc~poisson_110->undo_periodicity_x undo_periodicity_y undo_periodicity_y proc~poisson_110->undo_periodicity_y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/poisson_110.html"},{"title":"stretching_matrix – x3d2","text":"public  subroutine stretching_matrix(self, geo, xdirps, ydirps, zdirps) Stretching necessitates a special operation in spectral space.\nThe coefficients for the operation are stored in matrix form. Ref. JCP 228 (2009), 5989–6015, Sec 5 Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps Calls proc~~stretching_matrix~~CallsGraph proc~stretching_matrix m_poisson_fft::poisson_fft_t%stretching_matrix proc~get_imag m_poisson_fft::get_imag proc~stretching_matrix->proc~get_imag proc~get_km m_poisson_fft::poisson_fft_t%get_km proc~stretching_matrix->proc~get_km proc~get_km_im m_poisson_fft::poisson_fft_t%get_km_im proc~stretching_matrix->proc~get_km_im proc~get_km_re m_poisson_fft::poisson_fft_t%get_km_re proc~stretching_matrix->proc~get_km_re proc~get_real m_poisson_fft::get_real proc~stretching_matrix->proc~get_real proc~get_km->proc~get_imag proc~get_km->proc~get_real proc~get_km_im->proc~get_imag proc~get_km_im->proc~get_km proc~get_km_re->proc~get_km proc~get_km_re->proc~get_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stretching_matrix~~CalledByGraph proc~stretching_matrix m_poisson_fft::poisson_fft_t%stretching_matrix proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~stretching_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/stretching_matrix.html"},{"title":"waves_set – x3d2","text":"public  subroutine waves_set(self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Ref. JCP 228 (2009), 5989–6015, Sec 4 Type Bound poisson_fft_t Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps Calls proc~~waves_set~~CallsGraph proc~waves_set m_poisson_fft::poisson_fft_t%waves_set proc~wave_numbers m_poisson_fft::wave_numbers proc~waves_set->proc~wave_numbers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~waves_set~~CalledByGraph proc~waves_set m_poisson_fft::poisson_fft_t%waves_set proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~waves_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/waves_set.html"},{"title":"wave_numbers – x3d2","text":"public  subroutine wave_numbers(a, b, k, e, k2, n, L, d, periodic, c_a, c_b, c_alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:) :: a real(kind=dp), intent(out), dimension(:) :: b complex(kind=dp), intent(out), dimension(:) :: k complex(kind=dp), intent(out), dimension(:) :: e complex(kind=dp), intent(out), dimension(:) :: k2 integer, intent(in) :: n real(kind=dp), intent(in) :: L real(kind=dp), intent(in) :: d logical, intent(in) :: periodic real(kind=dp), intent(in) :: c_a real(kind=dp), intent(in) :: c_b real(kind=dp), intent(in) :: c_alpha Called by proc~~wave_numbers~~CalledByGraph proc~wave_numbers m_poisson_fft::wave_numbers proc~waves_set m_poisson_fft::poisson_fft_t%waves_set proc~waves_set->proc~wave_numbers proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~waves_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/wave_numbers.html"},{"title":"der_univ_thom – x3d2","text":"public  subroutine der_univ_thom(du, u, n_tds, n_rhs, coeffs_s, coeffs_e, coeffs, thom_f, thom_s, thom_w, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n_tds integer, intent(in), value :: n_rhs real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs real(kind=dp), intent(in), device, dimension(:) :: thom_f real(kind=dp), intent(in), device, dimension(:) :: thom_s real(kind=dp), intent(in), device, dimension(:) :: thom_w real(kind=dp), intent(in), device, dimension(:) :: strch Called by proc~~der_univ_thom~~CalledByGraph proc~der_univ_thom m_cuda_kernels_thom::der_univ_thom proc~exec_thom_tds_compact m_cuda_exec_thom::exec_thom_tds_compact proc~exec_thom_tds_compact->proc~der_univ_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_thom.html"},{"title":"der_univ_thom_per – x3d2","text":"public  subroutine der_univ_thom_per(du, u, n, coeffs, alpha, thom_f, thom_s, thom_w, thom_p, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: coeffs real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:) :: thom_f real(kind=dp), intent(in), device, dimension(:) :: thom_s real(kind=dp), intent(in), device, dimension(:) :: thom_w real(kind=dp), intent(in), device, dimension(:) :: thom_p real(kind=dp), intent(in), device, dimension(:) :: strch Called by proc~~der_univ_thom_per~~CalledByGraph proc~der_univ_thom_per m_cuda_kernels_thom::der_univ_thom_per proc~exec_thom_tds_compact m_cuda_exec_thom::exec_thom_tds_compact proc~exec_thom_tds_compact->proc~der_univ_thom_per Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_thom_per.html"},{"title":"get_rdr_from_dirs – x3d2","text":"public pure function get_rdr_from_dirs(dir_from, dir_to) result(rdr_dir) Returns RDR_?2? value based on two direction inputs Arguments Type Intent Optional Attributes Name integer, intent(in) :: dir_from integer, intent(in) :: dir_to Return Value integer Called by proc~~get_rdr_from_dirs~~CalledByGraph proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~get_field_data->proc~get_rdr_from_dirs proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~set_field_data->proc~get_rdr_from_dirs none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~set_field_data proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~set_field_data proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~set_field_data proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp proc~scalar_product_omp->proc~get_field_data proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~set_field_data proc~setup_field_arrays m_io_field_utils::setup_field_arrays proc~setup_field_arrays->proc~get_field_data none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~setup_field_arrays none~handle_restart m_io_manager::io_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~setup_field_arrays proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~case_init m_base_case::base_case_t%case_init proc~case_init->none~handle_restart proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_rdr_from_dirs.html"},{"title":"get_argument – x3d2","text":"public  function get_argument(pos) result(arg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pos Return Value character(len=:), allocatable Called by proc~~get_argument~~CalledByGraph proc~get_argument m_common::get_argument proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~get_argument proc~case_init m_base_case::base_case_t%case_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~get_argument proc~case_cylinder_init->proc~case_init proc~init~5 m_solver::init proc~init~5->proc~get_argument program~xcompact xcompact program~xcompact->proc~get_argument interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 proc~case_init->proc~init~5 proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_argument.html"},{"title":"move_data_loc – x3d2","text":"public  function move_data_loc(in_data_loc, dir, move) result(out_data_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: in_data_loc integer, intent(in) :: dir integer, intent(in) :: move Return Value integer Called by proc~~move_data_loc~~CalledByGraph proc~move_data_loc m_common::move_data_loc proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~move_data_loc proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~move_data_loc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/move_data_loc.html"},{"title":"get_dirs_from_rdr – x3d2","text":"public pure subroutine get_dirs_from_rdr(dir_from, dir_to, rdr_dir) Arguments Type Intent Optional Attributes Name integer, intent(out) :: dir_from integer, intent(out) :: dir_to integer, intent(in) :: rdr_dir Called by proc~~get_dirs_from_rdr~~CalledByGraph proc~get_dirs_from_rdr m_common::get_dirs_from_rdr proc~reorder_omp m_omp_backend::omp_backend_t%reorder_omp proc~reorder_omp->proc~get_dirs_from_rdr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_dirs_from_rdr.html"},{"title":"get_default_backend – x3d2","text":"public  function get_default_backend() result(backend) Arguments None Return Value integer","tags":"","url":"proc/get_default_backend~2.html"},{"title":"allocate_io_reader – x3d2","text":"public  subroutine allocate_io_reader(reader) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(out), allocatable :: reader","tags":"","url":"proc/allocate_io_reader~2.html"},{"title":"allocate_io_writer – x3d2","text":"public  subroutine allocate_io_writer(writer) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(out), allocatable :: writer","tags":"","url":"proc/allocate_io_writer~2.html"},{"title":"mesh_init – x3d2","text":"public  function mesh_init(dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z, stretching, beta, use_2decomp) result(mesh) Uses m_decomp proc~~mesh_init~~UsesGraph proc~mesh_init m_mesh::mesh_init module~m_decomp~2 m_decomp proc~mesh_init->module~m_decomp~2 mpi mpi module~m_decomp~2->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z character(len=*), intent(in), optional, dimension(3) :: stretching real(kind=dp), intent(in), optional, dimension(3) :: beta logical, intent(in), optional :: use_2decomp Return Value class( mesh_t ), allocatable Calls proc~~mesh_init~~CallsGraph proc~mesh_init m_mesh::mesh_init mpi_comm_rank mpi_comm_rank proc~mesh_init->mpi_comm_rank mpi_comm_size mpi_comm_size proc~mesh_init->mpi_comm_size proc~decomposition_2decomp m_decomp::decomposition_2decomp proc~mesh_init->proc~decomposition_2decomp proc~decomposition_generic m_mesh::decomposition_generic proc~mesh_init->proc~decomposition_generic proc~is_avail_2decomp m_decomp::is_avail_2decomp proc~mesh_init->proc~is_avail_2decomp proc~obtain_coordinates m_mesh_content::geo_t%obtain_coordinates proc~mesh_init->proc~obtain_coordinates proc~decomposition_2decomp->mpi_comm_rank decomp_2d_init decomp_2d_init proc~decomposition_2decomp->decomp_2d_init mpi_allreduce mpi_allreduce proc~decomposition_2decomp->mpi_allreduce mpi_cart_coords mpi_cart_coords proc~decomposition_2decomp->mpi_cart_coords proc~compute_rank_pos_from_global m_mesh_content::par_t%compute_rank_pos_from_global proc~decomposition_2decomp->proc~compute_rank_pos_from_global proc~copy_vert2cell_dims m_mesh_content::grid_t%copy_vert2cell_dims proc~decomposition_2decomp->proc~copy_vert2cell_dims proc~is_root m_mesh_content::par_t%is_root proc~decomposition_2decomp->proc~is_root xsize xsize proc~decomposition_2decomp->xsize xstart xstart proc~decomposition_2decomp->xstart proc~decomposition_generic->proc~compute_rank_pos_from_global proc~decomposition_generic->proc~copy_vert2cell_dims proc~decomposition_generic->proc~is_root Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mesh_init~~CalledByGraph proc~mesh_init m_mesh::mesh_init interface~mesh_t m_mesh::mesh_t interface~mesh_t->proc~mesh_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/mesh_init.html"},{"title":"get_dims – x3d2","text":"public pure function get_dims(self, data_loc) result(dims) Getter for local domain dimensions Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) Calls proc~~get_dims~~CallsGraph proc~get_dims m_mesh::mesh_t%get_dims proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_dims~~CalledByGraph proc~get_dims m_mesh::mesh_t%get_dims none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~get_dims proc~prepare_field_buffers m_io_field_utils::prepare_field_buffers none~handle_checkpoint_step->proc~prepare_field_buffers proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer none~handle_checkpoint_step->proc~write_single_field_to_buffer none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~get_dims none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~get_dims none~handle_snapshot_step->proc~prepare_field_buffers none~handle_snapshot_step->proc~write_single_field_to_buffer proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~get_dims proc~field_max_mean_cuda m_cuda_backend::cuda_backend_t%field_max_mean_cuda proc~field_max_mean_cuda->proc~get_dims proc~field_max_mean_omp m_omp_backend::omp_backend_t%field_max_mean_omp proc~field_max_mean_omp->proc~get_dims proc~field_set_face_cuda m_cuda_backend::cuda_backend_t%field_set_face_cuda proc~field_set_face_cuda->proc~get_dims proc~field_set_face_omp m_omp_backend::omp_backend_t%field_set_face_omp proc~field_set_face_omp->proc~get_dims proc~field_volume_integral_cuda m_cuda_backend::cuda_backend_t%field_volume_integral_cuda proc~field_volume_integral_cuda->proc~get_dims proc~field_volume_integral_omp m_omp_backend::omp_backend_t%field_volume_integral_omp proc~field_volume_integral_omp->proc~get_dims proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~get_dims proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~get_dims proc~prepare_field_buffers->proc~get_dims proc~scalar_product_cuda m_cuda_backend::cuda_backend_t%scalar_product_cuda proc~scalar_product_cuda->proc~get_dims proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp proc~scalar_product_omp->proc~get_dims proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~get_dims proc~write_single_field_to_buffer->proc~get_dims program~xcompact xcompact program~xcompact->proc~get_dims proc~run m_base_case::base_case_t%run program~xcompact->proc~run none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step none~handle_restart m_io_manager::io_manager_t%handle_restart none~handle_restart->none~handle_restart~2 proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init proc~case_init m_base_case::base_case_t%case_init proc~case_init->none~handle_restart proc~run->none~handle_io_step proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_dims.html"},{"title":"get_global_dims – x3d2","text":"public pure function get_global_dims(self, data_loc) result(dims) Getter for local domain dimensions Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) Calls proc~~get_global_dims~~CallsGraph proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_global_dims~~CalledByGraph proc~get_global_dims m_mesh::mesh_t%get_global_dims none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~get_global_dims proc~prepare_field_buffers m_io_field_utils::prepare_field_buffers none~handle_checkpoint_step->proc~prepare_field_buffers proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer none~handle_checkpoint_step->proc~write_single_field_to_buffer none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~get_global_dims none~handle_snapshot_step->proc~prepare_field_buffers none~handle_snapshot_step->proc~write_single_field_to_buffer proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~get_global_dims proc~boundary_conditions_channel m_case_channel::case_channel_t%boundary_conditions_channel proc~boundary_conditions_channel->proc~get_global_dims proc~field_max_mean_cuda m_cuda_backend::cuda_backend_t%field_max_mean_cuda proc~field_max_mean_cuda->proc~get_global_dims proc~field_max_mean_omp m_omp_backend::omp_backend_t%field_max_mean_omp proc~field_max_mean_omp->proc~get_global_dims proc~init~5 m_solver::init proc~init~5->proc~get_global_dims proc~prepare_field_buffers->proc~get_global_dims proc~write_single_field_to_buffer->proc~get_global_dims interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_global_dims.html"},{"title":"get_dims_dataloc – x3d2","text":"public pure function get_dims_dataloc(data_loc, vert_dims, cell_dims) result(dims) Getter for domain dimensions Arguments Type Intent Optional Attributes Name integer, intent(in) :: data_loc integer, intent(in), dimension(3) :: vert_dims integer, intent(in), dimension(3) :: cell_dims Return Value integer, dimension(3) Called by proc~~get_dims_dataloc~~CalledByGraph proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims m_mesh::mesh_t%get_dims proc~get_dims->proc~get_dims_dataloc proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~get_global_dims->proc~get_dims_dataloc none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~get_dims none~handle_checkpoint_step->proc~get_global_dims proc~prepare_field_buffers m_io_field_utils::prepare_field_buffers none~handle_checkpoint_step->proc~prepare_field_buffers proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer none~handle_checkpoint_step->proc~write_single_field_to_buffer none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~get_dims none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~get_dims none~handle_snapshot_step->proc~get_global_dims none~handle_snapshot_step->proc~prepare_field_buffers none~handle_snapshot_step->proc~write_single_field_to_buffer proc~base_init m_poisson_fft::poisson_fft_t%base_init proc~base_init->proc~get_dims proc~base_init->proc~get_global_dims proc~boundary_conditions_channel m_case_channel::case_channel_t%boundary_conditions_channel proc~boundary_conditions_channel->proc~get_global_dims proc~field_max_mean_cuda m_cuda_backend::cuda_backend_t%field_max_mean_cuda proc~field_max_mean_cuda->proc~get_dims proc~field_max_mean_cuda->proc~get_global_dims proc~field_max_mean_omp m_omp_backend::omp_backend_t%field_max_mean_omp proc~field_max_mean_omp->proc~get_dims proc~field_max_mean_omp->proc~get_global_dims proc~field_set_face_cuda m_cuda_backend::cuda_backend_t%field_set_face_cuda proc~field_set_face_cuda->proc~get_dims proc~field_set_face_omp m_omp_backend::omp_backend_t%field_set_face_omp proc~field_set_face_omp->proc~get_dims proc~field_volume_integral_cuda m_cuda_backend::cuda_backend_t%field_volume_integral_cuda proc~field_volume_integral_cuda->proc~get_dims proc~field_volume_integral_omp m_omp_backend::omp_backend_t%field_volume_integral_omp proc~field_volume_integral_omp->proc~get_dims proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~get_dims proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~get_dims proc~init~5 m_solver::init proc~init~5->proc~get_global_dims proc~prepare_field_buffers->proc~get_dims proc~prepare_field_buffers->proc~get_global_dims proc~scalar_product_cuda m_cuda_backend::cuda_backend_t%scalar_product_cuda proc~scalar_product_cuda->proc~get_dims proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp proc~scalar_product_omp->proc~get_dims proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~get_dims proc~write_single_field_to_buffer->proc~get_dims proc~write_single_field_to_buffer->proc~get_global_dims program~xcompact xcompact program~xcompact->proc~get_dims proc~run m_base_case::base_case_t%run program~xcompact->proc~run interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step none~handle_restart m_io_manager::io_manager_t%handle_restart none~handle_restart->none~handle_restart~2 proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 proc~case_init->none~handle_restart proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init proc~run->none~handle_io_step interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_dims_dataloc.html"},{"title":"get_n_phi – x3d2","text":"public pure function get_n_phi(self, phi) result(n) Getter for the main dimension of field phi Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer Calls proc~~get_n_phi~~CallsGraph proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n m_mesh::mesh_t%get_n proc~get_n_phi->none~get_n none~get_n->proc~get_n_phi proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_n_phi~~CalledByGraph proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n m_mesh::mesh_t%get_n proc~get_n_phi->none~get_n none~get_n->proc~get_n_phi proc~allocate_tdsops m_solver::allocate_tdsops proc~allocate_tdsops->none~get_n proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->none~get_n proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->none~get_n proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->none~get_n proc~init~5 m_solver::init proc~init~5->proc~allocate_tdsops proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_n_phi.html"},{"title":"get_n_dir – x3d2","text":"public pure function get_n_dir(self, dir, data_loc) result(n) Getter for the main dimension a field oriented along dir with data on data_loc Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer Called by proc~~get_n_dir~~CalledByGraph proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n m_mesh::mesh_t%get_n none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi proc~allocate_tdsops m_solver::allocate_tdsops proc~allocate_tdsops->none~get_n proc~get_n_phi->none~get_n proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->none~get_n proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->none~get_n proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->none~get_n proc~init~5 m_solver::init proc~init~5->proc~allocate_tdsops proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_n_dir.html"},{"title":"get_coordinates – x3d2","text":"public pure function get_coordinates(self, i, j, k, data_loc_op) result(coords) Get the coordinates of a vertex with i, j, k local cartesian indices\nAvoid calling this in hot loops Type Bound mesh_t Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in), optional :: data_loc_op Return Value real(kind=dp), dimension(3) Called by proc~~get_coordinates~~CalledByGraph proc~get_coordinates m_mesh::mesh_t%get_coordinates none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~get_coordinates proc~generate_coordinates m_io_field_utils::generate_coordinates proc~generate_coordinates->proc~get_coordinates proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~get_coordinates proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~get_coordinates none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_snapshot_step proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_coordinates.html"},{"title":"decomposition_generic – x3d2","text":"public  subroutine decomposition_generic(grid, par) Uses m_mesh_content proc~~decomposition_generic~~UsesGraph proc~decomposition_generic m_mesh::decomposition_generic module~m_mesh_content m_mesh_content proc~decomposition_generic->module~m_mesh_content module~m_common m_common module~m_mesh_content->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: grid class( par_t ), intent(inout) :: par Calls proc~~decomposition_generic~~CallsGraph proc~decomposition_generic m_mesh::decomposition_generic proc~compute_rank_pos_from_global m_mesh_content::par_t%compute_rank_pos_from_global proc~decomposition_generic->proc~compute_rank_pos_from_global proc~copy_vert2cell_dims m_mesh_content::grid_t%copy_vert2cell_dims proc~decomposition_generic->proc~copy_vert2cell_dims proc~is_root m_mesh_content::par_t%is_root proc~decomposition_generic->proc~is_root Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~decomposition_generic~~CalledByGraph proc~decomposition_generic m_mesh::decomposition_generic proc~mesh_init m_mesh::mesh_init proc~mesh_init->proc~decomposition_generic interface~mesh_t m_mesh::mesh_t interface~mesh_t->proc~mesh_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/decomposition_generic.html"},{"title":"mesh_t – x3d2","text":"public interface mesh_t Calls interface~~mesh_t~~CallsGraph interface~mesh_t m_mesh::mesh_t proc~mesh_init m_mesh::mesh_init interface~mesh_t->proc~mesh_init mpi_comm_rank mpi_comm_rank proc~mesh_init->mpi_comm_rank mpi_comm_size mpi_comm_size proc~mesh_init->mpi_comm_size proc~decomposition_2decomp m_decomp::decomposition_2decomp proc~mesh_init->proc~decomposition_2decomp proc~decomposition_generic m_mesh::decomposition_generic proc~mesh_init->proc~decomposition_generic proc~is_avail_2decomp m_decomp::is_avail_2decomp proc~mesh_init->proc~is_avail_2decomp proc~obtain_coordinates m_mesh_content::geo_t%obtain_coordinates proc~mesh_init->proc~obtain_coordinates proc~decomposition_2decomp->mpi_comm_rank decomp_2d_init decomp_2d_init proc~decomposition_2decomp->decomp_2d_init mpi_allreduce mpi_allreduce proc~decomposition_2decomp->mpi_allreduce mpi_cart_coords mpi_cart_coords proc~decomposition_2decomp->mpi_cart_coords proc~compute_rank_pos_from_global m_mesh_content::par_t%compute_rank_pos_from_global proc~decomposition_2decomp->proc~compute_rank_pos_from_global proc~copy_vert2cell_dims m_mesh_content::grid_t%copy_vert2cell_dims proc~decomposition_2decomp->proc~copy_vert2cell_dims proc~is_root m_mesh_content::par_t%is_root proc~decomposition_2decomp->proc~is_root xsize xsize proc~decomposition_2decomp->xsize xstart xstart proc~decomposition_2decomp->xstart proc~decomposition_generic->proc~compute_rank_pos_from_global proc~decomposition_generic->proc~copy_vert2cell_dims proc~decomposition_generic->proc~is_root Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z, stretching, beta, use_2decomp) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z character(len=*), intent(in), optional, dimension(3) :: stretching real(kind=dp), intent(in), optional, dimension(3) :: beta logical, intent(in), optional :: use_2decomp Return Value class( mesh_t ), allocatable","tags":"","url":"interface/mesh_t.html"},{"title":"der_univ_dist – x3d2","text":"public  subroutine der_univ_dist(du, send_u_s, send_u_e, u, u_s, u_e, n_tds, n_rhs, coeffs_s, coeffs_e, coeffs, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(out), dimension(:, :) :: send_u_s real(kind=dp), intent(out), dimension(:, :) :: send_u_e real(kind=dp), intent(in), dimension(:, :) :: u real(kind=dp), intent(in), dimension(:, :) :: u_s real(kind=dp), intent(in), dimension(:, :) :: u_e integer, intent(in) :: n_tds integer, intent(in) :: n_rhs real(kind=dp), intent(in), dimension(:, :) :: coeffs_s real(kind=dp), intent(in), dimension(:, :) :: coeffs_e real(kind=dp), intent(in), dimension(:) :: coeffs real(kind=dp), intent(in), dimension(:) :: ffr real(kind=dp), intent(in), dimension(:) :: fbc real(kind=dp), intent(in), dimension(:) :: faf Called by proc~~der_univ_dist~~CalledByGraph proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_tds_compact~2 m_omp_exec_dist::exec_dist_tds_compact proc~exec_dist_tds_compact~2->proc~der_univ_dist proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~exec_dist_transeq_compact->proc~der_univ_dist proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~tds_solve_dist->proc~exec_dist_tds_compact~2 proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~exec_dist_transeq_compact proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~exec_dist_transeq_compact proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~tds_solve_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_dist.html"},{"title":"der_univ_subs – x3d2","text":"public  subroutine der_univ_subs(du, recv_u_s, recv_u_e, n, dist_sa, dist_sc, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: recv_u_s real(kind=dp), intent(in), dimension(:, :) :: recv_u_e integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: dist_sa real(kind=dp), intent(in), dimension(:) :: dist_sc real(kind=dp), intent(in), dimension(:) :: strch Called by proc~~der_univ_subs~~CalledByGraph proc~der_univ_subs m_omp_kernels_dist::der_univ_subs proc~exec_dist_tds_compact~2 m_omp_exec_dist::exec_dist_tds_compact proc~exec_dist_tds_compact~2->proc~der_univ_subs proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~tds_solve_dist->proc~exec_dist_tds_compact~2 proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~tds_solve_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_subs.html"},{"title":"der_univ_fused_subs – x3d2","text":"public  subroutine der_univ_fused_subs(rhs_du, dud, d2u, v, du_recv_s, du_recv_e, dud_recv_s, dud_recv_e, d2u_recv_s, d2u_recv_e, nu, n, du_dist_sa, du_dist_sc, du_strch, dud_dist_sa, dud_dist_sc, dud_strch, d2u_dist_sa, d2u_dist_sc, d2u_strch, d2u_strch_cor) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), dimension(:, :) :: rhs_du real(kind=dp), intent(in), dimension(:, :) :: dud real(kind=dp), intent(in), dimension(:, :) :: d2u real(kind=dp), intent(in), dimension(:, :) :: v real(kind=dp), intent(in), dimension(:, :) :: du_recv_s real(kind=dp), intent(in), dimension(:, :) :: du_recv_e real(kind=dp), intent(in), dimension(:, :) :: dud_recv_s real(kind=dp), intent(in), dimension(:, :) :: dud_recv_e real(kind=dp), intent(in), dimension(:, :) :: d2u_recv_s real(kind=dp), intent(in), dimension(:, :) :: d2u_recv_e real(kind=dp), intent(in) :: nu integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: du_dist_sa real(kind=dp), intent(in), dimension(:) :: du_dist_sc real(kind=dp), intent(in), dimension(:) :: du_strch real(kind=dp), intent(in), dimension(:) :: dud_dist_sa real(kind=dp), intent(in), dimension(:) :: dud_dist_sc real(kind=dp), intent(in), dimension(:) :: dud_strch real(kind=dp), intent(in), dimension(:) :: d2u_dist_sa real(kind=dp), intent(in), dimension(:) :: d2u_dist_sc real(kind=dp), intent(in), dimension(:) :: d2u_strch real(kind=dp), intent(in), dimension(:) :: d2u_strch_cor Called by proc~~der_univ_fused_subs~~CalledByGraph proc~der_univ_fused_subs m_omp_kernels_dist::der_univ_fused_subs proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~exec_dist_transeq_compact->proc~der_univ_fused_subs proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~exec_dist_transeq_compact proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~exec_dist_transeq_compact proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_fused_subs.html"},{"title":"case_channel_init – x3d2","text":"public  function case_channel_init(backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_channel_t ) Calls proc~~case_channel_init~~CallsGraph proc~case_channel_init m_case_channel::case_channel_init proc~case_init m_base_case::base_case_t%case_init proc~case_channel_init->proc~case_init proc~get_argument m_common::get_argument proc~case_channel_init->proc~get_argument initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 proc~init~5->proc~get_argument init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~case_channel_init~~CalledByGraph proc~case_channel_init m_case_channel::case_channel_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/case_channel_init.html"},{"title":"boundary_conditions_channel – x3d2","text":"public  subroutine boundary_conditions_channel(self) Type Bound case_channel_t Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self Calls proc~~boundary_conditions_channel~~CallsGraph proc~boundary_conditions_channel m_case_channel::case_channel_t%boundary_conditions_channel field_shift field_shift proc~boundary_conditions_channel->field_shift field_volume_integral field_volume_integral proc~boundary_conditions_channel->field_volume_integral mpi_allreduce mpi_allreduce proc~boundary_conditions_channel->mpi_allreduce proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~boundary_conditions_channel->proc~get_global_dims proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/boundary_conditions_channel.html"},{"title":"initial_conditions_channel – x3d2","text":"public  subroutine initial_conditions_channel(self) Type Bound case_channel_t Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self Calls proc~~initial_conditions_channel~~CallsGraph proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~get_block m_allocator::allocator_t%get_block proc~initial_conditions_channel->proc~get_block proc~get_coordinates m_mesh::mesh_t%get_coordinates proc~initial_conditions_channel->proc~get_coordinates proc~get_dims m_mesh::mesh_t%get_dims proc~initial_conditions_channel->proc~get_dims proc~release_block m_allocator::allocator_t%release_block proc~initial_conditions_channel->proc~release_block proc~set_data_loc m_field::field_t%set_data_loc proc~initial_conditions_channel->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~initial_conditions_channel->proc~set_field_data proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block proc~set_field_data->proc~release_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs reorder reorder proc~set_field_data->reorder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/initial_conditions_channel.html"},{"title":"forcings_channel – x3d2","text":"public  subroutine forcings_channel(self, du, dv, dw, iter) Type Bound case_channel_t Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter Calls proc~~forcings_channel~~CallsGraph proc~forcings_channel m_case_channel::case_channel_t%forcings_channel vecadd vecadd proc~forcings_channel->vecadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/forcings_channel.html"},{"title":"pre_correction_channel – x3d2","text":"public  subroutine pre_correction_channel(self, u, v, w) Type Bound case_channel_t Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w Calls proc~~pre_correction_channel~~CallsGraph proc~pre_correction_channel m_case_channel::case_channel_t%pre_correction_channel field_set_face field_set_face proc~pre_correction_channel->field_set_face Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/pre_correction_channel.html"},{"title":"postprocess_channel – x3d2","text":"public  subroutine postprocess_channel(self, iter, t) Type Bound case_channel_t Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t Calls proc~~postprocess_channel~~CallsGraph proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~is_root m_mesh_content::par_t%is_root proc~postprocess_channel->proc~is_root proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~postprocess_channel->proc~print_div_max_mean proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~postprocess_channel->proc~print_enstrophy proc~print_div_max_mean->proc~is_root field_max_mean field_max_mean proc~print_div_max_mean->field_max_mean proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~print_div_max_mean->proc~divergence_v2p proc~get_block m_allocator::allocator_t%get_block proc~print_div_max_mean->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~print_div_max_mean->proc~release_block proc~print_enstrophy->proc~is_root proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~print_enstrophy->proc~get_block proc~print_enstrophy->proc~release_block scalar_product scalar_product proc~print_enstrophy->scalar_product proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl~2->proc~curl proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~curl->proc~get_block proc~curl->proc~release_block reorder reorder proc~curl->reorder tds_solve tds_solve proc~curl->tds_solve vecadd vecadd proc~curl->vecadd proc~divergence_v2c->proc~get_block proc~divergence_v2c->proc~release_block proc~divergence_v2c->reorder proc~divergence_v2c->tds_solve proc~divergence_v2c->vecadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/postprocess_channel.html"},{"title":"case_channel_t – x3d2","text":"public interface case_channel_t Calls interface~~case_channel_t~~CallsGraph interface~case_channel_t m_case_channel::case_channel_t proc~case_channel_init m_case_channel::case_channel_init interface~case_channel_t->proc~case_channel_init proc~case_init m_base_case::base_case_t%case_init proc~case_channel_init->proc~case_init proc~get_argument m_common::get_argument proc~case_channel_init->proc~get_argument initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 proc~init~5->proc~get_argument init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function case_channel_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_channel_t )","tags":"","url":"interface/case_channel_t.html"},{"title":"cuda_field_init – x3d2","text":"public  function cuda_field_init(ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) Called by proc~~cuda_field_init~~CalledByGraph proc~cuda_field_init m_cuda_allocator::cuda_field_init interface~cuda_field_t m_cuda_allocator::cuda_field_t interface~cuda_field_t->proc~cuda_field_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cuda_field_init.html"},{"title":"get_shape_cuda – x3d2","text":"public  function get_shape_cuda(self) result(dims) Type Bound cuda_field_t Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self Return Value integer, (3)","tags":"","url":"proc/get_shape_cuda.html"},{"title":"cuda_allocator_init – x3d2","text":"public  function cuda_allocator_init(dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( cuda_allocator_t ) Called by proc~~cuda_allocator_init~~CalledByGraph proc~cuda_allocator_init m_cuda_allocator::cuda_allocator_init interface~cuda_allocator_t m_cuda_allocator::cuda_allocator_t interface~cuda_allocator_t->proc~cuda_allocator_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cuda_allocator_init.html"},{"title":"create_cuda_block – x3d2","text":"public  function create_cuda_block(self, next) result(ptr) Type Bound cuda_allocator_t Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer","tags":"","url":"proc/create_cuda_block.html"},{"title":"fill_cuda – x3d2","text":"public  subroutine fill_cuda(self, c) Type Bound cuda_field_t Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self real(kind=dp), intent(in) :: c","tags":"","url":"proc/fill_cuda.html"},{"title":"set_shape_cuda – x3d2","text":"public  subroutine set_shape_cuda(self, dims) Type Bound cuda_field_t Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self integer, intent(in) :: dims (3)","tags":"","url":"proc/set_shape_cuda.html"},{"title":"cuda_allocator_t – x3d2","text":"public interface cuda_allocator_t Calls interface~~cuda_allocator_t~~CallsGraph interface~cuda_allocator_t m_cuda_allocator::cuda_allocator_t proc~cuda_allocator_init m_cuda_allocator::cuda_allocator_init interface~cuda_allocator_t->proc~cuda_allocator_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function cuda_allocator_init (dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( cuda_allocator_t )","tags":"","url":"interface/cuda_allocator_t.html"},{"title":"cuda_field_t – x3d2","text":"public interface cuda_field_t Calls interface~~cuda_field_t~~CallsGraph interface~cuda_field_t m_cuda_allocator::cuda_field_t proc~cuda_field_init m_cuda_allocator::cuda_field_init interface~cuda_field_t->proc~cuda_field_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function cuda_field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t )","tags":"","url":"interface/cuda_field_t.html"},{"title":"cuda_tdsops_init – x3d2","text":"public  function cuda_tdsops_init(n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function Calls proc~~cuda_tdsops_init~~CallsGraph proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init proc~tdsops_init m_tdsops::tdsops_init proc~cuda_tdsops_init->proc~tdsops_init proc~deriv_1st m_tdsops::tdsops_t%deriv_1st proc~tdsops_init->proc~deriv_1st proc~deriv_2nd m_tdsops::tdsops_t%deriv_2nd proc~tdsops_init->proc~deriv_2nd proc~interpl_mid m_tdsops::tdsops_t%interpl_mid proc~tdsops_init->proc~interpl_mid proc~stagder_1st m_tdsops::tdsops_t%stagder_1st proc~tdsops_init->proc~stagder_1st proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~deriv_1st->proc~preprocess_dist proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~deriv_1st->proc~preprocess_thom proc~deriv_2nd->proc~preprocess_dist proc~deriv_2nd->proc~preprocess_thom proc~interpl_mid->proc~preprocess_dist proc~interpl_mid->proc~preprocess_thom proc~stagder_1st->proc~preprocess_dist proc~stagder_1st->proc~preprocess_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cuda_tdsops_init~~CalledByGraph proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t interface~cuda_tdsops_t->proc~cuda_tdsops_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cuda_tdsops_init.html"},{"title":"cuda_tdsops_t – x3d2","text":"public interface cuda_tdsops_t Calls interface~~cuda_tdsops_t~~CallsGraph interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init interface~cuda_tdsops_t->proc~cuda_tdsops_init proc~tdsops_init m_tdsops::tdsops_init proc~cuda_tdsops_init->proc~tdsops_init proc~deriv_1st m_tdsops::tdsops_t%deriv_1st proc~tdsops_init->proc~deriv_1st proc~deriv_2nd m_tdsops::tdsops_t%deriv_2nd proc~tdsops_init->proc~deriv_2nd proc~interpl_mid m_tdsops::tdsops_t%interpl_mid proc~tdsops_init->proc~interpl_mid proc~stagder_1st m_tdsops::tdsops_t%stagder_1st proc~tdsops_init->proc~stagder_1st proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~deriv_1st->proc~preprocess_dist proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~deriv_1st->proc~preprocess_thom proc~deriv_2nd->proc~preprocess_dist proc~deriv_2nd->proc~preprocess_thom proc~interpl_mid->proc~preprocess_dist proc~interpl_mid->proc~preprocess_thom proc~stagder_1st->proc~preprocess_dist proc~stagder_1st->proc~preprocess_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function cuda_tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function","tags":"","url":"interface/cuda_tdsops_t.html"},{"title":"init – x3d2","text":"public  function init(backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t ) Calls proc~~init~5~~CallsGraph proc~init~5 m_solver::init init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_argument m_common::get_argument proc~init~5->proc~get_argument proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init~5~~CalledByGraph proc~init~5 m_solver::init interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/init~5.html"},{"title":"allocate_tdsops – x3d2","text":"public  subroutine allocate_tdsops(dirps, backend, mesh, der1st_scheme, der2nd_scheme, interpl_scheme, stagder_scheme) Arguments Type Intent Optional Attributes Name type( dirps_t ), intent(inout) :: dirps class( base_backend_t ), intent(in) :: backend type( mesh_t ), intent(in) :: mesh character(len=*), intent(in) :: der1st_scheme character(len=*), intent(in) :: der2nd_scheme character(len=*), intent(in) :: interpl_scheme character(len=*), intent(in) :: stagder_scheme Calls proc~~allocate_tdsops~~CallsGraph proc~allocate_tdsops m_solver::allocate_tdsops alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~allocate_tdsops~~CalledByGraph proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5 m_solver::init proc~init~5->proc~allocate_tdsops interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/allocate_tdsops.html"},{"title":"transeq_default – x3d2","text":"public  subroutine transeq_default(self, rhs, variables) Skew-symmetric form of convection-diffusion terms in the\nincompressible Navier-Stokes momemtum equations, excluding\npressure terms.\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(inout) :: variables (:) Calls proc~~transeq_default~~CallsGraph proc~transeq_default m_solver::transeq_default proc~get_block m_allocator::allocator_t%get_block proc~transeq_default->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~transeq_default->proc~release_block proc~transeq_species m_solver::solver_t%transeq_species proc~transeq_default->proc~transeq_species reorder reorder proc~transeq_default->reorder sum_yintox sum_yintox proc~transeq_default->sum_yintox sum_zintox sum_zintox proc~transeq_default->sum_zintox transeq_x transeq_x proc~transeq_default->transeq_x transeq_y transeq_y proc~transeq_default->transeq_y transeq_z transeq_z proc~transeq_default->transeq_z proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~transeq_species->proc~get_block proc~transeq_species->proc~release_block proc~transeq_species->reorder proc~transeq_species->sum_yintox proc~transeq_species->sum_zintox transeq_species transeq_species proc~transeq_species->transeq_species Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_default.html"},{"title":"transeq_lowmem – x3d2","text":"public  subroutine transeq_lowmem(self, rhs, variables) low memory version of the transport equation, roughly %2 slower overall Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(inout) :: variables (:) Calls proc~~transeq_lowmem~~CallsGraph proc~transeq_lowmem m_solver::transeq_lowmem proc~get_block m_allocator::allocator_t%get_block proc~transeq_lowmem->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~transeq_lowmem->proc~release_block proc~transeq_species m_solver::solver_t%transeq_species proc~transeq_lowmem->proc~transeq_species reorder reorder proc~transeq_lowmem->reorder sum_yintox sum_yintox proc~transeq_lowmem->sum_yintox sum_zintox sum_zintox proc~transeq_lowmem->sum_zintox transeq_x transeq_x proc~transeq_lowmem->transeq_x transeq_y transeq_y proc~transeq_lowmem->transeq_y transeq_z transeq_z proc~transeq_lowmem->transeq_z proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~transeq_species->proc~get_block proc~transeq_species->proc~release_block proc~transeq_species->reorder proc~transeq_species->sum_yintox proc~transeq_species->sum_zintox transeq_species transeq_species proc~transeq_species->transeq_species Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_lowmem.html"},{"title":"transeq_species – x3d2","text":"public  subroutine transeq_species(self, rhs, variables) Skew-symmetric form of convection-diffusion terms in the\nspecies equation.\nInputs from velocity grid and outputs to velocity grid. Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(in) :: variables (:) Calls proc~~transeq_species~~CallsGraph proc~transeq_species m_solver::solver_t%transeq_species proc~get_block m_allocator::allocator_t%get_block proc~transeq_species->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~transeq_species->proc~release_block reorder reorder proc~transeq_species->reorder sum_yintox sum_yintox proc~transeq_species->sum_yintox sum_zintox sum_zintox proc~transeq_species->sum_zintox transeq_species transeq_species proc~transeq_species->transeq_species proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transeq_species~~CalledByGraph proc~transeq_species m_solver::solver_t%transeq_species proc~transeq_default m_solver::transeq_default proc~transeq_default->proc~transeq_species proc~transeq_lowmem m_solver::transeq_lowmem proc~transeq_lowmem->proc~transeq_species Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_species.html"},{"title":"divergence_v2p – x3d2","text":"public  subroutine divergence_v2p(self, div_u, u, v, w) Wrapper for divergence_v2p Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w Calls proc~~divergence_v2p~~CallsGraph proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~get_block m_allocator::allocator_t%get_block proc~divergence_v2c->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~divergence_v2c->proc~release_block reorder reorder proc~divergence_v2c->reorder tds_solve tds_solve proc~divergence_v2c->tds_solve vecadd vecadd proc~divergence_v2c->vecadd proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~divergence_v2p~~CalledByGraph proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~pressure_correction m_solver::solver_t%pressure_correction proc~pressure_correction->proc~divergence_v2p proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~print_div_max_mean->proc~divergence_v2p proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_div_max_mean proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_div_max_mean proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_div_max_mean proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_div_max_mean proc~run m_base_case::base_case_t%run proc~run->proc~pressure_correction program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/divergence_v2p.html"},{"title":"gradient_p2v – x3d2","text":"public  subroutine gradient_p2v(self, dpdx, dpdy, dpdz, pressure) Wrapper for gradient_p2v Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure Calls proc~~gradient_p2v~~CallsGraph proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_p2v->proc~gradient_c2v proc~get_block m_allocator::allocator_t%get_block proc~gradient_c2v->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~gradient_c2v->proc~release_block reorder reorder proc~gradient_c2v->reorder tds_solve tds_solve proc~gradient_c2v->tds_solve proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gradient_p2v~~CalledByGraph proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~pressure_correction m_solver::solver_t%pressure_correction proc~pressure_correction->proc~gradient_p2v proc~run m_base_case::base_case_t%run proc~run->proc~pressure_correction program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gradient_p2v.html"},{"title":"curl – x3d2","text":"public  subroutine curl(self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Wrapper for curl Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w Calls proc~~curl~2~~CallsGraph proc~curl~2 m_solver::solver_t%curl proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl~2->proc~curl proc~get_block m_allocator::allocator_t%get_block proc~curl->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~curl->proc~release_block reorder reorder proc~curl->reorder tds_solve tds_solve proc~curl->tds_solve vecadd vecadd proc~curl->vecadd proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~curl~2~~CalledByGraph proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~print_enstrophy->proc~curl~2 proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_enstrophy proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_enstrophy proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_enstrophy proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_enstrophy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/curl~2.html"},{"title":"poisson_fft – x3d2","text":"public  subroutine poisson_fft(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u Calls proc~~poisson_fft~~CallsGraph proc~poisson_fft m_solver::poisson_fft proc~get_block m_allocator::allocator_t%get_block proc~poisson_fft->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~poisson_fft->proc~release_block proc~solve_poisson m_poisson_fft::poisson_fft_t%solve_poisson proc~poisson_fft->proc~solve_poisson reorder reorder proc~poisson_fft->reorder proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/poisson_fft.html"},{"title":"poisson_cg – x3d2","text":"public  subroutine poisson_cg(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u Calls proc~~poisson_cg~~CallsGraph proc~poisson_cg m_solver::poisson_cg proc~fill m_field::field_t%fill proc~poisson_cg->proc~fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/poisson_cg.html"},{"title":"pressure_correction – x3d2","text":"public  subroutine pressure_correction(self, u, v, w) Type Bound solver_t Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w Calls proc~~pressure_correction~~CallsGraph proc~pressure_correction m_solver::solver_t%pressure_correction proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~pressure_correction->proc~divergence_v2p proc~get_block m_allocator::allocator_t%get_block proc~pressure_correction->proc~get_block proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~pressure_correction->proc~gradient_p2v proc~release_block m_allocator::allocator_t%release_block proc~pressure_correction->proc~release_block vecadd vecadd proc~pressure_correction->vecadd proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_p2v->proc~gradient_c2v proc~divergence_v2c->proc~get_block proc~divergence_v2c->proc~release_block proc~divergence_v2c->vecadd reorder reorder proc~divergence_v2c->reorder tds_solve tds_solve proc~divergence_v2c->tds_solve proc~gradient_c2v->proc~get_block proc~gradient_c2v->proc~release_block proc~gradient_c2v->reorder proc~gradient_c2v->tds_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pressure_correction~~CalledByGraph proc~pressure_correction m_solver::solver_t%pressure_correction proc~run m_base_case::base_case_t%run proc~run->proc~pressure_correction program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/pressure_correction.html"},{"title":"solver_t – x3d2","text":"public interface solver_t Calls interface~~solver_t~~CallsGraph interface~solver_t m_solver::solver_t proc~init~5 m_solver::init interface~solver_t->proc~init~5 init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_argument m_common::get_argument proc~init~5->proc~get_argument proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function init (backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t )","tags":"","url":"interface/solver_t.html"},{"title":"is_root – x3d2","text":"public pure function is_root(self) result(is_root_rank) Returns wether or not the current rank is the root rank Type Bound par_t Arguments Type Intent Optional Attributes Name class( par_t ), intent(in) :: self Return Value logical Called by proc~~is_root~~CalledByGraph proc~is_root m_mesh_content::par_t%is_root none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~is_root proc~case_finalise m_base_case::base_case_t%case_finalise proc~case_finalise->proc~is_root proc~decomposition_2decomp m_decomp::decomposition_2decomp proc~decomposition_2decomp->proc~is_root proc~decomposition_generic m_mesh::decomposition_generic proc~decomposition_generic->proc~is_root proc~init~5 m_solver::init proc~init~5->proc~is_root proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~is_root proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~postprocess_channel->proc~print_div_max_mean proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~postprocess_channel->proc~print_enstrophy proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~is_root proc~postprocess_cylinder->proc~print_div_max_mean proc~postprocess_cylinder->proc~print_enstrophy proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~is_root proc~postprocess_generic->proc~print_div_max_mean proc~postprocess_generic->proc~print_enstrophy proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~is_root proc~postprocess_tgv->proc~print_div_max_mean proc~postprocess_tgv->proc~print_enstrophy proc~print_div_max_mean->proc~is_root proc~print_enstrophy->proc~is_root proc~run m_base_case::base_case_t%run proc~run->proc~is_root proc~run->proc~case_finalise none~handle_io_step m_io_manager::io_manager_t%handle_io_step proc~run->none~handle_io_step proc~setup_field_arrays m_io_field_utils::setup_field_arrays proc~setup_field_arrays->proc~is_root interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~setup_field_arrays none~handle_restart m_io_manager::io_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~setup_field_arrays proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 proc~case_init->none~handle_restart proc~mesh_init m_mesh::mesh_init proc~mesh_init->proc~decomposition_2decomp proc~mesh_init->proc~decomposition_generic program~xcompact xcompact program~xcompact->proc~run interface~mesh_t m_mesh::mesh_t interface~mesh_t->proc~mesh_init none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/is_root.html"},{"title":"compute_rank_pos_from_global – x3d2","text":"public pure subroutine compute_rank_pos_from_global(self, global_ranks) From the global rank maps, fills in the rank position as well\nas the previous and next rank in the par structure Type Bound par_t Arguments Type Intent Optional Attributes Name class( par_t ), intent(inout) :: self integer, intent(in), dimension(:, :, :) :: global_ranks Called by proc~~compute_rank_pos_from_global~~CalledByGraph proc~compute_rank_pos_from_global m_mesh_content::par_t%compute_rank_pos_from_global proc~decomposition_2decomp m_decomp::decomposition_2decomp proc~decomposition_2decomp->proc~compute_rank_pos_from_global proc~decomposition_generic m_mesh::decomposition_generic proc~decomposition_generic->proc~compute_rank_pos_from_global proc~mesh_init m_mesh::mesh_init proc~mesh_init->proc~decomposition_2decomp proc~mesh_init->proc~decomposition_generic interface~mesh_t m_mesh::mesh_t interface~mesh_t->proc~mesh_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_rank_pos_from_global.html"},{"title":"copy_vert2cell_dims – x3d2","text":"public pure subroutine copy_vert2cell_dims(self, par) Copies vert_dims information to cell_dims taking\nperiodicity into account Type Bound grid_t Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: self type( par_t ), intent(in) :: par Called by proc~~copy_vert2cell_dims~~CalledByGraph proc~copy_vert2cell_dims m_mesh_content::grid_t%copy_vert2cell_dims proc~decomposition_2decomp m_decomp::decomposition_2decomp proc~decomposition_2decomp->proc~copy_vert2cell_dims proc~decomposition_generic m_mesh::decomposition_generic proc~decomposition_generic->proc~copy_vert2cell_dims proc~mesh_init m_mesh::mesh_init proc~mesh_init->proc~decomposition_2decomp proc~mesh_init->proc~decomposition_generic interface~mesh_t m_mesh::mesh_t interface~mesh_t->proc~mesh_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/copy_vert2cell_dims.html"},{"title":"copy_cell2vert_dims – x3d2","text":"public pure subroutine copy_cell2vert_dims(self, par) Copies cell_dims information to vert_dims taking\nperiodicity into account Type Bound grid_t Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: self type( par_t ), intent(in) :: par","tags":"","url":"proc/copy_cell2vert_dims.html"},{"title":"obtain_coordinates – x3d2","text":"public  subroutine obtain_coordinates(self, vert_dims, cell_dims, n_offset) Obtains global coordinates for all the vertices and midpoints Type Bound geo_t Arguments Type Intent Optional Attributes Name class( geo_t ) :: self integer, intent(in) :: vert_dims (3) integer, intent(in) :: cell_dims (3) integer, intent(in) :: n_offset (3) Called by proc~~obtain_coordinates~~CalledByGraph proc~obtain_coordinates m_mesh_content::geo_t%obtain_coordinates proc~mesh_init m_mesh::mesh_init proc~mesh_init->proc~obtain_coordinates interface~mesh_t m_mesh::mesh_t interface~mesh_t->proc~mesh_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/obtain_coordinates.html"},{"title":"exec_dist_tds_compact – x3d2","text":"public  subroutine exec_dist_tds_compact(du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e type( cuda_tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads Calls proc~~exec_dist_tds_compact~~CallsGraph proc~exec_dist_tds_compact m_cuda_exec_dist::exec_dist_tds_compact proc~der_univ_dist~2 m_cuda_kernels_dist::der_univ_dist proc~exec_dist_tds_compact->proc~der_univ_dist~2 proc~der_univ_subs~2 m_cuda_kernels_dist::der_univ_subs proc~exec_dist_tds_compact->proc~der_univ_subs~2 proc~sendrecv_fields~2 m_cuda_sendrecv::sendrecv_fields proc~exec_dist_tds_compact->proc~sendrecv_fields~2 mpi_irecv mpi_irecv proc~sendrecv_fields~2->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields~2->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields~2->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~exec_dist_tds_compact~~CalledByGraph proc~exec_dist_tds_compact m_cuda_exec_dist::exec_dist_tds_compact proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_dist~2->proc~exec_dist_tds_compact proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~tds_solve_dist~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/exec_dist_tds_compact.html"},{"title":"exec_dist_transeq_3fused – x3d2","text":"public  subroutine exec_dist_transeq_3fused(r_du, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, tdsops_du, tdsops_dud, tdsops_d2u, nu, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_du The result array, it is also used as temporary storage real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_e type( cuda_tdsops_t ), intent(in) :: tdsops_du type( cuda_tdsops_t ), intent(in) :: tdsops_dud type( cuda_tdsops_t ), intent(in) :: tdsops_d2u real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads Calls proc~~exec_dist_transeq_3fused~~CallsGraph proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~sendrecv_3fields m_cuda_sendrecv::sendrecv_3fields proc~exec_dist_transeq_3fused->proc~sendrecv_3fields proc~transeq_3fused_dist m_cuda_kernels_dist::transeq_3fused_dist proc~exec_dist_transeq_3fused->proc~transeq_3fused_dist proc~transeq_3fused_subs m_cuda_kernels_dist::transeq_3fused_subs proc~exec_dist_transeq_3fused->proc~transeq_3fused_subs mpi_irecv mpi_irecv proc~sendrecv_3fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_3fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_3fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~exec_dist_transeq_3fused~~CalledByGraph proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~exec_dist_transeq_3fused proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~exec_dist_transeq_3fused proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/exec_dist_transeq_3fused.html"},{"title":"fft_forward_100_cuda – x3d2","text":"public  subroutine fft_forward_100_cuda(self, f) Forward FFT for non-periodic-X case\nWe transpose X<->Y so that the non-periodic direction becomes the\n\"Y\" direction in the transposed space, then use the same FFT approach as 010 Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f Calls proc~~fft_forward_100_cuda~~CallsGraph proc~fft_forward_100_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_forward_100_cuda cufftexecd2z cufftexecd2z proc~fft_forward_100_cuda->cufftexecd2z cufftxtexecdescriptor cufftxtexecdescriptor proc~fft_forward_100_cuda->cufftxtexecdescriptor dim3 dim3 proc~fft_forward_100_cuda->dim3 interface~cufftexecr2c_c m_cuda_poisson_fft::cufftExecR2C_C proc~fft_forward_100_cuda->interface~cufftexecr2c_c proc~memcpy3d_with_transpose m_cuda_spectral::memcpy3D_with_transpose proc~fft_forward_100_cuda->proc~memcpy3d_with_transpose Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_forward_100_cuda.html"},{"title":"fft_backward_100_cuda – x3d2","text":"public  subroutine fft_backward_100_cuda(self, f) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f Calls proc~~fft_backward_100_cuda~~CallsGraph proc~fft_backward_100_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_backward_100_cuda cufftexecz2d cufftexecz2d proc~fft_backward_100_cuda->cufftexecz2d cufftxtexecdescriptor cufftxtexecdescriptor proc~fft_backward_100_cuda->cufftxtexecdescriptor dim3 dim3 proc~fft_backward_100_cuda->dim3 interface~cufftexecc2r_c m_cuda_poisson_fft::cufftExecC2R_C proc~fft_backward_100_cuda->interface~cufftexecc2r_c proc~memcpy3d_with_transpose_back m_cuda_spectral::memcpy3D_with_transpose_back proc~fft_backward_100_cuda->proc~memcpy3d_with_transpose_back Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_backward_100_cuda.html"},{"title":"fft_forward_cuda – x3d2","text":"public  subroutine fft_forward_cuda(self, f) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f Calls proc~~fft_forward_cuda~~CallsGraph proc~fft_forward_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_forward_cuda cufftexecd2z cufftexecd2z proc~fft_forward_cuda->cufftexecd2z cufftxtexecdescriptor cufftxtexecdescriptor proc~fft_forward_cuda->cufftxtexecdescriptor dim3 dim3 proc~fft_forward_cuda->dim3 interface~cufftexecr2c_c m_cuda_poisson_fft::cufftExecR2C_C proc~fft_forward_cuda->interface~cufftexecr2c_c proc~memcpy3d m_cuda_spectral::memcpy3D proc~fft_forward_cuda->proc~memcpy3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_forward_cuda.html"},{"title":"fft_backward_cuda – x3d2","text":"public  subroutine fft_backward_cuda(self, f) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f Calls proc~~fft_backward_cuda~~CallsGraph proc~fft_backward_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_backward_cuda cufftexecz2d cufftexecz2d proc~fft_backward_cuda->cufftexecz2d cufftxtexecdescriptor cufftxtexecdescriptor proc~fft_backward_cuda->cufftxtexecdescriptor dim3 dim3 proc~fft_backward_cuda->dim3 interface~cufftexecc2r_c m_cuda_poisson_fft::cufftExecC2R_C proc~fft_backward_cuda->interface~cufftexecc2r_c proc~memcpy3d m_cuda_spectral::memcpy3D proc~fft_backward_cuda->proc~memcpy3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_backward_cuda.html"},{"title":"fft_postprocess_000_cuda – x3d2","text":"public  subroutine fft_postprocess_000_cuda(self) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self Calls proc~~fft_postprocess_000_cuda~~CallsGraph proc~fft_postprocess_000_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_000_cuda dim3 dim3 proc~fft_postprocess_000_cuda->dim3 proc~process_spectral_000~2 m_cuda_spectral::process_spectral_000 proc~fft_postprocess_000_cuda->proc~process_spectral_000~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_postprocess_000_cuda.html"},{"title":"fft_postprocess_100_cuda – x3d2","text":"public  subroutine fft_postprocess_100_cuda(self) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self Calls proc~~fft_postprocess_100_cuda~~CallsGraph proc~fft_postprocess_100_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_100_cuda dim3 dim3 proc~fft_postprocess_100_cuda->dim3 proc~process_spectral_010~2 m_cuda_spectral::process_spectral_010 proc~fft_postprocess_100_cuda->proc~process_spectral_010~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_postprocess_100_cuda.html"},{"title":"fft_postprocess_010_cuda – x3d2","text":"public  subroutine fft_postprocess_010_cuda(self) if stretching in y is 'bottom' Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self Calls proc~~fft_postprocess_010_cuda~~CallsGraph proc~fft_postprocess_010_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_010_cuda dim3 dim3 proc~fft_postprocess_010_cuda->dim3 proc~process_spectral_010_bw m_cuda_spectral::process_spectral_010_bw proc~fft_postprocess_010_cuda->proc~process_spectral_010_bw proc~process_spectral_010_fw m_cuda_spectral::process_spectral_010_fw proc~fft_postprocess_010_cuda->proc~process_spectral_010_fw proc~process_spectral_010_poisson m_cuda_spectral::process_spectral_010_poisson proc~fft_postprocess_010_cuda->proc~process_spectral_010_poisson proc~process_spectral_010~2 m_cuda_spectral::process_spectral_010 proc~fft_postprocess_010_cuda->proc~process_spectral_010~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_postprocess_010_cuda.html"},{"title":"fft_postprocess_110_cuda – x3d2","text":"public  subroutine fft_postprocess_110_cuda(self) if stretching in y is 'bottom' Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self Calls proc~~fft_postprocess_110_cuda~~CallsGraph proc~fft_postprocess_110_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_110_cuda dim3 dim3 proc~fft_postprocess_110_cuda->dim3 proc~process_spectral_010_bw m_cuda_spectral::process_spectral_010_bw proc~fft_postprocess_110_cuda->proc~process_spectral_010_bw proc~process_spectral_010_fw m_cuda_spectral::process_spectral_010_fw proc~fft_postprocess_110_cuda->proc~process_spectral_010_fw proc~process_spectral_010_poisson m_cuda_spectral::process_spectral_010_poisson proc~fft_postprocess_110_cuda->proc~process_spectral_010_poisson proc~process_spectral_110 m_cuda_spectral::process_spectral_110 proc~fft_postprocess_110_cuda->proc~process_spectral_110 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_postprocess_110_cuda.html"},{"title":"enforce_periodicity_x_cuda – x3d2","text":"public  subroutine enforce_periodicity_x_cuda(self, f_out, f_in) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in Calls proc~~enforce_periodicity_x_cuda~~CallsGraph proc~enforce_periodicity_x_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%enforce_periodicity_x_cuda dim3 dim3 proc~enforce_periodicity_x_cuda->dim3 proc~enforce_periodicity_x m_cuda_spectral::enforce_periodicity_x proc~enforce_periodicity_x_cuda->proc~enforce_periodicity_x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/enforce_periodicity_x_cuda.html"},{"title":"undo_periodicity_x_cuda – x3d2","text":"public  subroutine undo_periodicity_x_cuda(self, f_out, f_in) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in Calls proc~~undo_periodicity_x_cuda~~CallsGraph proc~undo_periodicity_x_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%undo_periodicity_x_cuda dim3 dim3 proc~undo_periodicity_x_cuda->dim3 proc~undo_periodicity_x m_cuda_spectral::undo_periodicity_x proc~undo_periodicity_x_cuda->proc~undo_periodicity_x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/undo_periodicity_x_cuda.html"},{"title":"enforce_periodicity_y_cuda – x3d2","text":"public  subroutine enforce_periodicity_y_cuda(self, f_out, f_in) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in Calls proc~~enforce_periodicity_y_cuda~~CallsGraph proc~enforce_periodicity_y_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%enforce_periodicity_y_cuda dim3 dim3 proc~enforce_periodicity_y_cuda->dim3 proc~enforce_periodicity_y m_cuda_spectral::enforce_periodicity_y proc~enforce_periodicity_y_cuda->proc~enforce_periodicity_y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/enforce_periodicity_y_cuda.html"},{"title":"undo_periodicity_y_cuda – x3d2","text":"public  subroutine undo_periodicity_y_cuda(self, f_out, f_in) Type Bound cuda_poisson_fft_t Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in Calls proc~~undo_periodicity_y_cuda~~CallsGraph proc~undo_periodicity_y_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%undo_periodicity_y_cuda dim3 dim3 proc~undo_periodicity_y_cuda->dim3 proc~undo_periodicity_y m_cuda_spectral::undo_periodicity_y proc~undo_periodicity_y_cuda->proc~undo_periodicity_y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/undo_periodicity_y_cuda.html"},{"title":"cuda_poisson_fft_t – x3d2","text":"public interface cuda_poisson_fft_t Module Procedures private  function init(mesh, xdirps, ydirps, zdirps, lowmem) result(poisson_fft) if stretching in y is 'bottom' Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem Return Value type( cuda_poisson_fft_t )","tags":"","url":"interface/cuda_poisson_fft_t.html"},{"title":"cufftExecR2C_C – x3d2","text":"interface Called by interface~~cufftexecr2c_c~~CalledByGraph interface~cufftexecr2c_c m_cuda_poisson_fft::cufftExecR2C_C proc~fft_forward_100_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_forward_100_cuda proc~fft_forward_100_cuda->interface~cufftexecr2c_c proc~fft_forward_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_forward_cuda proc~fft_forward_cuda->interface~cufftexecr2c_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftExecR2C_C(plan, idata, odata) bind(C, name='cufftExecR2C') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: plan type(c_ptr), value :: idata type(c_ptr), value :: odata Return Value integer(kind=c_int)","tags":"","url":"interface/cufftexecr2c_c.html"},{"title":"cufftExecC2R_C – x3d2","text":"interface Called by interface~~cufftexecc2r_c~~CalledByGraph interface~cufftexecc2r_c m_cuda_poisson_fft::cufftExecC2R_C proc~fft_backward_100_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_backward_100_cuda proc~fft_backward_100_cuda->interface~cufftexecc2r_c proc~fft_backward_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_backward_cuda proc~fft_backward_cuda->interface~cufftexecc2r_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function cufftExecC2R_C(plan, idata, odata) bind(C, name='cufftExecC2R') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: plan type(c_ptr), value :: idata type(c_ptr), value :: odata Return Value integer(kind=c_int)","tags":"","url":"interface/cufftexecc2r_c.html"},{"title":"der_univ_thom – x3d2","text":"public  subroutine der_univ_thom(du, u, n_tds, n_rhs, coeffs_s, coeffs_e, coeffs, thom_f, thom_s, thom_w, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: u integer, intent(in) :: n_tds integer, intent(in) :: n_rhs real(kind=dp), intent(in), dimension(:, :) :: coeffs_s real(kind=dp), intent(in), dimension(:, :) :: coeffs_e real(kind=dp), intent(in), dimension(:) :: coeffs real(kind=dp), intent(in), dimension(:) :: thom_f real(kind=dp), intent(in), dimension(:) :: thom_s real(kind=dp), intent(in), dimension(:) :: thom_w real(kind=dp), intent(in), dimension(:) :: strch Called by proc~~der_univ_thom~2~~CalledByGraph proc~der_univ_thom~2 m_omp_kernels_thom::der_univ_thom proc~exec_thom_tds_compact~2 m_exec_thom::exec_thom_tds_compact proc~exec_thom_tds_compact~2->proc~der_univ_thom~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_thom~2.html"},{"title":"der_univ_thom_per – x3d2","text":"public  subroutine der_univ_thom_per(du, u, n, coeffs, alpha, thom_f, thom_s, thom_w, thom_p, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: u integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: coeffs real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in), dimension(:) :: thom_f real(kind=dp), intent(in), dimension(:) :: thom_s real(kind=dp), intent(in), dimension(:) :: thom_w real(kind=dp), intent(in), dimension(:) :: thom_p real(kind=dp), intent(in), dimension(:) :: strch Called by proc~~der_univ_thom_per~2~~CalledByGraph proc~der_univ_thom_per~2 m_omp_kernels_thom::der_univ_thom_per proc~exec_thom_tds_compact~2 m_exec_thom::exec_thom_tds_compact proc~exec_thom_tds_compact~2->proc~der_univ_thom_per~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_thom_per~2.html"},{"title":"case_init – x3d2","text":"public  subroutine case_init(self, backend, mesh, host_allocator) Type Bound base_case_t Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Calls proc~~case_init~~CallsGraph proc~case_init m_base_case::base_case_t%case_init initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_argument m_common::get_argument proc~init~5->proc~get_argument proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~case_init~~CalledByGraph proc~case_init m_base_case::base_case_t%case_init proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/case_init.html"},{"title":"case_finalise – x3d2","text":"public  subroutine case_finalise(self) Type Bound base_case_t Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self Calls proc~~case_finalise~~CallsGraph proc~case_finalise m_base_case::base_case_t%case_finalise none~finalise m_io_manager::io_manager_t%finalise proc~case_finalise->none~finalise proc~is_root m_mesh_content::par_t%is_root proc~case_finalise->proc~is_root none~finalise~7 m_checkpoint_manager::checkpoint_manager_t%finalise none~finalise->none~finalise~7 proc~cleanup_field_buffers m_io_field_utils::cleanup_field_buffers none~finalise~7->proc~cleanup_field_buffers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~case_finalise~~CalledByGraph proc~case_finalise m_base_case::base_case_t%case_finalise proc~run m_base_case::base_case_t%run proc~run->proc~case_finalise program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/case_finalise.html"},{"title":"set_init – x3d2","text":"public  subroutine set_init(self, field, field_func) Type Bound base_case_t Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: field public pure function field_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) Calls proc~~set_init~~CallsGraph proc~set_init m_base_case::base_case_t%set_init proc~get_block m_allocator::allocator_t%get_block proc~set_init->proc~get_block proc~get_coordinates m_mesh::mesh_t%get_coordinates proc~set_init->proc~get_coordinates proc~get_dims m_mesh::mesh_t%get_dims proc~set_init->proc~get_dims proc~release_block m_allocator::allocator_t%release_block proc~set_init->proc~release_block proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~set_init->proc~set_field_data proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block proc~set_field_data->proc~release_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs reorder reorder proc~set_field_data->reorder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_init~~CalledByGraph proc~set_init m_base_case::base_case_t%set_init proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_init.html"},{"title":"print_enstrophy – x3d2","text":"public  subroutine print_enstrophy(self, u, v, w) Reports the enstrophy Type Bound base_case_t Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w Calls proc~~print_enstrophy~~CallsGraph proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~get_block m_allocator::allocator_t%get_block proc~print_enstrophy->proc~get_block proc~is_root m_mesh_content::par_t%is_root proc~print_enstrophy->proc~is_root proc~release_block m_allocator::allocator_t%release_block proc~print_enstrophy->proc~release_block scalar_product scalar_product proc~print_enstrophy->scalar_product proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl~2->proc~curl proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~curl->proc~get_block proc~curl->proc~release_block reorder reorder proc~curl->reorder tds_solve tds_solve proc~curl->tds_solve vecadd vecadd proc~curl->vecadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_enstrophy~~CalledByGraph proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_enstrophy proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_enstrophy proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_enstrophy proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_enstrophy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/print_enstrophy.html"},{"title":"print_div_max_mean – x3d2","text":"public  subroutine print_div_max_mean(self, u, v, w) Reports the div(u) at cell centres Type Bound base_case_t Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w Calls proc~~print_div_max_mean~~CallsGraph proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean field_max_mean field_max_mean proc~print_div_max_mean->field_max_mean proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~print_div_max_mean->proc~divergence_v2p proc~get_block m_allocator::allocator_t%get_block proc~print_div_max_mean->proc~get_block proc~is_root m_mesh_content::par_t%is_root proc~print_div_max_mean->proc~is_root proc~release_block m_allocator::allocator_t%release_block proc~print_div_max_mean->proc~release_block proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~divergence_v2c->proc~get_block proc~divergence_v2c->proc~release_block reorder reorder proc~divergence_v2c->reorder tds_solve tds_solve proc~divergence_v2c->tds_solve vecadd vecadd proc~divergence_v2c->vecadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_div_max_mean~~CalledByGraph proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_div_max_mean proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_div_max_mean proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_div_max_mean proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_div_max_mean Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/print_div_max_mean.html"},{"title":"run – x3d2","text":"public  subroutine run(self) Runs the solver forwards in time from t=t_0 to t=T, performing\npostprocessing/IO and reporting diagnostics. Type Bound base_case_t Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(inout) :: self Calls proc~~run~~CallsGraph proc~run m_base_case::base_case_t%run boundary_conditions boundary_conditions proc~run->boundary_conditions forcings forcings proc~run->forcings none~body m_ibm::ibm_t%body proc~run->none~body none~handle_io_step m_io_manager::io_manager_t%handle_io_step proc~run->none~handle_io_step none~is_restart m_io_manager::io_manager_t%is_restart proc~run->none~is_restart postprocess postprocess proc~run->postprocess pre_correction pre_correction proc~run->pre_correction proc~case_finalise m_base_case::base_case_t%case_finalise proc~run->proc~case_finalise proc~get_block m_allocator::allocator_t%get_block proc~run->proc~get_block proc~is_root m_mesh_content::par_t%is_root proc~run->proc~is_root proc~pressure_correction m_solver::solver_t%pressure_correction proc~run->proc~pressure_correction proc~release_block m_allocator::allocator_t%release_block proc~run->proc~release_block vecmult vecmult none~body->vecmult none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_io_step->none~handle_checkpoint_step none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_io_step->none~handle_snapshot_step none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 proc~case_finalise->proc~is_root none~finalise m_io_manager::io_manager_t%finalise proc~case_finalise->none~finalise proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~pressure_correction->proc~get_block proc~pressure_correction->proc~release_block proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~pressure_correction->proc~divergence_v2p proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~pressure_correction->proc~gradient_p2v vecadd vecadd proc~pressure_correction->vecadd none~finalise~7 m_checkpoint_manager::checkpoint_manager_t%finalise none~finalise->none~finalise~7 mpi_comm_rank mpi_comm_rank none~handle_checkpoint_step->mpi_comm_rank none~is_session_functional m_io_session::io_session_base_t%is_session_functional none~handle_checkpoint_step->none~is_session_functional none~write_data m_io_session::writer_session_t%write_data none~handle_checkpoint_step->none~write_data padded_dims padded_dims none~handle_checkpoint_step->padded_dims proc~cleanup_field_arrays m_io_field_utils::cleanup_field_arrays none~handle_checkpoint_step->proc~cleanup_field_arrays proc~cleanup_field_buffers m_io_field_utils::cleanup_field_buffers none~handle_checkpoint_step->proc~cleanup_field_buffers proc~get_dims m_mesh::mesh_t%get_dims none~handle_checkpoint_step->proc~get_dims proc~get_global_dims m_mesh::mesh_t%get_global_dims none~handle_checkpoint_step->proc~get_global_dims proc~get_output_dimensions m_io_field_utils::get_output_dimensions none~handle_checkpoint_step->proc~get_output_dimensions proc~get_shape m_field::field_t%get_shape none~handle_checkpoint_step->proc~get_shape proc~prepare_field_buffers m_io_field_utils::prepare_field_buffers none~handle_checkpoint_step->proc~prepare_field_buffers proc~setup_field_arrays m_io_field_utils::setup_field_arrays none~handle_checkpoint_step->proc~setup_field_arrays proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer none~handle_checkpoint_step->proc~write_single_field_to_buffer raw_buffers raw_buffers none~handle_checkpoint_step->raw_buffers none~handle_snapshot_step->mpi_comm_rank none~begin_step m_io_session::writer_session_t%begin_step none~handle_snapshot_step->none~begin_step none~end_step m_io_session::writer_session_t%end_step none~handle_snapshot_step->none~end_step none~handle_snapshot_step->none~is_session_functional none~write_attribute m_io_session::writer_session_t%write_attribute none~handle_snapshot_step->none~write_attribute none~handle_snapshot_step->none~write_data none~handle_snapshot_step->proc~cleanup_field_arrays proc~get_coordinates m_mesh::mesh_t%get_coordinates none~handle_snapshot_step->proc~get_coordinates none~handle_snapshot_step->proc~get_dims none~handle_snapshot_step->proc~get_global_dims none~handle_snapshot_step->proc~get_output_dimensions none~handle_snapshot_step->proc~prepare_field_buffers none~handle_snapshot_step->proc~setup_field_arrays none~handle_snapshot_step->proc~write_single_field_to_buffer proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_p2v->proc~gradient_c2v begin_step begin_step none~begin_step->begin_step end_step end_step none~end_step->end_step none~finalise~7->proc~cleanup_field_buffers none~write_attribute~2 m_io_base::io_writer_t%write_attribute none~write_attribute->none~write_attribute~2 none~write_data~2 m_io_base::io_writer_t%write_data none~write_data->none~write_data~2 proc~cleanup_field_arrays->proc~release_block proc~divergence_v2c->proc~get_block proc~divergence_v2c->proc~release_block proc~divergence_v2c->vecadd reorder reorder proc~divergence_v2c->reorder tds_solve tds_solve proc~divergence_v2c->tds_solve proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~gradient_c2v->proc~get_block proc~gradient_c2v->proc~release_block proc~gradient_c2v->reorder proc~gradient_c2v->tds_solve proc~prepare_field_buffers->proc~get_dims proc~prepare_field_buffers->proc~get_global_dims proc~prepare_field_buffers->proc~get_output_dimensions proc~setup_field_arrays->proc~get_block proc~setup_field_arrays->proc~is_root proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~setup_field_arrays->proc~get_field_data proc~write_single_field_to_buffer->proc~get_dims proc~write_single_field_to_buffer->proc~get_global_dims proc~write_single_field_to_buffer->proc~get_output_dimensions proc~stride_data_to_buffer m_io_field_utils::stride_data_to_buffer proc~write_single_field_to_buffer->proc~stride_data_to_buffer proc~get_field_data->proc~get_block proc~get_field_data->proc~release_block proc~get_field_data->reorder copy_f_to_data copy_f_to_data proc~get_field_data->copy_f_to_data proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~get_field_data->proc~get_rdr_from_dirs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run~~CalledByGraph proc~run m_base_case::base_case_t%run program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/run.html"},{"title":"exec_dist_tds_compact – x3d2","text":"public  subroutine exec_dist_tds_compact(du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e type( tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_groups Calls proc~~exec_dist_tds_compact~2~~CallsGraph proc~exec_dist_tds_compact~2 m_omp_exec_dist::exec_dist_tds_compact proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_tds_compact~2->proc~der_univ_dist proc~der_univ_subs m_omp_kernels_dist::der_univ_subs proc~exec_dist_tds_compact~2->proc~der_univ_subs proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~exec_dist_tds_compact~2->proc~sendrecv_fields mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~exec_dist_tds_compact~2~~CalledByGraph proc~exec_dist_tds_compact~2 m_omp_exec_dist::exec_dist_tds_compact proc~tds_solve_dist m_omp_backend::tds_solve_dist proc~tds_solve_dist->proc~exec_dist_tds_compact~2 proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~tds_solve_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/exec_dist_tds_compact~2.html"},{"title":"exec_dist_transeq_compact – x3d2","text":"public  subroutine exec_dist_transeq_compact(rhs_du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, tdsops_du, tdsops_dud, tdsops_d2u, nu, nproc, pprev, pnext, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: rhs_du The result array, it is also used as temporary storage real(kind=dp), intent(out), dimension(:, :, :) :: dud Temporary storage arrays real(kind=dp), intent(out), dimension(:, :, :) :: d2u Temporary storage arrays real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: v real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_e type( tdsops_t ), intent(in) :: tdsops_du type( tdsops_t ), intent(in) :: tdsops_dud type( tdsops_t ), intent(in) :: tdsops_d2u real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_groups Calls proc~~exec_dist_transeq_compact~~CallsGraph proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~der_univ_dist m_omp_kernels_dist::der_univ_dist proc~exec_dist_transeq_compact->proc~der_univ_dist proc~der_univ_fused_subs m_omp_kernels_dist::der_univ_fused_subs proc~exec_dist_transeq_compact->proc~der_univ_fused_subs proc~sendrecv_fields m_omp_sendrecv::sendrecv_fields proc~exec_dist_transeq_compact->proc~sendrecv_fields mpi_irecv mpi_irecv proc~sendrecv_fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~exec_dist_transeq_compact~~CalledByGraph proc~exec_dist_transeq_compact m_omp_exec_dist::exec_dist_transeq_compact proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~exec_dist_transeq_compact proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~exec_dist_transeq_compact proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/exec_dist_transeq_compact.html"},{"title":"case_tgv_init – x3d2","text":"public  function case_tgv_init(backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_tgv_t ) Calls proc~~case_tgv_init~~CallsGraph proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_init m_base_case::base_case_t%case_init proc~case_tgv_init->proc~case_init initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_argument m_common::get_argument proc~init~5->proc~get_argument proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~case_tgv_init~~CalledByGraph proc~case_tgv_init m_case_tgv::case_tgv_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/case_tgv_init.html"},{"title":"u_func – x3d2","text":"public pure function u_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp)","tags":"","url":"proc/u_func.html"},{"title":"v_func – x3d2","text":"public pure function v_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp)","tags":"","url":"proc/v_func.html"},{"title":"initial_conditions_tgv – x3d2","text":"public  subroutine initial_conditions_tgv(self) Type Bound case_tgv_t Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self Calls proc~~initial_conditions_tgv~~CallsGraph proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~fill m_field::field_t%fill proc~initial_conditions_tgv->proc~fill proc~set_data_loc m_field::field_t%set_data_loc proc~initial_conditions_tgv->proc~set_data_loc proc~set_init m_base_case::base_case_t%set_init proc~initial_conditions_tgv->proc~set_init proc~get_block m_allocator::allocator_t%get_block proc~set_init->proc~get_block proc~get_coordinates m_mesh::mesh_t%get_coordinates proc~set_init->proc~get_coordinates proc~get_dims m_mesh::mesh_t%get_dims proc~set_init->proc~get_dims proc~release_block m_allocator::allocator_t%release_block proc~set_init->proc~release_block proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~set_init->proc~set_field_data proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block proc~set_field_data->proc~release_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs reorder reorder proc~set_field_data->reorder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/initial_conditions_tgv.html"},{"title":"boundary_conditions_tgv – x3d2","text":"public  subroutine boundary_conditions_tgv(self) Type Bound case_tgv_t Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self","tags":"","url":"proc/boundary_conditions_tgv.html"},{"title":"forcings_tgv – x3d2","text":"public  subroutine forcings_tgv(self, du, dv, dw, iter) Type Bound case_tgv_t Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter","tags":"","url":"proc/forcings_tgv.html"},{"title":"pre_correction_tgv – x3d2","text":"public  subroutine pre_correction_tgv(self, u, v, w) Type Bound case_tgv_t Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w","tags":"","url":"proc/pre_correction_tgv.html"},{"title":"postprocess_tgv – x3d2","text":"public  subroutine postprocess_tgv(self, iter, t) Type Bound case_tgv_t Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t Calls proc~~postprocess_tgv~~CallsGraph proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~is_root m_mesh_content::par_t%is_root proc~postprocess_tgv->proc~is_root proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~postprocess_tgv->proc~print_div_max_mean proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~postprocess_tgv->proc~print_enstrophy proc~print_div_max_mean->proc~is_root field_max_mean field_max_mean proc~print_div_max_mean->field_max_mean proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~print_div_max_mean->proc~divergence_v2p proc~get_block m_allocator::allocator_t%get_block proc~print_div_max_mean->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~print_div_max_mean->proc~release_block proc~print_enstrophy->proc~is_root proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~print_enstrophy->proc~get_block proc~print_enstrophy->proc~release_block scalar_product scalar_product proc~print_enstrophy->scalar_product proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl~2->proc~curl proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~curl->proc~get_block proc~curl->proc~release_block reorder reorder proc~curl->reorder tds_solve tds_solve proc~curl->tds_solve vecadd vecadd proc~curl->vecadd proc~divergence_v2c->proc~get_block proc~divergence_v2c->proc~release_block proc~divergence_v2c->reorder proc~divergence_v2c->tds_solve proc~divergence_v2c->vecadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/postprocess_tgv.html"},{"title":"case_tgv_t – x3d2","text":"public interface case_tgv_t Calls interface~~case_tgv_t~~CallsGraph interface~case_tgv_t m_case_tgv::case_tgv_t proc~case_tgv_init m_case_tgv::case_tgv_init interface~case_tgv_t->proc~case_tgv_init proc~case_init m_base_case::base_case_t%case_init proc~case_tgv_init->proc~case_init initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_argument m_common::get_argument proc~init~5->proc~get_argument proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function case_tgv_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_tgv_t )","tags":"","url":"interface/case_tgv_t.html"},{"title":"fft_forward_omp – x3d2","text":"public  subroutine fft_forward_omp(self, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in Calls proc~~fft_forward_omp~~CallsGraph proc~fft_forward_omp m_omp_poisson_fft::omp_poisson_fft_t%fft_forward_omp decomp_2d_fft_3d decomp_2d_fft_3d proc~fft_forward_omp->decomp_2d_fft_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_forward_omp.html"},{"title":"fft_forward_010_omp – x3d2","text":"public  subroutine fft_forward_010_omp(self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in","tags":"","url":"proc/fft_forward_010_omp.html"},{"title":"fft_forward_100_omp – x3d2","text":"public  subroutine fft_forward_100_omp(self, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in","tags":"","url":"proc/fft_forward_100_omp.html"},{"title":"fft_forward_110_omp – x3d2","text":"public  subroutine fft_forward_110_omp(self, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in","tags":"","url":"proc/fft_forward_110_omp.html"},{"title":"fft_backward_omp – x3d2","text":"public  subroutine fft_backward_omp(self, f_out) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out Calls proc~~fft_backward_omp~~CallsGraph proc~fft_backward_omp m_omp_poisson_fft::omp_poisson_fft_t%fft_backward_omp decomp_2d_fft_3d decomp_2d_fft_3d proc~fft_backward_omp->decomp_2d_fft_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_backward_omp.html"},{"title":"fft_backward_010_omp – x3d2","text":"public  subroutine fft_backward_010_omp(self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out","tags":"","url":"proc/fft_backward_010_omp.html"},{"title":"fft_backward_100_omp – x3d2","text":"public  subroutine fft_backward_100_omp(self, f_out) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out","tags":"","url":"proc/fft_backward_100_omp.html"},{"title":"fft_backward_110_omp – x3d2","text":"public  subroutine fft_backward_110_omp(self, f_out) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out","tags":"","url":"proc/fft_backward_110_omp.html"},{"title":"fft_postprocess_000_omp – x3d2","text":"public  subroutine fft_postprocess_000_omp(self) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self Calls proc~~fft_postprocess_000_omp~~CallsGraph proc~fft_postprocess_000_omp m_omp_poisson_fft::omp_poisson_fft_t%fft_postprocess_000_omp proc~process_spectral_000 m_omp_spectral::process_spectral_000 proc~fft_postprocess_000_omp->proc~process_spectral_000 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_postprocess_000_omp.html"},{"title":"fft_postprocess_010_omp – x3d2","text":"public  subroutine fft_postprocess_010_omp(self) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self Calls proc~~fft_postprocess_010_omp~~CallsGraph proc~fft_postprocess_010_omp m_omp_poisson_fft::omp_poisson_fft_t%fft_postprocess_010_omp proc~process_spectral_010 m_omp_spectral::process_spectral_010 proc~fft_postprocess_010_omp->proc~process_spectral_010 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fft_postprocess_010_omp.html"},{"title":"fft_postprocess_100_omp – x3d2","text":"public  subroutine fft_postprocess_100_omp(self) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self","tags":"","url":"proc/fft_postprocess_100_omp.html"},{"title":"fft_postprocess_110_omp – x3d2","text":"public  subroutine fft_postprocess_110_omp(self) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self","tags":"","url":"proc/fft_postprocess_110_omp.html"},{"title":"enforce_periodicity_x_omp – x3d2","text":"public  subroutine enforce_periodicity_x_omp(self, f_out, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"proc/enforce_periodicity_x_omp.html"},{"title":"undo_periodicity_x_omp – x3d2","text":"public  subroutine undo_periodicity_x_omp(self, f_out, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"proc/undo_periodicity_x_omp.html"},{"title":"enforce_periodicity_y_omp – x3d2","text":"public  subroutine enforce_periodicity_y_omp(self, f_out, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"proc/enforce_periodicity_y_omp.html"},{"title":"undo_periodicity_y_omp – x3d2","text":"public  subroutine undo_periodicity_y_omp(self, f_out, f_in) Type Bound omp_poisson_fft_t Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"proc/undo_periodicity_y_omp.html"},{"title":"omp_poisson_fft_t – x3d2","text":"public interface omp_poisson_fft_t Module Procedures private  function init(mesh, xdirps, ydirps, zdirps, lowmem) result(poisson_fft) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(in) :: mesh class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem Return Value type( omp_poisson_fft_t )","tags":"","url":"interface/omp_poisson_fft_t.html"},{"title":"reorder_c2x – x3d2","text":"public  subroutine reorder_c2x(u_x, u_c, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_c integer, intent(in), value :: nz Calls proc~~reorder_c2x~~CallsGraph proc~reorder_c2x m_cuda_kernels_reorder::reorder_c2x syncthreads syncthreads proc~reorder_c2x->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~reorder_c2x~~CalledByGraph proc~reorder_c2x m_cuda_kernels_reorder::reorder_c2x proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~reorder_c2x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_c2x.html"},{"title":"reorder_x2c – x3d2","text":"public  subroutine reorder_x2c(u_c, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_c real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz Calls proc~~reorder_x2c~~CallsGraph proc~reorder_x2c m_cuda_kernels_reorder::reorder_x2c syncthreads syncthreads proc~reorder_x2c->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~reorder_x2c~~CalledByGraph proc~reorder_x2c m_cuda_kernels_reorder::reorder_x2c proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~reorder_x2c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_x2c.html"},{"title":"reorder_x2y – x3d2","text":"public  subroutine reorder_x2y(u_y, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz Calls proc~~reorder_x2y~~CallsGraph proc~reorder_x2y m_cuda_kernels_reorder::reorder_x2y syncthreads syncthreads proc~reorder_x2y->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~reorder_x2y~~CalledByGraph proc~reorder_x2y m_cuda_kernels_reorder::reorder_x2y proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~reorder_x2y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_x2y.html"},{"title":"reorder_x2z – x3d2","text":"public  subroutine reorder_x2z(u_z, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz Called by proc~~reorder_x2z~~CalledByGraph proc~reorder_x2z m_cuda_kernels_reorder::reorder_x2z proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~reorder_x2z Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_x2z.html"},{"title":"reorder_y2x – x3d2","text":"public  subroutine reorder_y2x(u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz Calls proc~~reorder_y2x~~CallsGraph proc~reorder_y2x m_cuda_kernels_reorder::reorder_y2x syncthreads syncthreads proc~reorder_y2x->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~reorder_y2x~~CalledByGraph proc~reorder_y2x m_cuda_kernels_reorder::reorder_y2x proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~reorder_y2x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_y2x.html"},{"title":"reorder_y2z – x3d2","text":"public  subroutine reorder_y2z(u_z, u_y, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nx integer, intent(in), value :: nz Calls proc~~reorder_y2z~~CallsGraph proc~reorder_y2z m_cuda_kernels_reorder::reorder_y2z syncthreads syncthreads proc~reorder_y2z->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~reorder_y2z~~CalledByGraph proc~reorder_y2z m_cuda_kernels_reorder::reorder_y2z proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~reorder_y2z Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_y2z.html"},{"title":"reorder_z2x – x3d2","text":"public  subroutine reorder_z2x(u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz Called by proc~~reorder_z2x~~CalledByGraph proc~reorder_z2x m_cuda_kernels_reorder::reorder_z2x proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~reorder_z2x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_z2x.html"},{"title":"reorder_z2y – x3d2","text":"public  subroutine reorder_z2y(u_y, u_z, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nx integer, intent(in), value :: nz Calls proc~~reorder_z2y~~CallsGraph proc~reorder_z2y m_cuda_kernels_reorder::reorder_z2y syncthreads syncthreads proc~reorder_z2y->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~reorder_z2y~~CalledByGraph proc~reorder_z2y m_cuda_kernels_reorder::reorder_z2y proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~reorder_z2y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_z2y.html"},{"title":"sum_yintox – x3d2","text":"public  subroutine sum_yintox(u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz Calls proc~~sum_yintox~~CallsGraph proc~sum_yintox m_cuda_kernels_reorder::sum_yintox syncthreads syncthreads proc~sum_yintox->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_yintox~~CalledByGraph proc~sum_yintox m_cuda_kernels_reorder::sum_yintox proc~sum_yintox_cuda m_cuda_backend::cuda_backend_t%sum_yintox_cuda proc~sum_yintox_cuda->proc~sum_yintox Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sum_yintox.html"},{"title":"sum_zintox – x3d2","text":"public  subroutine sum_zintox(u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz Called by proc~~sum_zintox~~CalledByGraph proc~sum_zintox m_cuda_kernels_reorder::sum_zintox proc~sum_zintox_cuda m_cuda_backend::cuda_backend_t%sum_zintox_cuda proc~sum_zintox_cuda->proc~sum_zintox Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sum_zintox.html"},{"title":"ibm_t – x3d2","text":"public interface ibm_t Module Procedures private  function init(backend, mesh, host_allocator) result(ibm) Initialize the basic IBM Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( ibm_t )","tags":"","url":"interface/ibm_t.html"},{"title":"base_init – x3d2","text":"public  subroutine base_init(self) Type Bound base_backend_t Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self Called by proc~~base_init~2~~CalledByGraph proc~base_init~2 m_base_backend::base_backend_t%base_init proc~init m_omp_backend::init proc~init->proc~base_init~2 proc~init~9 m_cuda_backend::init proc~init~9->proc~base_init~2 interface~cuda_backend_t m_cuda_backend::cuda_backend_t interface~cuda_backend_t->proc~init~9 interface~omp_backend_t m_omp_backend::omp_backend_t interface~omp_backend_t->proc~init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/base_init~2.html"},{"title":"get_field_data – x3d2","text":"public  subroutine get_field_data(self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Type Bound base_backend_t Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) Calls proc~~get_field_data~~CallsGraph proc~get_field_data m_base_backend::base_backend_t%get_field_data copy_f_to_data copy_f_to_data proc~get_field_data->copy_f_to_data proc~get_block m_allocator::allocator_t%get_block proc~get_field_data->proc~get_block proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~get_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~get_field_data->proc~release_block reorder reorder proc~get_field_data->reorder proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_field_data~~CalledByGraph proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp proc~scalar_product_omp->proc~get_field_data proc~setup_field_arrays m_io_field_utils::setup_field_arrays proc~setup_field_arrays->proc~get_field_data none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~setup_field_arrays none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~setup_field_arrays none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_field_data.html"},{"title":"set_field_data – x3d2","text":"public  subroutine set_field_data(self, f, data, dir) Type Bound base_backend_t Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian) Calls proc~~set_field_data~~CallsGraph proc~set_field_data m_base_backend::base_backend_t%set_field_data copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_block m_allocator::allocator_t%get_block proc~set_field_data->proc~get_block proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_field_data~~CalledByGraph proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~set_field_data proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~set_field_data proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~set_field_data proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~set_field_data none~handle_restart m_io_manager::io_manager_t%handle_restart none~handle_restart->none~handle_restart~2 proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init proc~case_init m_base_case::base_case_t%case_init proc~case_init->none~handle_restart proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_field_data.html"},{"title":"field_init – x3d2","text":"public  function field_init(ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) Called by proc~~field_init~~CalledByGraph proc~field_init m_field::field_init interface~field_t m_field::field_t interface~field_t->proc~field_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_init.html"},{"title":"get_shape – x3d2","text":"public  function get_shape(self) result(dims) Type Bound field_t Arguments Type Intent Optional Attributes Name class( field_t ) :: self Return Value integer, (3) Called by proc~~get_shape~~CalledByGraph proc~get_shape m_field::field_t%get_shape none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~get_shape none~handle_io_step m_io_manager::io_manager_t%handle_io_step none~handle_io_step->none~handle_checkpoint_step proc~run m_base_case::base_case_t%run proc~run->none~handle_io_step program~xcompact xcompact program~xcompact->proc~run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_shape.html"},{"title":"fill – x3d2","text":"public  subroutine fill(self, c) Type Bound field_t Arguments Type Intent Optional Attributes Name class( field_t ) :: self real(kind=dp), intent(in) :: c Called by proc~~fill~~CalledByGraph proc~fill m_field::field_t%fill none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~fill proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~fill proc~initial_conditions_generic m_case_generic::case_generic_t%initial_conditions_generic proc~initial_conditions_generic->proc~fill proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~fill proc~poisson_cg m_solver::poisson_cg proc~poisson_cg->proc~fill none~handle_restart m_io_manager::io_manager_t%handle_restart none~handle_restart->none~handle_restart~2 proc~case_init m_base_case::base_case_t%case_init proc~case_init->none~handle_restart proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/fill.html"},{"title":"set_data_loc – x3d2","text":"public  subroutine set_data_loc(self, data_loc) Type Bound field_t Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: data_loc Called by proc~~set_data_loc~~CalledByGraph proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~set_data_loc proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~set_data_loc proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~set_data_loc proc~initial_conditions_generic m_case_generic::case_generic_t%initial_conditions_generic proc~initial_conditions_generic->proc~set_data_loc proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_data_loc proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~set_data_loc proc~reorder_omp m_omp_backend::omp_backend_t%reorder_omp proc~reorder_omp->proc~set_data_loc proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~set_data_loc proc~tds_solve_omp m_omp_backend::omp_backend_t%tds_solve_omp proc~tds_solve_omp->proc~set_data_loc proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~set_data_loc proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~set_data_loc proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~set_data_loc proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~set_data_loc none~handle_restart m_io_manager::io_manager_t%handle_restart none~handle_restart->none~handle_restart~2 proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist proc~case_init m_base_case::base_case_t%case_init proc~case_init->none~handle_restart proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_data_loc.html"},{"title":"set_shape – x3d2","text":"public  subroutine set_shape(self, dims) Type Bound field_t Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: dims (3) Called by proc~~set_shape~~CalledByGraph proc~set_shape m_field::field_t%set_shape proc~get_block m_allocator::allocator_t%get_block proc~get_block->proc~set_shape proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl->proc~get_block proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2c->proc~get_block proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~get_field_data->proc~get_block proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_c2v->proc~get_block proc~initial_conditions_channel m_case_channel::case_channel_t%initial_conditions_channel proc~initial_conditions_channel->proc~get_block proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~initial_conditions_channel->proc~set_field_data proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~initial_conditions_cylinder->proc~get_block proc~initial_conditions_cylinder->proc~set_field_data proc~init~10 m_time_integrator::init proc~init~10->proc~get_block proc~init~5 m_solver::init proc~init~5->proc~get_block proc~laplacian m_vector_calculus::vector_calculus_t%laplacian proc~laplacian->proc~get_block proc~poisson_fft m_solver::poisson_fft proc~poisson_fft->proc~get_block proc~pressure_correction m_solver::solver_t%pressure_correction proc~pressure_correction->proc~get_block proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~pressure_correction->proc~divergence_v2p proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~pressure_correction->proc~gradient_p2v proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~print_div_max_mean->proc~get_block proc~print_div_max_mean->proc~divergence_v2p proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~print_enstrophy->proc~get_block proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~get_block proc~run m_base_case::base_case_t%run proc~run->proc~get_block proc~run->proc~pressure_correction none~handle_io_step m_io_manager::io_manager_t%handle_io_step proc~run->none~handle_io_step proc~scalar_product_omp m_omp_backend::omp_backend_t%scalar_product_omp proc~scalar_product_omp->proc~get_block proc~scalar_product_omp->proc~get_field_data proc~set_field_data->proc~get_block proc~set_init m_base_case::base_case_t%set_init proc~set_init->proc~get_block proc~set_init->proc~set_field_data proc~setup_field_arrays m_io_field_utils::setup_field_arrays proc~setup_field_arrays->proc~get_block proc~setup_field_arrays->proc~get_field_data proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~get_block proc~transeq_default m_solver::transeq_default proc~transeq_default->proc~get_block proc~transeq_species m_solver::solver_t%transeq_species proc~transeq_default->proc~transeq_species proc~transeq_lowmem m_solver::transeq_lowmem proc~transeq_lowmem->proc~get_block proc~transeq_lowmem->proc~transeq_species proc~transeq_omp_dist m_omp_backend::omp_backend_t%transeq_omp_dist proc~transeq_omp_dist->proc~get_block proc~transeq_species->proc~get_block proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~get_block proc~transeq_species_omp m_omp_backend::omp_backend_t%transeq_species_omp proc~transeq_species_omp->proc~get_block interface~solver_t m_solver::solver_t interface~solver_t->proc~init~5 interface~time_intg_t m_time_integrator::time_intg_t interface~time_intg_t->proc~init~10 none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_checkpoint_step->proc~setup_field_arrays none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart~2->proc~set_field_data none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_snapshot_step->proc~setup_field_arrays proc~case_init m_base_case::base_case_t%case_init proc~case_init->proc~init~5 none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart proc~curl~2->proc~curl proc~divergence_v2p->proc~divergence_v2c proc~gradient_p2v->proc~gradient_c2v proc~initial_conditions_tgv m_case_tgv::case_tgv_t%initial_conditions_tgv proc~initial_conditions_tgv->proc~set_init proc~postprocess_channel m_case_channel::case_channel_t%postprocess_channel proc~postprocess_channel->proc~print_div_max_mean proc~postprocess_channel->proc~print_enstrophy proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~postprocess_cylinder->proc~print_div_max_mean proc~postprocess_cylinder->proc~print_enstrophy proc~postprocess_generic m_case_generic::case_generic_t%postprocess_generic proc~postprocess_generic->proc~print_div_max_mean proc~postprocess_generic->proc~print_enstrophy proc~postprocess_tgv m_case_tgv::case_tgv_t%postprocess_tgv proc~postprocess_tgv->proc~print_div_max_mean proc~postprocess_tgv->proc~print_enstrophy proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_x_omp m_omp_backend::omp_backend_t%transeq_x_omp proc~transeq_x_omp->proc~transeq_omp_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_y_omp m_omp_backend::omp_backend_t%transeq_y_omp proc~transeq_y_omp->proc~transeq_omp_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist proc~transeq_z_omp m_omp_backend::omp_backend_t%transeq_z_omp proc~transeq_z_omp->proc~transeq_omp_dist program~xcompact xcompact program~xcompact->proc~run none~handle_io_step->none~handle_checkpoint_step none~handle_io_step->none~handle_snapshot_step none~handle_restart->none~handle_restart~2 proc~case_channel_init m_case_channel::case_channel_init proc~case_channel_init->proc~case_init proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_cylinder_init->proc~case_init proc~case_generic_init m_case_generic::case_generic_init proc~case_generic_init->proc~case_init proc~case_tgv_init m_case_tgv::case_tgv_init proc~case_tgv_init->proc~case_init interface~case_channel_t m_case_channel::case_channel_t interface~case_channel_t->proc~case_channel_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init interface~case_generic_t m_case_generic::case_generic_t interface~case_generic_t->proc~case_generic_init interface~case_tgv_t m_case_tgv::case_tgv_t interface~case_tgv_t->proc~case_tgv_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_shape.html"},{"title":"field_t – x3d2","text":"public interface field_t Calls interface~~field_t~~CallsGraph interface~field_t m_field::field_t proc~field_init m_field::field_init interface~field_t->proc~field_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t )","tags":"","url":"interface/field_t.html"},{"title":"exec_thom_tds_compact – x3d2","text":"public  subroutine exec_thom_tds_compact(du, u, tdsops, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(in), dimension(:, :, :) :: u type( tdsops_t ), intent(in) :: tdsops integer, intent(in) :: n_groups Calls proc~~exec_thom_tds_compact~2~~CallsGraph proc~exec_thom_tds_compact~2 m_exec_thom::exec_thom_tds_compact proc~der_univ_thom_per~2 m_omp_kernels_thom::der_univ_thom_per proc~exec_thom_tds_compact~2->proc~der_univ_thom_per~2 proc~der_univ_thom~2 m_omp_kernels_thom::der_univ_thom proc~exec_thom_tds_compact~2->proc~der_univ_thom~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/exec_thom_tds_compact~2.html"},{"title":"case_cylinder_init – x3d2","text":"public  function case_cylinder_init(backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_cylinder_t ) Calls proc~~case_cylinder_init~~CallsGraph proc~case_cylinder_init m_case_cylinder::case_cylinder_init proc~case_init m_base_case::base_case_t%case_init proc~case_cylinder_init->proc~case_init proc~get_argument m_common::get_argument proc~case_cylinder_init->proc~get_argument initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 proc~init~5->proc~get_argument init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~case_cylinder_init~~CalledByGraph proc~case_cylinder_init m_case_cylinder::case_cylinder_init interface~case_cylinder_t m_case_cylinder::case_cylinder_t interface~case_cylinder_t->proc~case_cylinder_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/case_cylinder_init.html"},{"title":"boundary_conditions_cylinder – x3d2","text":"public  subroutine boundary_conditions_cylinder(self) Type Bound case_cylinder_t Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self","tags":"","url":"proc/boundary_conditions_cylinder.html"},{"title":"initial_conditions_cylinder – x3d2","text":"public  subroutine initial_conditions_cylinder(self) Type Bound case_cylinder_t Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self Calls proc~~initial_conditions_cylinder~~CallsGraph proc~initial_conditions_cylinder m_case_cylinder::case_cylinder_t%initial_conditions_cylinder proc~fill m_field::field_t%fill proc~initial_conditions_cylinder->proc~fill proc~get_block m_allocator::allocator_t%get_block proc~initial_conditions_cylinder->proc~get_block proc~get_dims m_mesh::mesh_t%get_dims proc~initial_conditions_cylinder->proc~get_dims proc~release_block m_allocator::allocator_t%release_block proc~initial_conditions_cylinder->proc~release_block proc~set_data_loc m_field::field_t%set_data_loc proc~initial_conditions_cylinder->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data proc~initial_conditions_cylinder->proc~set_field_data proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block proc~set_field_data->proc~release_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs reorder reorder proc~set_field_data->reorder Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/initial_conditions_cylinder.html"},{"title":"forcings_cylinder – x3d2","text":"public  subroutine forcings_cylinder(self, du, dv, dw, iter) Type Bound case_cylinder_t Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter","tags":"","url":"proc/forcings_cylinder.html"},{"title":"pre_correction_cylinder – x3d2","text":"public  subroutine pre_correction_cylinder(self, u, v, w) Type Bound case_cylinder_t Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w","tags":"","url":"proc/pre_correction_cylinder.html"},{"title":"postprocess_cylinder – x3d2","text":"public  subroutine postprocess_cylinder(self, iter, t) Type Bound case_cylinder_t Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t Calls proc~~postprocess_cylinder~~CallsGraph proc~postprocess_cylinder m_case_cylinder::case_cylinder_t%postprocess_cylinder proc~is_root m_mesh_content::par_t%is_root proc~postprocess_cylinder->proc~is_root proc~print_div_max_mean m_base_case::base_case_t%print_div_max_mean proc~postprocess_cylinder->proc~print_div_max_mean proc~print_enstrophy m_base_case::base_case_t%print_enstrophy proc~postprocess_cylinder->proc~print_enstrophy proc~print_div_max_mean->proc~is_root field_max_mean field_max_mean proc~print_div_max_mean->field_max_mean proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~print_div_max_mean->proc~divergence_v2p proc~get_block m_allocator::allocator_t%get_block proc~print_div_max_mean->proc~get_block proc~release_block m_allocator::allocator_t%release_block proc~print_div_max_mean->proc~release_block proc~print_enstrophy->proc~is_root proc~curl~2 m_solver::solver_t%curl proc~print_enstrophy->proc~curl~2 proc~print_enstrophy->proc~get_block proc~print_enstrophy->proc~release_block scalar_product scalar_product proc~print_enstrophy->scalar_product proc~curl m_vector_calculus::vector_calculus_t%curl proc~curl~2->proc~curl proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~curl->proc~get_block proc~curl->proc~release_block reorder reorder proc~curl->reorder tds_solve tds_solve proc~curl->tds_solve vecadd vecadd proc~curl->vecadd proc~divergence_v2c->proc~get_block proc~divergence_v2c->proc~release_block proc~divergence_v2c->reorder proc~divergence_v2c->tds_solve proc~divergence_v2c->vecadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/postprocess_cylinder.html"},{"title":"case_cylinder_t – x3d2","text":"public interface case_cylinder_t Calls interface~~case_cylinder_t~~CallsGraph interface~case_cylinder_t m_case_cylinder::case_cylinder_t proc~case_cylinder_init m_case_cylinder::case_cylinder_init interface~case_cylinder_t->proc~case_cylinder_init proc~case_init m_base_case::base_case_t%case_init proc~case_cylinder_init->proc~case_init proc~get_argument m_common::get_argument proc~case_cylinder_init->proc~get_argument initial_conditions initial_conditions proc~case_init->initial_conditions none~handle_restart m_io_manager::io_manager_t%handle_restart proc~case_init->none~handle_restart none~is_restart m_io_manager::io_manager_t%is_restart proc~case_init->none~is_restart proc~init~5 m_solver::init proc~case_init->proc~init~5 none~handle_restart~2 m_checkpoint_manager::checkpoint_manager_t%handle_restart none~handle_restart->none~handle_restart~2 none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 proc~init~5->proc~get_argument init_poisson_fft init_poisson_fft proc~init~5->init_poisson_fft proc~allocate_tdsops m_solver::allocate_tdsops proc~init~5->proc~allocate_tdsops proc~get_block m_allocator::allocator_t%get_block proc~init~5->proc~get_block proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~init~5->proc~get_global_dims proc~is_root m_mesh_content::par_t%is_root proc~init~5->proc~is_root none~handle_restart~2->proc~is_root field_data_u field_data_u none~handle_restart~2->field_data_u field_data_v field_data_v none~handle_restart~2->field_data_v field_data_w field_data_w none~handle_restart~2->field_data_w mpi_abort mpi_abort none~handle_restart~2->mpi_abort mpi_comm_rank mpi_comm_rank none~handle_restart~2->mpi_comm_rank none~read_data m_io_session::reader_session_t%read_data none~handle_restart~2->none~read_data old_field old_field none~handle_restart~2->old_field padded_dims padded_dims none~handle_restart~2->padded_dims proc~fill m_field::field_t%fill none~handle_restart~2->proc~fill proc~get_dims m_mesh::mesh_t%get_dims none~handle_restart~2->proc~get_dims proc~set_data_loc m_field::field_t%set_data_loc none~handle_restart~2->proc~set_data_loc proc~set_field_data m_base_backend::base_backend_t%set_field_data none~handle_restart~2->proc~set_field_data alloc_tdsops alloc_tdsops proc~allocate_tdsops->alloc_tdsops none~get_n m_mesh::mesh_t%get_n proc~allocate_tdsops->none~get_n proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi none~read_data~2 m_io_base::io_reader_t%read_data none~read_data->none~read_data~2 proc~get_dims->proc~get_dims_dataloc proc~set_field_data->proc~get_block copy_data_to_f copy_data_to_f proc~set_field_data->copy_data_to_f proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~set_field_data->proc~get_rdr_from_dirs proc~release_block m_allocator::allocator_t%release_block proc~set_field_data->proc~release_block reorder reorder proc~set_field_data->reorder proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function case_cylinder_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_cylinder_t )","tags":"","url":"interface/case_cylinder_t.html"},{"title":"is_avail_2decomp – x3d2","text":"public  function is_avail_2decomp() result(avail) Arguments None Return Value logical","tags":"","url":"proc/is_avail_2decomp~2.html"},{"title":"decomposition_2decomp – x3d2","text":"public  subroutine decomposition_2decomp(grid, par) Uses m_mesh_content proc~~decomposition_2decomp~2~~UsesGraph proc~decomposition_2decomp~2 m_decomp::decomposition_2decomp module~m_mesh_content m_mesh_content proc~decomposition_2decomp~2->module~m_mesh_content module~m_common m_common module~m_mesh_content->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: grid class( par_t ), intent(inout) :: par","tags":"","url":"proc/decomposition_2decomp~2.html"},{"title":"init – x3d2","text":"public  function init(mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) Calls proc~~init~9~~CallsGraph proc~init~9 m_cuda_backend::init dim3 dim3 proc~init~9->dim3 proc~base_init~2 m_base_backend::base_backend_t%base_init proc~init~9->proc~base_init~2 proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~init~9->proc~get_n_groups Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init~9~~CalledByGraph proc~init~9 m_cuda_backend::init interface~cuda_backend_t m_cuda_backend::cuda_backend_t interface~cuda_backend_t->proc~init~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/init~9.html"},{"title":"scalar_product_cuda – x3d2","text":"public  function scalar_product_cuda(self, x, y) result(s) m_base_backend Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) Calls proc~~scalar_product_cuda~~CallsGraph proc~scalar_product_cuda m_cuda_backend::cuda_backend_t%scalar_product_cuda dim3 dim3 proc~scalar_product_cuda->dim3 mpi_allreduce mpi_allreduce proc~scalar_product_cuda->mpi_allreduce proc~get_dims m_mesh::mesh_t%get_dims proc~scalar_product_cuda->proc~get_dims proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~scalar_product_cuda->proc~get_padded_dims proc~resolve_field_t m_cuda_backend::resolve_field_t proc~scalar_product_cuda->proc~resolve_field_t proc~scalar_product m_cuda_kernels_fieldops::scalar_product proc~scalar_product_cuda->proc~scalar_product proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc atomicadd atomicadd proc~scalar_product->atomicadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/scalar_product_cuda.html"},{"title":"field_volume_integral_cuda – x3d2","text":"public  function field_volume_integral_cuda(self, f) result(s) volume integral of a field Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) Calls proc~~field_volume_integral_cuda~~CallsGraph proc~field_volume_integral_cuda m_cuda_backend::cuda_backend_t%field_volume_integral_cuda dim3 dim3 proc~field_volume_integral_cuda->dim3 mpi_allreduce mpi_allreduce proc~field_volume_integral_cuda->mpi_allreduce proc~get_dims m_mesh::mesh_t%get_dims proc~field_volume_integral_cuda->proc~get_dims proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~field_volume_integral_cuda->proc~get_padded_dims proc~resolve_field_t m_cuda_backend::resolve_field_t proc~field_volume_integral_cuda->proc~resolve_field_t proc~volume_integral m_cuda_kernels_fieldops::volume_integral proc~field_volume_integral_cuda->proc~volume_integral proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc atomicadd atomicadd proc~volume_integral->atomicadd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_volume_integral_cuda.html"},{"title":"alloc_cuda_tdsops – x3d2","text":"public  subroutine alloc_cuda_tdsops(self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu","tags":"","url":"proc/alloc_cuda_tdsops.html"},{"title":"transeq_x_cuda – x3d2","text":"public  subroutine transeq_x_cuda(self, du, dv, dw, u, v, w, nu, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps Calls proc~~transeq_x_cuda~~CallsGraph proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_x_cuda->proc~transeq_cuda_dist none~get_n m_mesh::mesh_t%get_n proc~transeq_cuda_dist->none~get_n proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~transeq_cuda_dist->proc~copy_into_buffers~2 proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~transeq_cuda_dist->proc~exec_dist_transeq_3fused proc~get_block m_allocator::allocator_t%get_block proc~transeq_cuda_dist->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_cuda_dist->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_cuda_dist->proc~release_block proc~resolve_field_t m_cuda_backend::resolve_field_t proc~transeq_cuda_dist->proc~resolve_field_t proc~sendrecv_3fields m_cuda_sendrecv::sendrecv_3fields proc~transeq_cuda_dist->proc~sendrecv_3fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_cuda_dist->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi dim3 dim3 proc~copy_into_buffers~2->dim3 proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2->proc~buffer_copy proc~exec_dist_transeq_3fused->proc~sendrecv_3fields proc~transeq_3fused_dist m_cuda_kernels_dist::transeq_3fused_dist proc~exec_dist_transeq_3fused->proc~transeq_3fused_dist proc~transeq_3fused_subs m_cuda_kernels_dist::transeq_3fused_subs proc~exec_dist_transeq_3fused->proc~transeq_3fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_3fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_3fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_3fields->mpi_waitall proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_x_cuda.html"},{"title":"transeq_y_cuda – x3d2","text":"public  subroutine transeq_y_cuda(self, du, dv, dw, u, v, w, nu, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps Calls proc~~transeq_y_cuda~~CallsGraph proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_y_cuda->proc~transeq_cuda_dist none~get_n m_mesh::mesh_t%get_n proc~transeq_cuda_dist->none~get_n proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~transeq_cuda_dist->proc~copy_into_buffers~2 proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~transeq_cuda_dist->proc~exec_dist_transeq_3fused proc~get_block m_allocator::allocator_t%get_block proc~transeq_cuda_dist->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_cuda_dist->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_cuda_dist->proc~release_block proc~resolve_field_t m_cuda_backend::resolve_field_t proc~transeq_cuda_dist->proc~resolve_field_t proc~sendrecv_3fields m_cuda_sendrecv::sendrecv_3fields proc~transeq_cuda_dist->proc~sendrecv_3fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_cuda_dist->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi dim3 dim3 proc~copy_into_buffers~2->dim3 proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2->proc~buffer_copy proc~exec_dist_transeq_3fused->proc~sendrecv_3fields proc~transeq_3fused_dist m_cuda_kernels_dist::transeq_3fused_dist proc~exec_dist_transeq_3fused->proc~transeq_3fused_dist proc~transeq_3fused_subs m_cuda_kernels_dist::transeq_3fused_subs proc~exec_dist_transeq_3fused->proc~transeq_3fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_3fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_3fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_3fields->mpi_waitall proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_y_cuda.html"},{"title":"transeq_z_cuda – x3d2","text":"public  subroutine transeq_z_cuda(self, du, dv, dw, u, v, w, nu, dirps) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps Calls proc~~transeq_z_cuda~~CallsGraph proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_z_cuda->proc~transeq_cuda_dist none~get_n m_mesh::mesh_t%get_n proc~transeq_cuda_dist->none~get_n proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~transeq_cuda_dist->proc~copy_into_buffers~2 proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~transeq_cuda_dist->proc~exec_dist_transeq_3fused proc~get_block m_allocator::allocator_t%get_block proc~transeq_cuda_dist->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_cuda_dist->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_cuda_dist->proc~release_block proc~resolve_field_t m_cuda_backend::resolve_field_t proc~transeq_cuda_dist->proc~resolve_field_t proc~sendrecv_3fields m_cuda_sendrecv::sendrecv_3fields proc~transeq_cuda_dist->proc~sendrecv_3fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_cuda_dist->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi dim3 dim3 proc~copy_into_buffers~2->dim3 proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2->proc~buffer_copy proc~exec_dist_transeq_3fused->proc~sendrecv_3fields proc~transeq_3fused_dist m_cuda_kernels_dist::transeq_3fused_dist proc~exec_dist_transeq_3fused->proc~transeq_3fused_dist proc~transeq_3fused_subs m_cuda_kernels_dist::transeq_3fused_subs proc~exec_dist_transeq_3fused->proc~transeq_3fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_3fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_3fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_3fields->mpi_waitall proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_z_cuda.html"},{"title":"transeq_species_cuda – x3d2","text":"public  subroutine transeq_species_cuda(self, dspec, uvw, spec, nu, dirps, sync) Compute the convection and diffusion for the given field\nin the given direction.\nHalo exchange for the given field is necessary\nWhen sync is true, halo exchange of momentum is necessary Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync Calls proc~~transeq_species_cuda~~CallsGraph proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda none~get_n m_mesh::mesh_t%get_n proc~transeq_species_cuda->none~get_n proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~transeq_species_cuda->proc~copy_into_buffers~2 proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~transeq_species_cuda->proc~exec_dist_transeq_3fused proc~get_block m_allocator::allocator_t%get_block proc~transeq_species_cuda->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_species_cuda->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_species_cuda->proc~release_block proc~resolve_field_t m_cuda_backend::resolve_field_t proc~transeq_species_cuda->proc~resolve_field_t proc~sendrecv_fields~2 m_cuda_sendrecv::sendrecv_fields proc~transeq_species_cuda->proc~sendrecv_fields~2 proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_species_cuda->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi dim3 dim3 proc~copy_into_buffers~2->dim3 proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2->proc~buffer_copy proc~sendrecv_3fields m_cuda_sendrecv::sendrecv_3fields proc~exec_dist_transeq_3fused->proc~sendrecv_3fields proc~transeq_3fused_dist m_cuda_kernels_dist::transeq_3fused_dist proc~exec_dist_transeq_3fused->proc~transeq_3fused_dist proc~transeq_3fused_subs m_cuda_kernels_dist::transeq_3fused_subs proc~exec_dist_transeq_3fused->proc~transeq_3fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_fields~2->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields~2->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields~2->mpi_waitall proc~get_n_phi->none~get_n proc~sendrecv_3fields->mpi_irecv proc~sendrecv_3fields->mpi_isend proc~sendrecv_3fields->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_species_cuda.html"},{"title":"transeq_cuda_dist – x3d2","text":"public  subroutine transeq_cuda_dist(self, du, dv, dw, u, v, w, nu, dirps, blocks, threads) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads Calls proc~~transeq_cuda_dist~~CallsGraph proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist none~get_n m_mesh::mesh_t%get_n proc~transeq_cuda_dist->none~get_n proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~transeq_cuda_dist->proc~copy_into_buffers~2 proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~transeq_cuda_dist->proc~exec_dist_transeq_3fused proc~get_block m_allocator::allocator_t%get_block proc~transeq_cuda_dist->proc~get_block proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~transeq_cuda_dist->proc~get_n_groups proc~release_block m_allocator::allocator_t%release_block proc~transeq_cuda_dist->proc~release_block proc~resolve_field_t m_cuda_backend::resolve_field_t proc~transeq_cuda_dist->proc~resolve_field_t proc~sendrecv_3fields m_cuda_sendrecv::sendrecv_3fields proc~transeq_cuda_dist->proc~sendrecv_3fields proc~set_data_loc m_field::field_t%set_data_loc proc~transeq_cuda_dist->proc~set_data_loc proc~get_n_dir m_mesh::mesh_t%get_n_dir none~get_n->proc~get_n_dir proc~get_n_phi m_mesh::mesh_t%get_n_phi none~get_n->proc~get_n_phi dim3 dim3 proc~copy_into_buffers~2->dim3 proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2->proc~buffer_copy proc~exec_dist_transeq_3fused->proc~sendrecv_3fields proc~transeq_3fused_dist m_cuda_kernels_dist::transeq_3fused_dist proc~exec_dist_transeq_3fused->proc~transeq_3fused_dist proc~transeq_3fused_subs m_cuda_kernels_dist::transeq_3fused_subs proc~exec_dist_transeq_3fused->proc~transeq_3fused_subs proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape mpi_irecv mpi_irecv proc~sendrecv_3fields->mpi_irecv mpi_isend mpi_isend proc~sendrecv_3fields->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_3fields->mpi_waitall proc~get_n_phi->none~get_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transeq_cuda_dist~~CalledByGraph proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_cuda_dist.html"},{"title":"transeq_cuda_thom – x3d2","text":"public  subroutine transeq_cuda_thom(self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps","tags":"","url":"proc/transeq_cuda_thom.html"},{"title":"tds_solve_cuda – x3d2","text":"public  subroutine tds_solve_cuda(self, du, u, tdsops) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops Calls proc~~tds_solve_cuda~~CallsGraph proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda dim3 dim3 proc~tds_solve_cuda->dim3 proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~tds_solve_cuda->proc~get_n_groups proc~move_data_loc m_common::move_data_loc proc~tds_solve_cuda->proc~move_data_loc proc~set_data_loc m_field::field_t%set_data_loc proc~tds_solve_cuda->proc~set_data_loc proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_cuda->proc~tds_solve_dist~2 proc~tds_solve_dist~2->proc~get_n_groups proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~tds_solve_dist~2->proc~copy_into_buffers~2 proc~exec_dist_tds_compact m_cuda_exec_dist::exec_dist_tds_compact proc~tds_solve_dist~2->proc~exec_dist_tds_compact proc~resolve_field_t m_cuda_backend::resolve_field_t proc~tds_solve_dist~2->proc~resolve_field_t proc~sendrecv_fields~2 m_cuda_sendrecv::sendrecv_fields proc~tds_solve_dist~2->proc~sendrecv_fields~2 proc~copy_into_buffers~2->dim3 proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2->proc~buffer_copy proc~exec_dist_tds_compact->proc~sendrecv_fields~2 proc~der_univ_dist~2 m_cuda_kernels_dist::der_univ_dist proc~exec_dist_tds_compact->proc~der_univ_dist~2 proc~der_univ_subs~2 m_cuda_kernels_dist::der_univ_subs proc~exec_dist_tds_compact->proc~der_univ_subs~2 mpi_irecv mpi_irecv proc~sendrecv_fields~2->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields~2->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields~2->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/tds_solve_cuda.html"},{"title":"tds_solve_dist – x3d2","text":"public  subroutine tds_solve_dist(self, du, u, tdsops, blocks, threads) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads Calls proc~~tds_solve_dist~2~~CallsGraph proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~tds_solve_dist~2->proc~copy_into_buffers~2 proc~exec_dist_tds_compact m_cuda_exec_dist::exec_dist_tds_compact proc~tds_solve_dist~2->proc~exec_dist_tds_compact proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~tds_solve_dist~2->proc~get_n_groups proc~resolve_field_t m_cuda_backend::resolve_field_t proc~tds_solve_dist~2->proc~resolve_field_t proc~sendrecv_fields~2 m_cuda_sendrecv::sendrecv_fields proc~tds_solve_dist~2->proc~sendrecv_fields~2 dim3 dim3 proc~copy_into_buffers~2->dim3 proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2->proc~buffer_copy proc~exec_dist_tds_compact->proc~sendrecv_fields~2 proc~der_univ_dist~2 m_cuda_kernels_dist::der_univ_dist proc~exec_dist_tds_compact->proc~der_univ_dist~2 proc~der_univ_subs~2 m_cuda_kernels_dist::der_univ_subs proc~exec_dist_tds_compact->proc~der_univ_subs~2 mpi_irecv mpi_irecv proc~sendrecv_fields~2->mpi_irecv mpi_isend mpi_isend proc~sendrecv_fields~2->mpi_isend mpi_waitall mpi_waitall proc~sendrecv_fields~2->mpi_waitall Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tds_solve_dist~2~~CalledByGraph proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~tds_solve_dist~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/tds_solve_dist~2.html"},{"title":"reorder_cuda – x3d2","text":"public  subroutine reorder_cuda(self, u_o, u_i, direction) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction Calls proc~~reorder_cuda~~CallsGraph proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda dim3 dim3 proc~reorder_cuda->dim3 proc~get_block m_allocator::allocator_t%get_block proc~reorder_cuda->proc~get_block proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~reorder_cuda->proc~get_padded_dims proc~release_block m_allocator::allocator_t%release_block proc~reorder_cuda->proc~release_block proc~reorder_c2x m_cuda_kernels_reorder::reorder_c2x proc~reorder_cuda->proc~reorder_c2x proc~reorder_x2c m_cuda_kernels_reorder::reorder_x2c proc~reorder_cuda->proc~reorder_x2c proc~reorder_x2y m_cuda_kernels_reorder::reorder_x2y proc~reorder_cuda->proc~reorder_x2y proc~reorder_x2z m_cuda_kernels_reorder::reorder_x2z proc~reorder_cuda->proc~reorder_x2z proc~reorder_y2x m_cuda_kernels_reorder::reorder_y2x proc~reorder_cuda->proc~reorder_y2x proc~reorder_y2z m_cuda_kernels_reorder::reorder_y2z proc~reorder_cuda->proc~reorder_y2z proc~reorder_z2x m_cuda_kernels_reorder::reorder_z2x proc~reorder_cuda->proc~reorder_z2x proc~reorder_z2y m_cuda_kernels_reorder::reorder_z2y proc~reorder_cuda->proc~reorder_z2y proc~resolve_field_t m_cuda_backend::resolve_field_t proc~reorder_cuda->proc~resolve_field_t proc~set_data_loc m_field::field_t%set_data_loc proc~reorder_cuda->proc~set_data_loc proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape syncthreads syncthreads proc~reorder_c2x->syncthreads proc~reorder_x2c->syncthreads proc~reorder_x2y->syncthreads proc~reorder_y2x->syncthreads proc~reorder_y2z->syncthreads proc~reorder_z2y->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/reorder_cuda.html"},{"title":"sum_yintox_cuda – x3d2","text":"public  subroutine sum_yintox_cuda(self, u, u_y) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y Calls proc~~sum_yintox_cuda~~CallsGraph proc~sum_yintox_cuda m_cuda_backend::cuda_backend_t%sum_yintox_cuda dim3 dim3 proc~sum_yintox_cuda->dim3 proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~sum_yintox_cuda->proc~get_padded_dims proc~resolve_field_t m_cuda_backend::resolve_field_t proc~sum_yintox_cuda->proc~resolve_field_t proc~sum_yintox m_cuda_kernels_reorder::sum_yintox proc~sum_yintox_cuda->proc~sum_yintox syncthreads syncthreads proc~sum_yintox->syncthreads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sum_yintox_cuda.html"},{"title":"sum_zintox_cuda – x3d2","text":"public  subroutine sum_zintox_cuda(self, u, u_z) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z Calls proc~~sum_zintox_cuda~~CallsGraph proc~sum_zintox_cuda m_cuda_backend::cuda_backend_t%sum_zintox_cuda dim3 dim3 proc~sum_zintox_cuda->dim3 proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~sum_zintox_cuda->proc~get_padded_dims proc~resolve_field_t m_cuda_backend::resolve_field_t proc~sum_zintox_cuda->proc~resolve_field_t proc~sum_zintox m_cuda_kernels_reorder::sum_zintox proc~sum_zintox_cuda->proc~sum_zintox Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/sum_zintox_cuda.html"},{"title":"veccopy_cuda – x3d2","text":"public  subroutine veccopy_cuda(self, dst, src) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src Calls proc~~veccopy_cuda~~CallsGraph proc~veccopy_cuda m_cuda_backend::cuda_backend_t%veccopy_cuda copy copy proc~veccopy_cuda->copy dim3 dim3 proc~veccopy_cuda->dim3 proc~resolve_field_t m_cuda_backend::resolve_field_t proc~veccopy_cuda->proc~resolve_field_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/veccopy_cuda.html"},{"title":"vecadd_cuda – x3d2","text":"public  subroutine vecadd_cuda(self, a, x, b, y) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y Calls proc~~vecadd_cuda~~CallsGraph proc~vecadd_cuda m_cuda_backend::cuda_backend_t%vecadd_cuda dim3 dim3 proc~vecadd_cuda->dim3 proc~axpby m_cuda_kernels_fieldops::axpby proc~vecadd_cuda->proc~axpby proc~resolve_field_t m_cuda_backend::resolve_field_t proc~vecadd_cuda->proc~resolve_field_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/vecadd_cuda.html"},{"title":"vecmult_cuda – x3d2","text":"public  subroutine vecmult_cuda(self, y, x) m_base_backend Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x Calls proc~~vecmult_cuda~~CallsGraph proc~vecmult_cuda m_cuda_backend::cuda_backend_t%vecmult_cuda dim3 dim3 proc~vecmult_cuda->dim3 proc~pwmul m_cuda_kernels_fieldops::pwmul proc~vecmult_cuda->proc~pwmul proc~resolve_field_t m_cuda_backend::resolve_field_t proc~vecmult_cuda->proc~resolve_field_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/vecmult_cuda.html"},{"title":"copy_into_buffers – x3d2","text":"public  subroutine copy_into_buffers(u_send_s_dev, u_send_e_dev, u_dev, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_s_dev real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_e_dev real(kind=dp), intent(in), device, dimension(:, :, :) :: u_dev integer, intent(in) :: n Calls proc~~copy_into_buffers~2~~CallsGraph proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers dim3 dim3 proc~copy_into_buffers~2->dim3 proc~buffer_copy m_cuda_kernels_fieldops::buffer_copy proc~copy_into_buffers~2->proc~buffer_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_into_buffers~2~~CalledByGraph proc~copy_into_buffers~2 m_cuda_backend::copy_into_buffers proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_dist~2->proc~copy_into_buffers~2 proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~copy_into_buffers~2 proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~copy_into_buffers~2 proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~tds_solve_dist~2 proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/copy_into_buffers~2.html"},{"title":"field_max_mean_cuda – x3d2","text":"public  subroutine field_max_mean_cuda(self, max_val, mean_val, f, enforced_data_loc) m_base_backend Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc Calls proc~~field_max_mean_cuda~~CallsGraph proc~field_max_mean_cuda m_cuda_backend::cuda_backend_t%field_max_mean_cuda dim3 dim3 proc~field_max_mean_cuda->dim3 mpi_allreduce mpi_allreduce proc~field_max_mean_cuda->mpi_allreduce proc~field_max_sum m_cuda_kernels_fieldops::field_max_sum proc~field_max_mean_cuda->proc~field_max_sum proc~get_dims m_mesh::mesh_t%get_dims proc~field_max_mean_cuda->proc~get_dims proc~get_global_dims m_mesh::mesh_t%get_global_dims proc~field_max_mean_cuda->proc~get_global_dims proc~get_padded_dims m_allocator::allocator_t%get_padded_dims proc~field_max_mean_cuda->proc~get_padded_dims proc~resolve_field_t m_cuda_backend::resolve_field_t proc~field_max_mean_cuda->proc~resolve_field_t atomicadd atomicadd proc~field_max_sum->atomicadd atomicmax atomicmax proc~field_max_sum->atomicmax proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc proc~get_global_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_max_mean_cuda.html"},{"title":"field_scale_cuda – x3d2","text":"public  subroutine field_scale_cuda(self, f, a) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a Calls proc~~field_scale_cuda~~CallsGraph proc~field_scale_cuda m_cuda_backend::cuda_backend_t%field_scale_cuda dim3 dim3 proc~field_scale_cuda->dim3 proc~field_scale m_cuda_kernels_fieldops::field_scale proc~field_scale_cuda->proc~field_scale proc~resolve_field_t m_cuda_backend::resolve_field_t proc~field_scale_cuda->proc~resolve_field_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_scale_cuda.html"},{"title":"field_shift_cuda – x3d2","text":"public  subroutine field_shift_cuda(self, f, a) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a Calls proc~~field_shift_cuda~~CallsGraph proc~field_shift_cuda m_cuda_backend::cuda_backend_t%field_shift_cuda dim3 dim3 proc~field_shift_cuda->dim3 proc~field_shift m_cuda_kernels_fieldops::field_shift proc~field_shift_cuda->proc~field_shift proc~resolve_field_t m_cuda_backend::resolve_field_t proc~field_shift_cuda->proc~resolve_field_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_shift_cuda.html"},{"title":"field_set_face_cuda – x3d2","text":"public  subroutine field_set_face_cuda(self, f, c_start, c_end, face) m_base_backend Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face Calls proc~~field_set_face_cuda~~CallsGraph proc~field_set_face_cuda m_cuda_backend::cuda_backend_t%field_set_face_cuda dim3 dim3 proc~field_set_face_cuda->dim3 proc~field_set_y_face m_cuda_kernels_fieldops::field_set_y_face proc~field_set_face_cuda->proc~field_set_y_face proc~get_dims m_mesh::mesh_t%get_dims proc~field_set_face_cuda->proc~get_dims proc~resolve_field_t m_cuda_backend::resolve_field_t proc~field_set_face_cuda->proc~resolve_field_t proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/field_set_face_cuda.html"},{"title":"copy_data_to_f_cuda – x3d2","text":"public  subroutine copy_data_to_f_cuda(self, f, data) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(inout), dimension(:, :, :) :: data","tags":"","url":"proc/copy_data_to_f_cuda.html"},{"title":"copy_f_to_data_cuda – x3d2","text":"public  subroutine copy_f_to_data_cuda(self, data, f) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f","tags":"","url":"proc/copy_f_to_data_cuda.html"},{"title":"init_cuda_poisson_fft – x3d2","text":"public  subroutine init_cuda_poisson_fft(self, mesh, xdirps, ydirps, zdirps, lowmem) Type Bound cuda_backend_t Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem","tags":"","url":"proc/init_cuda_poisson_fft.html"},{"title":"resolve_field_t – x3d2","text":"public  subroutine resolve_field_t(u_dev, u) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, pointer, dimension(:, :, :) :: u_dev class( field_t ), intent(in) :: u Called by proc~~resolve_field_t~~CalledByGraph proc~resolve_field_t m_cuda_backend::resolve_field_t proc~field_max_mean_cuda m_cuda_backend::cuda_backend_t%field_max_mean_cuda proc~field_max_mean_cuda->proc~resolve_field_t proc~field_scale_cuda m_cuda_backend::cuda_backend_t%field_scale_cuda proc~field_scale_cuda->proc~resolve_field_t proc~field_set_face_cuda m_cuda_backend::cuda_backend_t%field_set_face_cuda proc~field_set_face_cuda->proc~resolve_field_t proc~field_shift_cuda m_cuda_backend::cuda_backend_t%field_shift_cuda proc~field_shift_cuda->proc~resolve_field_t proc~field_volume_integral_cuda m_cuda_backend::cuda_backend_t%field_volume_integral_cuda proc~field_volume_integral_cuda->proc~resolve_field_t proc~reorder_cuda m_cuda_backend::cuda_backend_t%reorder_cuda proc~reorder_cuda->proc~resolve_field_t proc~scalar_product_cuda m_cuda_backend::cuda_backend_t%scalar_product_cuda proc~scalar_product_cuda->proc~resolve_field_t proc~sum_yintox_cuda m_cuda_backend::cuda_backend_t%sum_yintox_cuda proc~sum_yintox_cuda->proc~resolve_field_t proc~sum_zintox_cuda m_cuda_backend::cuda_backend_t%sum_zintox_cuda proc~sum_zintox_cuda->proc~resolve_field_t proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_dist~2->proc~resolve_field_t proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~resolve_field_t proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~resolve_field_t proc~vecadd_cuda m_cuda_backend::cuda_backend_t%vecadd_cuda proc~vecadd_cuda->proc~resolve_field_t proc~veccopy_cuda m_cuda_backend::cuda_backend_t%veccopy_cuda proc~veccopy_cuda->proc~resolve_field_t proc~vecmult_cuda m_cuda_backend::cuda_backend_t%vecmult_cuda proc~vecmult_cuda->proc~resolve_field_t proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~tds_solve_dist~2 proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/resolve_field_t.html"},{"title":"cuda_backend_t – x3d2","text":"public interface cuda_backend_t Calls interface~~cuda_backend_t~~CallsGraph interface~cuda_backend_t m_cuda_backend::cuda_backend_t proc~init~9 m_cuda_backend::init interface~cuda_backend_t->proc~init~9 dim3 dim3 proc~init~9->dim3 proc~base_init~2 m_base_backend::base_backend_t%base_init proc~init~9->proc~base_init~2 proc~get_n_groups m_allocator::allocator_t%get_n_groups proc~init~9->proc~get_n_groups Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t )","tags":"","url":"interface/cuda_backend_t.html"},{"title":"tdsops_init – x3d2","text":"public  function tdsops_init(n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n_tds', 'delta', 'operation', 'scheme', 'bc_start', and 'bc_end' are\nnecessary arguments. The remaining arguments are optional. 'stretch' is for obtaining the correct derivations in a stretched mesh\n'stretch_correct' is for correcting the second derivative with the first 'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are BC_HALO. 'sym' is relevant when the BC is free-slip. If sym is .true. then it\nmeans the field we operate on is assumed to be an even function\n(symmetric, cos type) accross the boundary. If it is .false. it means\nthe field is assumed to be an odd function (anti-symmetric, sin type). 'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds Tridiagonal system size real(kind=dp), intent(in) :: delta Grid spacing character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start Boundary Cond. integer, intent(in) :: bc_end Boundary Cond. real(kind=dp), intent(in), optional :: stretch (:) Stretching coefficients real(kind=dp), intent(in), optional :: stretch_correct (:) Stretch correction integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Calls proc~~tdsops_init~~CallsGraph proc~tdsops_init m_tdsops::tdsops_init proc~deriv_1st m_tdsops::tdsops_t%deriv_1st proc~tdsops_init->proc~deriv_1st proc~deriv_2nd m_tdsops::tdsops_t%deriv_2nd proc~tdsops_init->proc~deriv_2nd proc~interpl_mid m_tdsops::tdsops_t%interpl_mid proc~tdsops_init->proc~interpl_mid proc~stagder_1st m_tdsops::tdsops_t%stagder_1st proc~tdsops_init->proc~stagder_1st proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~deriv_1st->proc~preprocess_dist proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~deriv_1st->proc~preprocess_thom proc~deriv_2nd->proc~preprocess_dist proc~deriv_2nd->proc~preprocess_thom proc~interpl_mid->proc~preprocess_dist proc~interpl_mid->proc~preprocess_thom proc~stagder_1st->proc~preprocess_dist proc~stagder_1st->proc~preprocess_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tdsops_init~~CalledByGraph proc~tdsops_init m_tdsops::tdsops_init interface~tdsops_t m_tdsops::tdsops_t interface~tdsops_t->proc~tdsops_init proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init proc~cuda_tdsops_init->proc~tdsops_init interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t interface~cuda_tdsops_t->proc~cuda_tdsops_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/tdsops_init.html"},{"title":"deriv_1st – x3d2","text":"public  subroutine deriv_1st(self, delta, scheme, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym Calls proc~~deriv_1st~~CallsGraph proc~deriv_1st m_tdsops::tdsops_t%deriv_1st proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~deriv_1st->proc~preprocess_dist proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~deriv_1st->proc~preprocess_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~deriv_1st~~CalledByGraph proc~deriv_1st m_tdsops::tdsops_t%deriv_1st proc~tdsops_init m_tdsops::tdsops_init proc~tdsops_init->proc~deriv_1st interface~tdsops_t m_tdsops::tdsops_t interface~tdsops_t->proc~tdsops_init proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init proc~cuda_tdsops_init->proc~tdsops_init interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t interface~cuda_tdsops_t->proc~cuda_tdsops_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/deriv_1st.html"},{"title":"deriv_2nd – x3d2","text":"public  subroutine deriv_2nd(self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Calls proc~~deriv_2nd~~CallsGraph proc~deriv_2nd m_tdsops::tdsops_t%deriv_2nd proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~deriv_2nd->proc~preprocess_dist proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~deriv_2nd->proc~preprocess_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~deriv_2nd~~CalledByGraph proc~deriv_2nd m_tdsops::tdsops_t%deriv_2nd proc~tdsops_init m_tdsops::tdsops_init proc~tdsops_init->proc~deriv_2nd interface~tdsops_t m_tdsops::tdsops_t interface~tdsops_t->proc~tdsops_init proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init proc~cuda_tdsops_init->proc~tdsops_init interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t interface~cuda_tdsops_t->proc~cuda_tdsops_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/deriv_2nd.html"},{"title":"interpl_mid – x3d2","text":"public  subroutine interpl_mid(self, scheme, from_to, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym Calls proc~~interpl_mid~~CallsGraph proc~interpl_mid m_tdsops::tdsops_t%interpl_mid proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~interpl_mid->proc~preprocess_dist proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~interpl_mid->proc~preprocess_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~interpl_mid~~CalledByGraph proc~interpl_mid m_tdsops::tdsops_t%interpl_mid proc~tdsops_init m_tdsops::tdsops_init proc~tdsops_init->proc~interpl_mid interface~tdsops_t m_tdsops::tdsops_t interface~tdsops_t->proc~tdsops_init proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init proc~cuda_tdsops_init->proc~tdsops_init interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t interface~cuda_tdsops_t->proc~cuda_tdsops_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/interpl_mid.html"},{"title":"stagder_1st – x3d2","text":"public  subroutine stagder_1st(self, delta, scheme, from_to, bc_start, bc_end, sym) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym Calls proc~~stagder_1st~~CallsGraph proc~stagder_1st m_tdsops::tdsops_t%stagder_1st proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~stagder_1st->proc~preprocess_dist proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~stagder_1st->proc~preprocess_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stagder_1st~~CalledByGraph proc~stagder_1st m_tdsops::tdsops_t%stagder_1st proc~tdsops_init m_tdsops::tdsops_init proc~tdsops_init->proc~stagder_1st interface~tdsops_t m_tdsops::tdsops_t interface~tdsops_t->proc~tdsops_init proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init proc~cuda_tdsops_init->proc~tdsops_init interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t interface~cuda_tdsops_t->proc~cuda_tdsops_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/stagder_1st.html"},{"title":"preprocess_dist – x3d2","text":"public  subroutine preprocess_dist(self, dist_b) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b Called by proc~~preprocess_dist~~CalledByGraph proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~deriv_1st m_tdsops::tdsops_t%deriv_1st proc~deriv_1st->proc~preprocess_dist proc~deriv_2nd m_tdsops::tdsops_t%deriv_2nd proc~deriv_2nd->proc~preprocess_dist proc~interpl_mid m_tdsops::tdsops_t%interpl_mid proc~interpl_mid->proc~preprocess_dist proc~stagder_1st m_tdsops::tdsops_t%stagder_1st proc~stagder_1st->proc~preprocess_dist proc~tdsops_init m_tdsops::tdsops_init proc~tdsops_init->proc~deriv_1st proc~tdsops_init->proc~deriv_2nd proc~tdsops_init->proc~interpl_mid proc~tdsops_init->proc~stagder_1st interface~tdsops_t m_tdsops::tdsops_t interface~tdsops_t->proc~tdsops_init proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init proc~cuda_tdsops_init->proc~tdsops_init interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t interface~cuda_tdsops_t->proc~cuda_tdsops_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/preprocess_dist.html"},{"title":"preprocess_thom – x3d2","text":"public  subroutine preprocess_thom(self, b) Type Bound tdsops_t Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: b Called by proc~~preprocess_thom~~CalledByGraph proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~deriv_1st m_tdsops::tdsops_t%deriv_1st proc~deriv_1st->proc~preprocess_thom proc~deriv_2nd m_tdsops::tdsops_t%deriv_2nd proc~deriv_2nd->proc~preprocess_thom proc~interpl_mid m_tdsops::tdsops_t%interpl_mid proc~interpl_mid->proc~preprocess_thom proc~stagder_1st m_tdsops::tdsops_t%stagder_1st proc~stagder_1st->proc~preprocess_thom proc~tdsops_init m_tdsops::tdsops_init proc~tdsops_init->proc~deriv_1st proc~tdsops_init->proc~deriv_2nd proc~tdsops_init->proc~interpl_mid proc~tdsops_init->proc~stagder_1st interface~tdsops_t m_tdsops::tdsops_t interface~tdsops_t->proc~tdsops_init proc~cuda_tdsops_init m_cuda_tdsops::cuda_tdsops_init proc~cuda_tdsops_init->proc~tdsops_init interface~cuda_tdsops_t m_cuda_tdsops::cuda_tdsops_t interface~cuda_tdsops_t->proc~cuda_tdsops_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/preprocess_thom.html"},{"title":"tdsops_t – x3d2","text":"public interface tdsops_t Calls interface~~tdsops_t~~CallsGraph interface~tdsops_t m_tdsops::tdsops_t proc~tdsops_init m_tdsops::tdsops_init interface~tdsops_t->proc~tdsops_init proc~deriv_1st m_tdsops::tdsops_t%deriv_1st proc~tdsops_init->proc~deriv_1st proc~deriv_2nd m_tdsops::tdsops_t%deriv_2nd proc~tdsops_init->proc~deriv_2nd proc~interpl_mid m_tdsops::tdsops_t%interpl_mid proc~tdsops_init->proc~interpl_mid proc~stagder_1st m_tdsops::tdsops_t%stagder_1st proc~tdsops_init->proc~stagder_1st proc~preprocess_dist m_tdsops::tdsops_t%preprocess_dist proc~deriv_1st->proc~preprocess_dist proc~preprocess_thom m_tdsops::tdsops_t%preprocess_thom proc~deriv_1st->proc~preprocess_thom proc~deriv_2nd->proc~preprocess_dist proc~deriv_2nd->proc~preprocess_thom proc~interpl_mid->proc~preprocess_dist proc~interpl_mid->proc~preprocess_thom proc~stagder_1st->proc~preprocess_dist proc~stagder_1st->proc~preprocess_thom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds Tridiagonal system size real(kind=dp), intent(in) :: delta Grid spacing character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start Boundary Cond. integer, intent(in) :: bc_end Boundary Cond. real(kind=dp), intent(in), optional :: stretch (:) Stretching coefficients real(kind=dp), intent(in), optional :: stretch_correct (:) Stretch correction integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function","tags":"","url":"interface/tdsops_t.html"},{"title":"init – x3d2","text":"public  function init(backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in) :: nvars Return Value type( time_intg_t ) Calls proc~~init~10~~CallsGraph proc~init~10 m_time_integrator::init proc~get_block m_allocator::allocator_t%get_block proc~init~10->proc~get_block proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init~10~~CalledByGraph proc~init~10 m_time_integrator::init interface~time_intg_t m_time_integrator::time_intg_t interface~time_intg_t->proc~init~10 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/init~10.html"},{"title":"finalize – x3d2","text":"public  subroutine finalize(self) Type Bound time_intg_t Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self Calls proc~~finalize~~CallsGraph proc~finalize m_time_integrator::time_intg_t%finalize proc~release_block m_allocator::allocator_t%release_block proc~finalize->proc~release_block Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/finalize.html"},{"title":"rotate – x3d2","text":"public  subroutine rotate(sol, n) Arguments Type Intent Optional Attributes Name type( flist_t ), intent(inout) :: sol (:) integer, intent(in) :: n","tags":"","url":"proc/rotate.html"},{"title":"time_intg_t – x3d2","text":"public interface time_intg_t Calls interface~~time_intg_t~~CallsGraph interface~time_intg_t m_time_integrator::time_intg_t proc~init~10 m_time_integrator::init interface~time_intg_t->proc~init~10 proc~get_block m_allocator::allocator_t%get_block proc~init~10->proc~get_block proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function init (backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in) :: nvars Return Value type( time_intg_t )","tags":"","url":"interface/time_intg_t.html"},{"title":"get_index_ijk – x3d2","text":"public pure subroutine get_index_ijk(i, j, k, dir_i, dir_j, dir_k, dir, SZ, nx_padded, ny_padded, nz_padded) Get cartesian index from application storage directional one Arguments Type Intent Optional Attributes Name integer, intent(out) :: i integer, intent(out) :: j integer, intent(out) :: k integer, intent(in) :: dir_i integer, intent(in) :: dir_j integer, intent(in) :: dir_k integer, intent(in) :: dir integer, intent(in) :: SZ integer, intent(in) :: nx_padded integer, intent(in) :: ny_padded integer, intent(in) :: nz_padded Called by proc~~get_index_ijk~~CalledByGraph proc~get_index_ijk m_ordering::get_index_ijk proc~get_index_reordering m_ordering::get_index_reordering proc~get_index_reordering->proc~get_index_ijk proc~reorder_omp m_omp_backend::omp_backend_t%reorder_omp proc~reorder_omp->proc~get_index_reordering proc~sum_intox_omp m_omp_backend::sum_intox_omp proc~sum_intox_omp->proc~get_index_reordering proc~sum_yintox_omp m_omp_backend::omp_backend_t%sum_yintox_omp proc~sum_yintox_omp->proc~sum_intox_omp proc~sum_zintox_omp m_omp_backend::omp_backend_t%sum_zintox_omp proc~sum_zintox_omp->proc~sum_intox_omp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_index_ijk.html"},{"title":"get_index_dir – x3d2","text":"public pure subroutine get_index_dir(dir_i, dir_j, dir_k, i, j, k, dir, SZ, nx_padded, ny_padded, nz_padded) Get application storage directional index from cartesian index Arguments Type Intent Optional Attributes Name integer, intent(out) :: dir_i integer, intent(out) :: dir_j integer, intent(out) :: dir_k integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: dir integer, intent(in) :: SZ integer, intent(in) :: nx_padded integer, intent(in) :: ny_padded integer, intent(in) :: nz_padded Called by proc~~get_index_dir~~CalledByGraph proc~get_index_dir m_ordering::get_index_dir proc~get_index_reordering m_ordering::get_index_reordering proc~get_index_reordering->proc~get_index_dir proc~reorder_omp m_omp_backend::omp_backend_t%reorder_omp proc~reorder_omp->proc~get_index_reordering proc~sum_intox_omp m_omp_backend::sum_intox_omp proc~sum_intox_omp->proc~get_index_reordering proc~sum_yintox_omp m_omp_backend::omp_backend_t%sum_yintox_omp proc~sum_yintox_omp->proc~sum_intox_omp proc~sum_zintox_omp m_omp_backend::omp_backend_t%sum_zintox_omp proc~sum_zintox_omp->proc~sum_intox_omp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_index_dir.html"},{"title":"get_index_reordering – x3d2","text":"public pure subroutine get_index_reordering(out_i, out_j, out_k, in_i, in_j, in_k, dir_from, dir_to, sz, cart_padded) Converts indices in between any two DIR_? Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: dir_from integer, intent(in) :: dir_to integer, intent(in) :: sz integer, intent(in) :: cart_padded (3) Calls proc~~get_index_reordering~~CallsGraph proc~get_index_reordering m_ordering::get_index_reordering proc~get_index_dir m_ordering::get_index_dir proc~get_index_reordering->proc~get_index_dir proc~get_index_ijk m_ordering::get_index_ijk proc~get_index_reordering->proc~get_index_ijk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_index_reordering~~CalledByGraph proc~get_index_reordering m_ordering::get_index_reordering proc~reorder_omp m_omp_backend::omp_backend_t%reorder_omp proc~reorder_omp->proc~get_index_reordering proc~sum_intox_omp m_omp_backend::sum_intox_omp proc~sum_intox_omp->proc~get_index_reordering proc~sum_yintox_omp m_omp_backend::omp_backend_t%sum_yintox_omp proc~sum_yintox_omp->proc~sum_intox_omp proc~sum_zintox_omp m_omp_backend::omp_backend_t%sum_zintox_omp proc~sum_zintox_omp->proc~sum_intox_omp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_index_reordering.html"},{"title":"memcpy3D – x3d2","text":"public  subroutine memcpy3D(dst, src, nx, ny, nz) Copy data between x3d2 padded arrays and cuFFTMp descriptors Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: dst real(kind=dp), intent(in), device, dimension(:, :, :) :: src integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz Called by proc~~memcpy3d~~CalledByGraph proc~memcpy3d m_cuda_spectral::memcpy3D proc~fft_backward_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_backward_cuda proc~fft_backward_cuda->proc~memcpy3d proc~fft_forward_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_forward_cuda proc~fft_forward_cuda->proc~memcpy3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/memcpy3d.html"},{"title":"memcpy3D_with_transpose – x3d2","text":"public  subroutine memcpy3D_with_transpose(dst, src, nx, ny, nz) Copy with transpose: src(nx, ny, nz) -> dst(ny, nx, nz)\nUsed for 100 case forward FFT Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: dst real(kind=dp), intent(in), device, dimension(:, :, :) :: src integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz Called by proc~~memcpy3d_with_transpose~~CalledByGraph proc~memcpy3d_with_transpose m_cuda_spectral::memcpy3D_with_transpose proc~fft_forward_100_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_forward_100_cuda proc~fft_forward_100_cuda->proc~memcpy3d_with_transpose Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/memcpy3d_with_transpose.html"},{"title":"memcpy3D_with_transpose_back – x3d2","text":"public  subroutine memcpy3D_with_transpose_back(dst, src, nx, ny, nz) Copy with transpose back: src(ny, nx, nz) -> dst(nx, ny, nz)\nUsed for 100 case backward FFT Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: dst real(kind=dp), intent(in), device, dimension(:, :, :) :: src integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz Called by proc~~memcpy3d_with_transpose_back~~CalledByGraph proc~memcpy3d_with_transpose_back m_cuda_spectral::memcpy3D_with_transpose_back proc~fft_backward_100_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_backward_100_cuda proc~fft_backward_100_cuda->proc~memcpy3d_with_transpose_back Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/memcpy3d_with_transpose_back.html"},{"title":"process_spectral_000 – x3d2","text":"public  subroutine process_spectral_000(div_u, waves, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz Called by proc~~process_spectral_000~2~~CalledByGraph proc~process_spectral_000~2 m_cuda_spectral::process_spectral_000 proc~fft_postprocess_000_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_000_cuda proc~fft_postprocess_000_cuda->proc~process_spectral_000~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/process_spectral_000~2.html"},{"title":"process_spectral_010 – x3d2","text":"public  subroutine process_spectral_010(div_u, waves, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz Called by proc~~process_spectral_010~2~~CalledByGraph proc~process_spectral_010~2 m_cuda_spectral::process_spectral_010 proc~fft_postprocess_010_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_010_cuda proc~fft_postprocess_010_cuda->proc~process_spectral_010~2 proc~fft_postprocess_100_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_100_cuda proc~fft_postprocess_100_cuda->proc~process_spectral_010~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/process_spectral_010~2.html"},{"title":"process_spectral_010_fw – x3d2","text":"public  subroutine process_spectral_010_fw(div_u, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: bx Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: ay Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: by Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: az Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: bz Spectral equivalence constants Called by proc~~process_spectral_010_fw~~CalledByGraph proc~process_spectral_010_fw m_cuda_spectral::process_spectral_010_fw proc~fft_postprocess_010_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_010_cuda proc~fft_postprocess_010_cuda->proc~process_spectral_010_fw proc~fft_postprocess_110_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_110_cuda proc~fft_postprocess_110_cuda->proc~process_spectral_010_fw Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/process_spectral_010_fw.html"},{"title":"process_spectral_010_poisson – x3d2","text":"public  subroutine process_spectral_010_poisson(div_u, a_re, a_im, off, inc, nx_spec, n, nx, ny, nz) Solve the Poisson equation at cell centres with non-perioic BC along y Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space real(kind=dp), intent(inout), device, dimension(:, :, :, :) :: a_re Spectral equivalence constants real(kind=dp), intent(inout), device, dimension(:, :, :, :) :: a_im Spectral equivalence constants integer, intent(in), value :: off offset and increment. increment is 2 when considering only odd or even integer, intent(in), value :: inc offset and increment. increment is 2 when considering only odd or even integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: n Grid size in spectral space integer, intent(in), value :: nx Grid size in spectral space integer, intent(in), value :: ny Grid size in spectral space integer, intent(in), value :: nz Grid size in spectral space Called by proc~~process_spectral_010_poisson~~CalledByGraph proc~process_spectral_010_poisson m_cuda_spectral::process_spectral_010_poisson proc~fft_postprocess_010_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_010_cuda proc~fft_postprocess_010_cuda->proc~process_spectral_010_poisson proc~fft_postprocess_110_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_110_cuda proc~fft_postprocess_110_cuda->proc~process_spectral_010_poisson Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/process_spectral_010_poisson.html"},{"title":"process_spectral_010_bw – x3d2","text":"public  subroutine process_spectral_010_bw(div_u, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Ref. JCP 228 (2009), 5989–6015, Sec 4 Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: bx Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: ay Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: by Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: az Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: bz Spectral equivalence constants Called by proc~~process_spectral_010_bw~~CalledByGraph proc~process_spectral_010_bw m_cuda_spectral::process_spectral_010_bw proc~fft_postprocess_010_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_010_cuda proc~fft_postprocess_010_cuda->proc~process_spectral_010_bw proc~fft_postprocess_110_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_110_cuda proc~fft_postprocess_110_cuda->proc~process_spectral_010_bw Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/process_spectral_010_bw.html"},{"title":"process_spectral_110 – x3d2","text":"public  subroutine process_spectral_110(div_u, waves, nx_spec, ny_spec, x_sp_st, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes for Dirichlet BC in X and Y, periodic in Z Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves integer, intent(in), value :: nx_spec integer, intent(in), value :: ny_spec integer, intent(in), value :: x_sp_st integer, intent(in), value :: y_sp_st integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz Called by proc~~process_spectral_110~~CalledByGraph proc~process_spectral_110 m_cuda_spectral::process_spectral_110 proc~fft_postprocess_110_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%fft_postprocess_110_cuda proc~fft_postprocess_110_cuda->proc~process_spectral_110 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/process_spectral_110.html"},{"title":"enforce_periodicity_x – x3d2","text":"public  subroutine enforce_periodicity_x(f_out, f_in, nx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_out real(kind=dp), intent(in), device, dimension(:, :, :) :: f_in integer, intent(in), value :: nx Called by proc~~enforce_periodicity_x~~CalledByGraph proc~enforce_periodicity_x m_cuda_spectral::enforce_periodicity_x proc~enforce_periodicity_x_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%enforce_periodicity_x_cuda proc~enforce_periodicity_x_cuda->proc~enforce_periodicity_x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/enforce_periodicity_x.html"},{"title":"undo_periodicity_x – x3d2","text":"public  subroutine undo_periodicity_x(f_out, f_in, nx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_out real(kind=dp), intent(in), device, dimension(:, :, :) :: f_in integer, intent(in), value :: nx Called by proc~~undo_periodicity_x~~CalledByGraph proc~undo_periodicity_x m_cuda_spectral::undo_periodicity_x proc~undo_periodicity_x_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%undo_periodicity_x_cuda proc~undo_periodicity_x_cuda->proc~undo_periodicity_x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/undo_periodicity_x.html"},{"title":"enforce_periodicity_y – x3d2","text":"public  subroutine enforce_periodicity_y(f_out, f_in, ny) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_out real(kind=dp), intent(in), device, dimension(:, :, :) :: f_in integer, intent(in), value :: ny Called by proc~~enforce_periodicity_y~~CalledByGraph proc~enforce_periodicity_y m_cuda_spectral::enforce_periodicity_y proc~enforce_periodicity_y_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%enforce_periodicity_y_cuda proc~enforce_periodicity_y_cuda->proc~enforce_periodicity_y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/enforce_periodicity_y.html"},{"title":"undo_periodicity_y – x3d2","text":"public  subroutine undo_periodicity_y(f_out, f_in, ny) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_out real(kind=dp), intent(in), device, dimension(:, :, :) :: f_in integer, intent(in), value :: ny Called by proc~~undo_periodicity_y~~CalledByGraph proc~undo_periodicity_y m_cuda_spectral::undo_periodicity_y proc~undo_periodicity_y_cuda m_cuda_poisson_fft::cuda_poisson_fft_t%undo_periodicity_y_cuda proc~undo_periodicity_y_cuda->proc~undo_periodicity_y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/undo_periodicity_y.html"},{"title":"der_univ_dist – x3d2","text":"public  subroutine der_univ_dist(du, send_u_s, send_u_e, u, u_s, u_e, n_tds, n_rhs, coeffs_s, coeffs_e, coeffs, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e integer, intent(in), value :: n_tds integer, intent(in), value :: n_rhs real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs real(kind=dp), intent(in), device, dimension(:) :: ffr real(kind=dp), intent(in), device, dimension(:) :: fbc real(kind=dp), intent(in), device, dimension(:) :: faf Called by proc~~der_univ_dist~2~~CalledByGraph proc~der_univ_dist~2 m_cuda_kernels_dist::der_univ_dist proc~exec_dist_tds_compact m_cuda_exec_dist::exec_dist_tds_compact proc~exec_dist_tds_compact->proc~der_univ_dist~2 proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_dist~2->proc~exec_dist_tds_compact proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~tds_solve_dist~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_dist~2.html"},{"title":"der_univ_subs – x3d2","text":"public  subroutine der_univ_subs(du, recv_u_s, recv_u_e, n, dist_sa, dist_sc, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_e integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: dist_sa real(kind=dp), intent(in), device, dimension(:) :: dist_sc real(kind=dp), intent(in), device, dimension(:) :: strch Called by proc~~der_univ_subs~2~~CalledByGraph proc~der_univ_subs~2 m_cuda_kernels_dist::der_univ_subs proc~exec_dist_tds_compact m_cuda_exec_dist::exec_dist_tds_compact proc~exec_dist_tds_compact->proc~der_univ_subs~2 proc~tds_solve_dist~2 m_cuda_backend::cuda_backend_t%tds_solve_dist proc~tds_solve_dist~2->proc~exec_dist_tds_compact proc~tds_solve_cuda m_cuda_backend::cuda_backend_t%tds_solve_cuda proc~tds_solve_cuda->proc~tds_solve_dist~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/der_univ_subs~2.html"},{"title":"transeq_3fused_dist – x3d2","text":"public  subroutine transeq_3fused_dist(du, dud, d2u, send_du_s, send_du_e, send_dud_s, send_dud_e, send_d2u_s, send_d2u_e, u, u_s, u_e, v, v_s, v_e, n_tds, n_rhs, du_coeffs_s, du_coeffs_e, du_coeffs, du_fw, du_bw, du_af, dud_coeffs_s, dud_coeffs_e, dud_coeffs, dud_fw, dud_bw, dud_af, d2u_coeffs_s, d2u_coeffs_e, d2u_coeffs, d2u_fw, d2u_bw, d2u_af) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_e integer, intent(in), value :: n_tds integer, intent(in), value :: n_rhs real(kind=dp), intent(in), device :: du_coeffs_s (:,:) real(kind=dp), intent(in), device :: du_coeffs_e (:,:) real(kind=dp), intent(in), device :: du_coeffs (:) real(kind=dp), intent(in), device :: du_fw (:) real(kind=dp), intent(in), device :: du_bw (:) real(kind=dp), intent(in), device :: du_af (:) real(kind=dp), intent(in), device :: dud_coeffs_s (:,:) real(kind=dp), intent(in), device :: dud_coeffs_e (:,:) real(kind=dp), intent(in), device :: dud_coeffs (:) real(kind=dp), intent(in), device :: dud_fw (:) real(kind=dp), intent(in), device :: dud_bw (:) real(kind=dp), intent(in), device :: dud_af (:) real(kind=dp), intent(in), device :: d2u_coeffs_s (:,:) real(kind=dp), intent(in), device :: d2u_coeffs_e (:,:) real(kind=dp), intent(in), device :: d2u_coeffs (:) real(kind=dp), intent(in), device :: d2u_fw (:) real(kind=dp), intent(in), device :: d2u_bw (:) real(kind=dp), intent(in), device :: d2u_af (:) Called by proc~~transeq_3fused_dist~~CalledByGraph proc~transeq_3fused_dist m_cuda_kernels_dist::transeq_3fused_dist proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~exec_dist_transeq_3fused->proc~transeq_3fused_dist proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~exec_dist_transeq_3fused proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~exec_dist_transeq_3fused proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_3fused_dist.html"},{"title":"transeq_3fused_subs – x3d2","text":"public  subroutine transeq_3fused_subs(r_du, conv, dud, d2u, recv_du_s, recv_du_e, recv_dud_s, recv_dud_e, recv_d2u_s, recv_d2u_e, n, nu, du_sa, du_sc, du_strch, dud_sa, dud_sc, dud_strch, d2u_sa, d2u_sc, d2u_strch, d2u_strch_cor) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: r_du The result array, it stores 'du' first then its overwritten real(kind=dp), intent(in), device, dimension(:, :, :) :: conv real(kind=dp), intent(in), device, dimension(:, :, :) :: dud real(kind=dp), intent(in), device, dimension(:, :, :) :: d2u real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_e integer, intent(in), value :: n real(kind=dp), intent(in), value :: nu real(kind=dp), intent(in), device, dimension(:) :: du_sa real(kind=dp), intent(in), device, dimension(:) :: du_sc real(kind=dp), intent(in), device, dimension(:) :: du_strch real(kind=dp), intent(in), device, dimension(:) :: dud_sa real(kind=dp), intent(in), device, dimension(:) :: dud_sc real(kind=dp), intent(in), device, dimension(:) :: dud_strch real(kind=dp), intent(in), device, dimension(:) :: d2u_sa real(kind=dp), intent(in), device, dimension(:) :: d2u_sc real(kind=dp), intent(in), device, dimension(:) :: d2u_strch real(kind=dp), intent(in), device, dimension(:) :: d2u_strch_cor Called by proc~~transeq_3fused_subs~~CalledByGraph proc~transeq_3fused_subs m_cuda_kernels_dist::transeq_3fused_subs proc~exec_dist_transeq_3fused m_cuda_exec_dist::exec_dist_transeq_3fused proc~exec_dist_transeq_3fused->proc~transeq_3fused_subs proc~transeq_cuda_dist m_cuda_backend::cuda_backend_t%transeq_cuda_dist proc~transeq_cuda_dist->proc~exec_dist_transeq_3fused proc~transeq_species_cuda m_cuda_backend::cuda_backend_t%transeq_species_cuda proc~transeq_species_cuda->proc~exec_dist_transeq_3fused proc~transeq_x_cuda m_cuda_backend::cuda_backend_t%transeq_x_cuda proc~transeq_x_cuda->proc~transeq_cuda_dist proc~transeq_y_cuda m_cuda_backend::cuda_backend_t%transeq_y_cuda proc~transeq_y_cuda->proc~transeq_cuda_dist proc~transeq_z_cuda m_cuda_backend::cuda_backend_t%transeq_z_cuda proc~transeq_z_cuda->proc~transeq_cuda_dist Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/transeq_3fused_subs.html"},{"title":"m_cuda_exec_thom – x3d2","text":"Uses m_common cudafor m_cuda_kernels_thom m_cuda_tdsops module~~m_cuda_exec_thom~~UsesGraph module~m_cuda_exec_thom m_cuda_exec_thom cudafor cudafor module~m_cuda_exec_thom->cudafor module~m_common m_common module~m_cuda_exec_thom->module~m_common module~m_cuda_kernels_thom m_cuda_kernels_thom module~m_cuda_exec_thom->module~m_cuda_kernels_thom module~m_cuda_tdsops m_cuda_tdsops module~m_cuda_exec_thom->module~m_cuda_tdsops mpi mpi module~m_common->mpi module~m_cuda_kernels_thom->cudafor module~m_cuda_kernels_thom->module~m_common module~m_cuda_tdsops->module~m_common iso_fortran_env iso_fortran_env module~m_cuda_tdsops->iso_fortran_env module~m_tdsops m_tdsops module~m_cuda_tdsops->module~m_tdsops module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine exec_thom_tds_compact (du, u, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u type( cuda_tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","url":"module/m_cuda_exec_thom.html"},{"title":"m_io_manager – x3d2","text":"snapshot operations. Its purpose is to simplify the main simulation loop by providing\na single point of contact for all I/O-related actions. The mainprogram only\nneeds to interact with the io_manager_t type, which then delegates tasks\nto the specialised checkpoint and snapshot managers. Uses m_solver m_checkpoint_manager m_snapshot_manager module~~m_io_manager~~UsesGraph module~m_io_manager m_io_manager module~m_checkpoint_manager m_checkpoint_manager module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_solver m_solver module~m_io_manager->module~m_solver module~m_checkpoint_manager->module~m_solver module~m_common m_common module~m_checkpoint_manager->module~m_common module~m_config m_config module~m_checkpoint_manager->module~m_config module~m_field m_field module~m_checkpoint_manager->module~m_field module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session m_io_session module~m_checkpoint_manager->module~m_io_session mpi mpi module~m_checkpoint_manager->mpi module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_common module~m_snapshot_manager->module~m_config module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_io_field_utils module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->mpi iso_fortran_env iso_fortran_env module~m_solver->iso_fortran_env module~m_allocator m_allocator module~m_solver->module~m_allocator module~m_base_backend m_base_backend module~m_solver->module~m_base_backend module~m_solver->module~m_common module~m_solver->module~m_config module~m_solver->module~m_field module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_mesh m_mesh module~m_solver->module~m_mesh module~m_tdsops m_tdsops module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_solver->mpi module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_base_backend->module~m_tdsops module~m_base_backend->mpi module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_common->mpi module~m_config->iso_fortran_env module~m_config->module~m_common module~m_field->module~m_common module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->module~m_io_session module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_io_field_utils->module~m_solver module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_base m_io_base module~m_io_field_utils->module~m_io_base module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_session->module~m_io_base module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_tdsops module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_io_manager~~UsedByGraph module~m_io_manager m_io_manager module~m_base_case m_base_case module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_base_case program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: io_manager_t Components Type Visibility Attributes Name Initial type( checkpoint_manager_t ), public :: checkpoint_mgr type( snapshot_manager_t ), public :: snapshot_mgr Type-Bound Procedures procedure, public :: init => io_init procedure, public :: handle_restart => io_handle_restart procedure, public :: handle_io_step => io_handle_step procedure, public :: finalise => io_finalise procedure, public :: is_restart => io_is_restart","tags":"","url":"module/m_io_manager.html"},{"title":"m_config – x3d2","text":"Contains all the namelist configurations used in x3d2 Uses iso_fortran_env m_common module~~m_config~~UsesGraph module~m_config m_config iso_fortran_env iso_fortran_env module~m_config->iso_fortran_env module~m_common m_common module~m_config->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_config~~UsedByGraph module~m_config m_config module~m_case_channel m_case_channel module~m_case_channel->module~m_config module~m_solver m_solver module~m_case_channel->module~m_solver module~m_base_case m_base_case module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_config module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_config module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_snapshot_manager m_snapshot_manager module~m_snapshot_manager->module~m_config module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils module~m_solver->module~m_config program~xcompact xcompact program~xcompact->module~m_config program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_base_case module~m_case_generic m_case_generic program~xcompact->module~m_case_generic module~m_case_tgv m_case_tgv program~xcompact->module~m_case_tgv module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_io_manager->module~m_snapshot_manager module~m_io_manager->module~m_solver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: n_species_max = 99 Abstract Interfaces abstract interface public  subroutine read(self, nml_file, nml_string) Assigns the member variables either from a file or text source. nml_file can be an absolute or relative path\nnml_string is a character string that contains the namelist.\nFor example, nml_string=\"&foobar_nml foo=0, bar='this'/\" Arguments Type Intent Optional Attributes Name class( base_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string Derived Types type, public, abstract :: base_config_t All config types have a method read to initialise their data Type-Bound Procedures procedure( read ), public, deferred :: read type, public, extends( base_config_t ) :: domain_config_t Components Type Visibility Attributes Name Initial character(len=30), public :: flow_case_name real(kind=dp), public :: L_global (3) integer, public :: dims_global (3) integer, public :: nproc_dir (3) character(len=20), public :: BC_x (2) character(len=20), public :: BC_y (2) character(len=20), public :: BC_z (2) character(len=20), public :: stretching (3) real(kind=dp), public :: beta (3) Type-Bound Procedures procedure, public :: read => read_domain_nml type, public, extends( base_config_t ) :: solver_config_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: Re real(kind=dp), public :: dt logical, public :: ibm_on real(kind=dp), public, dimension(:), allocatable :: pr_species integer, public :: n_iters integer, public :: n_output integer, public :: n_species logical, public :: lowmem_transeq logical, public :: lowmem_fft character(len=3), public :: poisson_solver_type character(len=3), public :: time_intg character(len=30), public :: der1st_scheme character(len=30), public :: der2nd_scheme character(len=30), public :: interpl_scheme character(len=30), public :: stagder_scheme Type-Bound Procedures procedure, public :: read => read_solver_nml type, public, extends( base_config_t ) :: channel_config_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: noise real(kind=dp), public :: omega_rot logical, public :: rotation integer, public :: n_rotate Type-Bound Procedures procedure, public :: read => read_channel_nml type, public, extends( base_config_t ) :: cylinder_config_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: init_noise (3) Type-Bound Procedures procedure, public :: read => read_cylinder_nml type, public, extends( base_config_t ) :: checkpoint_config_t Components Type Visibility Attributes Name Initial integer, public :: checkpoint_freq = 0 Frequency of checkpointing (0 = off) integer, public :: snapshot_freq = 0 Frequency of snapshots (0 = off) logical, public :: keep_checkpoint = .true. If false, only keep latest checkpoint character(len=256), public :: checkpoint_prefix = \"checkpoint\" character(len=256), public :: snapshot_prefix = \"snapshot\" logical, public :: restart_from_checkpoint = .false. character(len=256), public :: restart_file = \"\" integer, public, dimension(3) :: output_stride = [2, 2, 2] Spatial stride for snapshot output logical, public :: snapshot_sp = .false. if true, snapshot in single precision Type-Bound Procedures procedure, public :: read => read_checkpoint_nml Subroutines public  subroutine read_domain_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( domain_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string public  subroutine read_solver_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( solver_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string public  subroutine read_channel_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( channel_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string public  subroutine read_cylinder_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( cylinder_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string public  subroutine read_checkpoint_nml (self, nml_file, nml_string) Arguments Type Intent Optional Attributes Name class( checkpoint_config_t ) :: self character(len=*), intent(in), optional :: nml_file character(len=*), intent(in), optional :: nml_string","tags":"","url":"module/m_config.html"},{"title":"m_case_generic – x3d2","text":"An example case set up to run and sustain a freestream flow.\nThis is a good place to start for adding a new flow case. Uses m_base_case m_field m_solver iso_fortran_env m_mesh m_allocator m_base_backend m_common module~~m_case_generic~~UsesGraph module~m_case_generic m_case_generic iso_fortran_env iso_fortran_env module~m_case_generic->iso_fortran_env module~m_allocator m_allocator module~m_case_generic->module~m_allocator module~m_base_backend m_base_backend module~m_case_generic->module~m_base_backend module~m_base_case m_base_case module~m_case_generic->module~m_base_case module~m_common m_common module~m_case_generic->module~m_common module~m_field m_field module~m_case_generic->module~m_field module~m_mesh m_mesh module~m_case_generic->module~m_mesh module~m_solver m_solver module~m_case_generic->module~m_solver module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops mpi mpi module~m_base_backend->mpi module~m_base_case->module~m_allocator module~m_base_case->module~m_base_backend module~m_base_case->module~m_common module~m_base_case->module~m_field module~m_base_case->module~m_mesh module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_base_case->mpi module~m_common->mpi module~m_field->module~m_common module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_mesh->mpi module~m_solver->iso_fortran_env module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_common module~m_solver->module~m_field module~m_solver->module~m_mesh module~m_config m_config module~m_solver->module~m_config module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_solver->mpi module~m_config->iso_fortran_env module~m_config->module~m_common module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_io_session m_io_session module~m_ibm->module~m_io_session module~m_io_manager->module~m_solver module~m_checkpoint_manager m_checkpoint_manager module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_tdsops module~m_checkpoint_manager->module~m_common module~m_checkpoint_manager->module~m_field module~m_checkpoint_manager->module~m_solver module~m_checkpoint_manager->module~m_config module~m_checkpoint_manager->mpi module~m_checkpoint_manager->module~m_io_session module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_base m_io_base module~m_io_session->module~m_io_base module~m_snapshot_manager->module~m_common module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_config module~m_snapshot_manager->mpi module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->module~m_io_field_utils module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_solver module~m_io_field_utils->module~m_io_base Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_case_generic~~UsedByGraph module~m_case_generic m_case_generic program~xcompact xcompact program~xcompact->module~m_case_generic Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface case_generic_t public  function case_generic_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_generic_t ) Derived Types type, public, extends( base_case_t ) :: case_generic_t Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr Constructor public\n\n                    \n                    function case_generic_init (backend, mesh, host_allocator) Type-Bound Procedures procedure, public :: case_init procedure, public :: case_finalise procedure, public :: set_init procedure, public :: run procedure, public :: print_enstrophy procedure, public :: print_div_max_mean procedure, public :: boundary_conditions => boundary_conditions_generic procedure, public :: initial_conditions => initial_conditions_generic procedure, public :: forcings => forcings_generic procedure, public :: pre_correction => pre_correction_generic procedure, public :: postprocess => postprocess_generic Functions public  function case_generic_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_generic_t ) Subroutines public  subroutine boundary_conditions_generic (self) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self public  subroutine initial_conditions_generic (self) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self public  subroutine forcings_generic (self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter public  subroutine pre_correction_generic (self, u, v, w) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w public  subroutine postprocess_generic (self, iter, t) Arguments Type Intent Optional Attributes Name class( case_generic_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t","tags":"","url":"module/m_case_generic.html"},{"title":"m_io_session – x3d2","text":"operations It abstracts away all backend details and provides a type-safe interface\nfor all I/O tasks. Key features:\n- Type-safe sessions: specialised reader_session_t and writer_session_t types for reading and writing operations, respectively.\n- Automatic backend selection: based on compile-time options\n- Resource cleanup: memory is automatically freed when sessions\n  go out of scope (using final subroutines).\n- Simplified workflow - user only needs to manage a simple open -> read/write -> close workflow, with no need for manual file handle\n  management or explicit cleanup calls. @example\nA typical usage pattern for reading data and writing data: @code{.f90}\nuse m_io_session, only: writer_session_t, reader_session_t implicit none real, dimension(:,:,:), allocatable :: temp_field\ntype(writer_session_t)           :: writer\ntype(reader_session_t)           :: reader ! For writing data\ncall writer%open(\"output.bp\")\ncall writer%write_data(\"temperature\", temp_field)\ncall writer%close()\n! Note: writer is automatically cleaned up when it goes out of scope ! For reading data\ncall reader%open(\"input.bp\")\ncall reader%read_data(\"temperature\", temp_field)\ncall reader%close()\n! Note: reader is automatically cleaned up when it goes out of scope\n@endcode Note Users should only use the types provided by this module. The lower-level\nmodules like m_io_base and m_io_backend are internal components and should\nnever be used directly in user code.\nPublic session types for user interaction Uses m_common m_io_backend m_io_base module~~m_io_session~~UsesGraph module~m_io_session m_io_session module~m_common m_common module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_base m_io_base module~m_io_session->module~m_io_base mpi mpi module~m_common->mpi module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base iso_fortran_env iso_fortran_env module~m_io_backend~2->iso_fortran_env module~m_io_base->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_io_session~~UsedByGraph module~m_io_session m_io_session module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_io_session module~m_solver m_solver module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_ibm m_ibm module~m_ibm->module~m_io_session module~m_snapshot_manager m_snapshot_manager module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils module~m_io_manager m_io_manager module~m_io_manager->module~m_checkpoint_manager module~m_io_manager->module~m_snapshot_manager module~m_io_manager->module~m_solver module~m_solver->module~m_ibm module~m_base_case m_base_case module~m_base_case->module~m_io_manager module~m_base_case->module~m_solver module~m_case_channel m_case_channel module~m_case_channel->module~m_solver module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case module~m_io_field_utils->module~m_solver program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends(../../../io_session_base_t) :: reader_session_t PRIMARY TYPE FOR READING DATA - Use this for all file reading operations\nThis is the only interface users should use for reading data.\nProvides type-safe reading operations with automatic backend selection. Read more… Finalizations Procedures final :: reader_session_finaliser Type-Bound Procedures procedure, public :: is_session_open procedure, public :: is_session_functional procedure, public :: close => session_base_close procedure, public :: open => reader_session_open generic, public :: read_data => read_data_i8, read_data_integer, read_data_real, read_data_array_3d type, public, extends(../../../io_session_base_t) :: writer_session_t PRIMARY TYPE FOR WRITING DATA - Use this for all file writing operations\nThis is the only interface users should use for writing data.\nProvides type-safe writing operations with automatic backend selection. Read more… Finalizations Procedures final :: writer_session_finaliser Type-Bound Procedures procedure, public :: is_session_open procedure, public :: is_session_functional procedure, public :: close => session_base_close procedure, public :: open => writer_session_open procedure, public :: begin_step => writer_session_begin_step procedure, public :: end_step => writer_session_end_step generic, public :: write_data => write_data_i8, write_data_integer, write_data_real, write_data_array_3d procedure, public :: write_attribute => session_write_attribute","tags":"","url":"module/m_io_session.html"},{"title":"m_omp_spectral – x3d2","text":"Uses m_common module~~m_omp_spectral~~UsesGraph module~m_omp_spectral m_omp_spectral module~m_common m_common module~m_omp_spectral->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_omp_spectral~~UsedByGraph module~m_omp_spectral m_omp_spectral module~m_omp_poisson_fft m_omp_poisson_fft module~m_omp_poisson_fft->module~m_omp_spectral proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine process_spectral_000 (div_u, waves, nx_spec, ny_spec, nz_spec, x_sp_st, y_sp_st, z_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-process div U* in spectral space for all periodic BCs. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in) :: nx_spec Grid size in spectral space integer, intent(in) :: ny_spec Grid size in spectral space integer, intent(in) :: nz_spec Grid size in spectral space integer, intent(in) :: x_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: y_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: z_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: nx Global cell size integer, intent(in) :: ny Global cell size integer, intent(in) :: nz Global cell size real(kind=dp), intent(in), dimension(:) :: ax real(kind=dp), intent(in), dimension(:) :: bx real(kind=dp), intent(in), dimension(:) :: ay real(kind=dp), intent(in), dimension(:) :: by real(kind=dp), intent(in), dimension(:) :: az real(kind=dp), intent(in), dimension(:) :: bz public  subroutine process_spectral_010 (div_u, waves, nx_spec, ny_spec, nz_spec, x_sp_st, y_sp_st, z_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-process div U* in spectral space, for non-periodic BC in y-dir. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in) :: nx_spec Grid size in spectral space integer, intent(in) :: ny_spec Grid size in spectral space integer, intent(in) :: nz_spec Grid size in spectral space integer, intent(in) :: x_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: y_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: z_sp_st Offsets in the permuted pencils in spectral space integer, intent(in) :: nx Global cell size integer, intent(in) :: ny Global cell size integer, intent(in) :: nz Global cell size real(kind=dp), intent(in), dimension(:) :: ax real(kind=dp), intent(in), dimension(:) :: bx real(kind=dp), intent(in), dimension(:) :: ay real(kind=dp), intent(in), dimension(:) :: by real(kind=dp), intent(in), dimension(:) :: az real(kind=dp), intent(in), dimension(:) :: bz","tags":"","url":"module/m_omp_spectral.html"},{"title":"m_omp_sendrecv – x3d2","text":"Uses m_common mpi module~~m_omp_sendrecv~~UsesGraph module~m_omp_sendrecv m_omp_sendrecv module~m_common m_common module~m_omp_sendrecv->module~m_common mpi mpi module~m_omp_sendrecv->mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_omp_sendrecv~~UsedByGraph module~m_omp_sendrecv m_omp_sendrecv module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_omp_sendrecv module~m_omp_exec_dist m_omp_exec_dist module~m_omp_backend->module~m_omp_exec_dist module~m_omp_exec_dist->module~m_omp_sendrecv program~xcompact xcompact program~xcompact->module~m_omp_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine sendrecv_fields (f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","url":"module/m_omp_sendrecv.html"},{"title":"m_omp_backend – x3d2","text":"Uses m_tdsops m_omp_sendrecv m_field m_omp_common m_omp_exec_dist m_ordering m_mesh m_allocator mpi m_base_backend m_common module~~m_omp_backend~~UsesGraph module~m_omp_backend m_omp_backend module~m_allocator m_allocator module~m_omp_backend->module~m_allocator module~m_base_backend m_base_backend module~m_omp_backend->module~m_base_backend module~m_common m_common module~m_omp_backend->module~m_common module~m_field m_field module~m_omp_backend->module~m_field module~m_mesh m_mesh module~m_omp_backend->module~m_mesh module~m_omp_common m_omp_common module~m_omp_backend->module~m_omp_common module~m_omp_exec_dist m_omp_exec_dist module~m_omp_backend->module~m_omp_exec_dist module~m_omp_sendrecv m_omp_sendrecv module~m_omp_backend->module~m_omp_sendrecv module~m_ordering m_ordering module~m_omp_backend->module~m_ordering module~m_tdsops m_tdsops module~m_omp_backend->module~m_tdsops mpi mpi module~m_omp_backend->mpi module~m_allocator->module~m_common module~m_allocator->module~m_field iso_fortran_env iso_fortran_env module~m_allocator->iso_fortran_env module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_base_backend->module~m_tdsops module~m_base_backend->mpi module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_common->mpi module~m_field->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_omp_exec_dist->module~m_common module~m_omp_exec_dist->module~m_omp_common module~m_omp_exec_dist->module~m_omp_sendrecv module~m_omp_exec_dist->module~m_tdsops module~m_omp_exec_dist->mpi module~m_omp_kernels_dist m_omp_kernels_dist module~m_omp_exec_dist->module~m_omp_kernels_dist module~m_omp_sendrecv->module~m_common module~m_omp_sendrecv->mpi module~m_ordering->module~m_common module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_mesh_content->module~m_common module~m_omp_kernels_dist->module~m_common module~m_omp_kernels_dist->module~m_omp_common omp_lib omp_lib module~m_omp_kernels_dist->omp_lib module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_omp_backend~~UsedByGraph module~m_omp_backend m_omp_backend program~xcompact xcompact program~xcompact->module~m_omp_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface omp_backend_t public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) Derived Types type, public, extends( base_backend_t ) :: omp_backend_t Components Type Visibility Attributes Name Initial integer, public :: n_halo = 4 DistD2 implementation is hardcoded for 4 halo layers for all backends type( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: v_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: w_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: du_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: dud_recv_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_send_e real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_s real(kind=dp), public, allocatable, dimension(:, :, :) :: d2u_recv_e Constructor public\n\n                    \n                    function init (mesh, allocator) Type-Bound Procedures procedure, public :: base_init procedure, public :: get_field_data procedure, public :: set_field_data procedure, public :: alloc_tdsops => alloc_omp_tdsops procedure, public :: transeq_x => transeq_x_omp procedure, public :: transeq_y => transeq_y_omp procedure, public :: transeq_z => transeq_z_omp procedure, public :: transeq_species => transeq_species_omp procedure, public :: tds_solve => tds_solve_omp procedure, public :: reorder => reorder_omp procedure, public :: sum_yintox => sum_yintox_omp procedure, public :: sum_zintox => sum_zintox_omp procedure, public :: veccopy => veccopy_omp procedure, public :: vecadd => vecadd_omp procedure, public :: vecmult => vecmult_omp procedure, public :: scalar_product => scalar_product_omp procedure, public :: field_max_mean => field_max_mean_omp procedure, public :: field_scale => field_scale_omp procedure, public :: field_shift => field_shift_omp procedure, public :: field_set_face => field_set_face_omp procedure, public :: field_volume_integral => field_volume_integral_omp procedure, public :: copy_data_to_f => copy_data_to_f_omp procedure, public :: copy_f_to_data => copy_f_to_data_omp procedure, public :: init_poisson_fft => init_omp_poisson_fft procedure, public :: transeq_omp_dist Functions public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( omp_backend_t ) public  function scalar_product_omp (self, x, y) result(s) m_base_backend Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) public  function field_volume_integral_omp (self, f) result(s) volume integral of a field Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) Subroutines public  subroutine alloc_omp_tdsops (self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine transeq_x_omp (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps public  subroutine transeq_y_omp (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps public  subroutine transeq_z_omp (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps public  subroutine transeq_species_omp (self, dspec, uvw, spec, nu, dirps, sync) Compute the convection and diffusion for the given field\nin the given direction.\nHalo exchange for the given field is necessary\nWhen sync is true, halo exchange of momentum is necessary Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync public  subroutine transeq_omp_dist (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps public  subroutine tds_solve_omp (self, du, u, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops public  subroutine tds_solve_dist (self, du, u, tdsops) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops public  subroutine reorder_omp (self, u_, u, direction) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction public  subroutine sum_yintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ public  subroutine sum_zintox_omp (self, u, u_) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ public  subroutine sum_intox_omp (self, u, u_, dir_to) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ integer, intent(in) :: dir_to public  subroutine veccopy_omp (self, dst, src) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src public  subroutine vecadd_omp (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y public  subroutine vecmult_omp (self, y, x) m_base_backend Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x public  subroutine copy_into_buffers (u_send_s, u_send_e, u, n, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), dimension(:, :, :) :: u integer, intent(in) :: n integer, intent(in) :: n_groups public  subroutine field_max_mean_omp (self, max_val, mean_val, f, enforced_data_loc) m_base_backend Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc public  subroutine field_scale_omp (self, f, a) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a public  subroutine field_shift_omp (self, f, a) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a public  subroutine field_set_face_omp (self, f, c_start, c_end, face) m_base_backend Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face public  subroutine copy_data_to_f_omp (self, f, data) Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data public  subroutine copy_f_to_data_omp (self, data, f) Arguments Type Intent Optional Attributes Name class( omp_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f public  subroutine init_omp_poisson_fft (self, mesh, xdirps, ydirps, zdirps, lowmem) Arguments Type Intent Optional Attributes Name class( omp_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem","tags":"","url":"module/m_omp_backend.html"},{"title":"m_io_backend – x3d2","text":"is not available interface. It is used when no real I/O backend (e.g. ADIOS2) is enabled at\ncompile time. The primary purpose of this dummy backend is to allow the full program to\ncompile and link against the session interface ( m_io_session ) without\nrequiring a functional I/O library. Warning This is a non-functional stub. Calling any of its I/O procedures\nwill immediately terminate the program with an error message. Note If you require file I/O, you must recompile the code with a functional\nbackend Uses iso_fortran_env m_io_base m_common module~~m_io_backend~2~~UsesGraph module~m_io_backend~2 m_io_backend iso_fortran_env iso_fortran_env module~m_io_backend~2->iso_fortran_env module~m_common m_common module~m_io_backend~2->module~m_common module~m_io_base m_io_base module~m_io_backend~2->module~m_io_base mpi mpi module~m_common->mpi module~m_io_base->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_io_backend~2~~UsedByGraph module~m_io_backend~2 m_io_backend module~m_io_session m_io_session module~m_io_session->module~m_io_backend~2 module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_io_session module~m_solver m_solver module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_ibm m_ibm module~m_ibm->module~m_io_session module~m_snapshot_manager m_snapshot_manager module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils module~m_io_manager m_io_manager module~m_io_manager->module~m_checkpoint_manager module~m_io_manager->module~m_snapshot_manager module~m_io_manager->module~m_solver module~m_solver->module~m_ibm module~m_base_case m_base_case module~m_base_case->module~m_io_manager module~m_base_case->module~m_solver module~m_case_channel m_case_channel module~m_case_channel->module~m_solver module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case module~m_io_field_utils->module~m_solver program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: IO_BACKEND_DUMMY = 0 integer, public, parameter :: IO_BACKEND_ADIOS2 = 1 Functions public  function get_default_backend () result(backend) Arguments None Return Value integer Subroutines public  subroutine allocate_io_reader (reader) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(out), allocatable :: reader public  subroutine allocate_io_writer (writer) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(out), allocatable :: writer","tags":"","url":"module/m_io_backend~2.html"},{"title":"m_allocator – x3d2","text":"Uses iso_fortran_env m_field m_common module~~m_allocator~~UsesGraph module~m_allocator m_allocator iso_fortran_env iso_fortran_env module~m_allocator->iso_fortran_env module~m_common m_common module~m_allocator->module~m_common module~m_field m_field module~m_allocator->module~m_field mpi mpi module~m_common->mpi module~m_field->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_allocator~~UsedByGraph module~m_allocator m_allocator module~m_base_backend m_base_backend module~m_base_backend->module~m_allocator module~m_base_case m_base_case module~m_base_case->module~m_allocator module~m_base_case->module~m_base_backend module~m_solver m_solver module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_allocator module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_base_case module~m_case_channel->module~m_solver module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_allocator module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_base_case module~m_case_cylinder->module~m_solver module~m_case_generic m_case_generic module~m_case_generic->module~m_allocator module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_base_case module~m_case_generic->module~m_solver module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_allocator module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_base_case module~m_case_tgv->module~m_solver module~m_cuda_allocator m_cuda_allocator module~m_cuda_allocator->module~m_allocator module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_allocator module~m_cuda_backend->module~m_base_backend module~m_cuda_backend->module~m_cuda_allocator module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_ibm m_ibm module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_allocator module~m_omp_backend->module~m_base_backend module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_ibm module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend program~xcompact xcompact program~xcompact->module~m_allocator program~xcompact->module~m_base_backend program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv program~xcompact->module~m_cuda_allocator program~xcompact->module~m_cuda_backend program~xcompact->module~m_omp_backend module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_cuda_poisson_fft->module~m_cuda_allocator module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface allocator_t public  function allocator_init (dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( allocator_t ) Derived Types type, public :: allocator_t An instance of type allocator_t is responsible for the\nmaintenance of a linked list of instances of equal size m_allocator objects: Read more… Components Type Visibility Attributes Name Initial integer, public :: ngrid integer, public :: sz integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( field_t ), public, pointer :: first => null() The pointer to the first block on the list.  Non associated if\nthe list is empty Constructor public\n\n                    \n                    function allocator_init (dims, sz) Type-Bound Procedures procedure, public :: get_block procedure, public :: release_block procedure, public :: create_block procedure, public :: get_block_ids procedure, public :: destroy procedure, public :: get_padded_dims procedure, public :: get_n_groups Functions public  function allocator_init (dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( allocator_t ) public  function create_block (self, next) result(ptr) Allocate memory for a new block and return a pointer to a new m_allocator object. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer public  function get_block (self, dir, data_loc) result(handle) Return a pointer to the first available memory block, i.e. the\ncurrent head of the block list.  If the list is empty, allocate\na new block with create_block first. Read more… Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir integer, intent(in), optional :: data_loc Return Value class( field_t ), pointer public  function get_block_ids (self) Utility function that returns a array made of the id of the\nblock currently in the block list.  Return the array [0] if\nblock list is empty. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self Return Value integer, allocatable, (:) public  function get_padded_dims (self, dir) result(dims) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir Return Value integer, (3) public  function get_n_groups (self, dir) result(n_groups) Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self integer, intent(in) :: dir Return Value integer Subroutines public  subroutine release_block (self, handle) Release memory block pointed to by HANDLE to the block list.\nIt is pushed to the front of the block list, in other words it\nis made the head block. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self class( field_t ), pointer :: handle public  subroutine destroy (self) Go through the block list from head to tail, deallocating each\nmemory block in turn.  Deallocation of a m_allocator object automatically\ndeallocates its internal allocatable data array. Arguments Type Intent Optional Attributes Name class( allocator_t ), intent(inout) :: self","tags":"","url":"module/m_allocator.html"},{"title":"m_vector_calculus – x3d2","text":"Uses m_tdsops m_field iso_fortran_env m_allocator m_base_backend m_common module~~m_vector_calculus~~UsesGraph module~m_vector_calculus m_vector_calculus iso_fortran_env iso_fortran_env module~m_vector_calculus->iso_fortran_env module~m_allocator m_allocator module~m_vector_calculus->module~m_allocator module~m_base_backend m_base_backend module~m_vector_calculus->module~m_base_backend module~m_common m_common module~m_vector_calculus->module~m_common module~m_field m_field module~m_vector_calculus->module~m_field module~m_tdsops m_tdsops module~m_vector_calculus->module~m_tdsops module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_tdsops module~m_mesh m_mesh module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft mpi mpi module~m_base_backend->mpi module~m_common->mpi module~m_field->module~m_common module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_tdsops module~m_poisson_fft->module~m_mesh module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_vector_calculus~~UsedByGraph module~m_vector_calculus m_vector_calculus module~m_solver m_solver module~m_solver->module~m_vector_calculus module~m_base_case m_base_case module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_solver module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface vector_calculus_t public  function init (backend) result(vector_calculus) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend Return Value type( vector_calculus_t ) Derived Types type, public :: vector_calculus_t Defines vector calculus operators Components Type Visibility Attributes Name Initial class( base_backend_t ), public, pointer :: backend Constructor public\n\n                    \n                    function init (backend) Type-Bound Procedures procedure, public :: curl procedure, public :: divergence_v2c procedure, public :: gradient_c2v procedure, public :: laplacian Functions public  function init (backend) result(vector_calculus) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend Return Value type( vector_calculus_t ) Subroutines public  subroutine curl (self, o_i_hat, o_j_hat, o_k_hat, u, v, w, x_der1st, y_der1st, z_der1st) Curl of a vector field (u, v, w). Read more… Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w class( tdsops_t ), intent(in) :: x_der1st class( tdsops_t ), intent(in) :: y_der1st class( tdsops_t ), intent(in) :: z_der1st public  subroutine divergence_v2c (self, div_u, u, v, w, x_stagder_v2c, x_interpl_v2c, y_stagder_v2c, y_interpl_v2c, z_stagder_v2c, z_interpl_v2c) Divergence of a vector field (u, v, w). Read more… Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w class( tdsops_t ), intent(in) :: x_stagder_v2c class( tdsops_t ), intent(in) :: x_interpl_v2c class( tdsops_t ), intent(in) :: y_stagder_v2c class( tdsops_t ), intent(in) :: y_interpl_v2c class( tdsops_t ), intent(in) :: z_stagder_v2c class( tdsops_t ), intent(in) :: z_interpl_v2c public  subroutine gradient_c2v (self, dpdx, dpdy, dpdz, p, x_stagder_c2v, x_interpl_c2v, y_stagder_c2v, y_interpl_c2v, z_stagder_c2v, z_interpl_c2v) Gradient of a scalar field 'p'. Read more… Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: p class( tdsops_t ), intent(in) :: x_stagder_c2v class( tdsops_t ), intent(in) :: x_interpl_c2v class( tdsops_t ), intent(in) :: y_stagder_c2v class( tdsops_t ), intent(in) :: y_interpl_c2v class( tdsops_t ), intent(in) :: z_stagder_c2v class( tdsops_t ), intent(in) :: z_interpl_c2v public  subroutine laplacian (self, lapl_u, u, x_der2nd, y_der2nd, z_der2nd) Laplacian of a scalar field 'u'. Read more… Arguments Type Intent Optional Attributes Name class( vector_calculus_t ) :: self class( field_t ), intent(inout) :: lapl_u class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: x_der2nd class( tdsops_t ), intent(in) :: y_der2nd class( tdsops_t ), intent(in) :: z_der2nd","tags":"","url":"module/m_vector_calculus.html"},{"title":"m_io_field_utils – x3d2","text":"operations types that handle the low-level tasks required for writing field data\nIts primary functionalities include:\n- Data sub-sampling (striding) - applying a stride to data to reduce the\nsize of the output files\n- Parallel I/O calculations - determining correct global shapes,\nlocal starts, and counts for data distributed across multiple MPI ranks\n- Data management - handling the setup, cleanup, and buffering of field\ndata in preparation for asynchronous I/O operations Uses m_solver m_common m_io_base m_field module~~m_io_field_utils~~UsesGraph module~m_io_field_utils m_io_field_utils module~m_common m_common module~m_io_field_utils->module~m_common module~m_field m_field module~m_io_field_utils->module~m_field module~m_io_base m_io_base module~m_io_field_utils->module~m_io_base module~m_solver m_solver module~m_io_field_utils->module~m_solver mpi mpi module~m_common->mpi module~m_field->module~m_common module~m_io_base->module~m_common module~m_solver->module~m_common module~m_solver->module~m_field iso_fortran_env iso_fortran_env module~m_solver->iso_fortran_env module~m_allocator m_allocator module~m_solver->module~m_allocator module~m_base_backend m_base_backend module~m_solver->module~m_base_backend module~m_config m_config module~m_solver->module~m_config module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_mesh m_mesh module~m_solver->module~m_mesh module~m_tdsops m_tdsops module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_solver->mpi module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_allocator->iso_fortran_env module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_mesh module~m_base_backend->module~m_tdsops module~m_base_backend->mpi module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_config->module~m_common module~m_config->iso_fortran_env module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_io_session m_io_session module~m_ibm->module~m_io_session module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->iso_fortran_env module~m_mesh->mpi module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_tdsops module~m_io_session->module~m_common module~m_io_session->module~m_io_base module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_backend~2->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_io_field_utils~~UsedByGraph module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_io_field_utils module~m_snapshot_manager m_snapshot_manager module~m_snapshot_manager->module~m_io_field_utils module~m_io_manager m_io_manager module~m_io_manager->module~m_checkpoint_manager module~m_io_manager->module~m_snapshot_manager module~m_base_case m_base_case module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_base_case program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: field_buffer_map_t Components Type Visibility Attributes Name Initial character(len=32), public :: field_name real(kind=dp), public, dimension(:, :, :), allocatable :: buffer type, public :: field_ptr_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: ptr => null() Functions public  function stride_data (input_data, dims, stride, output_dims_out) result(output_data) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :, :) :: input_data integer, intent(in), dimension(3) :: dims integer, intent(in), dimension(3) :: stride integer, intent(out), dimension(3) :: output_dims_out Return Value real(kind=dp), dimension(:, :, :), allocatable Subroutines public  subroutine stride_data_to_buffer (input_data, dims, stride, out_buffer, output_dims_out) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :, :) :: input_data integer, intent(in), dimension(3) :: dims integer, intent(in), dimension(3) :: stride real(kind=dp), intent(inout), dimension(:, :, :), allocatable :: out_buffer integer, intent(out), dimension(3) :: output_dims_out public  subroutine get_output_dimensions (shape_dims, start_dims, count_dims, stride_factors, output_shape, output_start, output_count, output_dims_local, last_shape_dims, last_stride_factors, last_output_shape) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in), dimension(3) :: shape_dims integer(kind=i8), intent(in), dimension(3) :: start_dims integer(kind=i8), intent(in), dimension(3) :: count_dims integer, intent(in), dimension(3) :: stride_factors integer(kind=i8), intent(out), dimension(3) :: output_shape integer(kind=i8), intent(out), dimension(3) :: output_start integer(kind=i8), intent(out), dimension(3) :: output_count integer, intent(out), dimension(3) :: output_dims_local integer(kind=i8), intent(inout), optional, dimension(3) :: last_shape_dims integer, intent(inout), optional, dimension(3) :: last_stride_factors integer(kind=i8), intent(inout), optional, dimension(3) :: last_output_shape public  subroutine generate_coordinates (solver, writer, file, shape_dims, start_dims, count_dims, data_loc, coords_x, coords_y, coords_z) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: solver class( io_writer_t ), intent(inout) :: writer class( io_file_t ), intent(inout) :: file integer(kind=i8), intent(in), dimension(3) :: shape_dims integer(kind=i8), intent(in), dimension(3) :: start_dims integer(kind=i8), intent(in), dimension(3) :: count_dims integer, intent(in) :: data_loc real(kind=dp), intent(inout), dimension(:, :, :), allocatable :: coords_x real(kind=dp), intent(inout), dimension(:, :, :), allocatable :: coords_y real(kind=dp), intent(inout), dimension(:, :, :), allocatable :: coords_z public  subroutine setup_field_arrays (solver, field_names, field_ptrs, host_fields) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: solver character(len=*), intent(in), dimension(:) :: field_names type( field_ptr_t ), intent(out), allocatable :: field_ptrs (:) type( field_ptr_t ), intent(out), allocatable :: host_fields (:) public  subroutine cleanup_field_arrays (solver, field_ptrs, host_fields) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: solver type( field_ptr_t ), intent(inout), allocatable :: field_ptrs (:) type( field_ptr_t ), intent(inout), allocatable :: host_fields (:) public  subroutine prepare_field_buffers (solver, stride_factors, field_names, data_loc, field_buffers, last_shape_dims, last_stride_factors, last_output_shape) Arguments Type Intent Optional Attributes Name class( solver_t ), intent(in) :: solver integer, intent(in), dimension(3) :: stride_factors character(len=*), intent(in), dimension(:) :: field_names integer, intent(in) :: data_loc type( field_buffer_map_t ), intent(inout), allocatable :: field_buffers (:) integer(kind=i8), intent(inout), dimension(3) :: last_shape_dims integer, intent(inout), dimension(3) :: last_stride_factors integer(kind=i8), intent(inout), dimension(3) :: last_output_shape public  subroutine write_single_field_to_buffer (field_name, host_field, solver, stride_factors, data_loc, field_buffers, last_shape_dims, last_stride_factors, last_output_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: field_name class( field_t ), pointer :: host_field class( solver_t ), intent(in) :: solver integer, intent(in), dimension(3) :: stride_factors integer, intent(in) :: data_loc type( field_buffer_map_t ), intent(inout) :: field_buffers (:) integer(kind=i8), intent(inout), dimension(3) :: last_shape_dims integer, intent(inout), dimension(3) :: last_stride_factors integer(kind=i8), intent(inout), dimension(3) :: last_output_shape public  subroutine cleanup_field_buffers (field_buffers) Arguments Type Intent Optional Attributes Name type( field_buffer_map_t ), intent(inout), allocatable :: field_buffers (:)","tags":"","url":"module/m_io_field_utils.html"},{"title":"m_decomp – x3d2","text":"Parallel decomposition provided by 2decomp&FFT Uses mpi module~~m_decomp~2~~UsesGraph module~m_decomp~2 m_decomp mpi mpi module~m_decomp~2->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_decomp~2~~UsedByGraph module~m_decomp~2 m_decomp proc~mesh_init m_mesh::mesh_init proc~mesh_init->module~m_decomp~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function is_avail_2decomp () result(avail) Arguments None Return Value logical Subroutines public  subroutine decomposition_2decomp (grid, par) Performs 2D mesh decomposition using 2decomp&fft Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: grid class( par_t ), intent(inout) :: par","tags":"","url":"module/m_decomp~2.html"},{"title":"m_cuda_sendrecv – x3d2","text":"Uses m_common cudafor mpi module~~m_cuda_sendrecv~~UsesGraph module~m_cuda_sendrecv m_cuda_sendrecv cudafor cudafor module~m_cuda_sendrecv->cudafor module~m_common m_common module~m_cuda_sendrecv->module~m_common mpi mpi module~m_cuda_sendrecv->mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_sendrecv~~UsedByGraph module~m_cuda_sendrecv m_cuda_sendrecv module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_sendrecv module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend->module~m_cuda_exec_dist module~m_cuda_exec_dist->module~m_cuda_sendrecv program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine sendrecv_fields (f_recv_s, f_recv_e, f_send_s, f_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next public  subroutine sendrecv_3fields (f1_recv_s, f1_recv_e, f2_recv_s, f2_recv_e, f3_recv_s, f3_recv_e, f1_send_s, f1_send_e, f2_send_s, f2_send_e, f3_send_s, f3_send_e, n_data, nproc, prev, next) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f1_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f2_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: f3_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f1_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f2_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_s real(kind=dp), intent(in), device, dimension(:, :, :) :: f3_send_e integer, intent(in) :: n_data integer, intent(in) :: nproc integer, intent(in) :: prev integer, intent(in) :: next","tags":"","url":"module/m_cuda_sendrecv.html"},{"title":"m_cuda_kernels_fieldops – x3d2","text":"Uses m_common cudafor m_cuda_common module~~m_cuda_kernels_fieldops~~UsesGraph module~m_cuda_kernels_fieldops m_cuda_kernels_fieldops cudafor cudafor module~m_cuda_kernels_fieldops->cudafor module~m_common m_common module~m_cuda_kernels_fieldops->module~m_common module~m_cuda_common m_cuda_common module~m_cuda_kernels_fieldops->module~m_cuda_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_kernels_fieldops~~UsedByGraph module~m_cuda_kernels_fieldops m_cuda_kernels_fieldops module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_kernels_fieldops program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine copy (n, dst, src) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: n real(kind=dp), intent(out), device, dimension(:, :, :) :: dst real(kind=dp), intent(in), device, dimension(:, :, :) :: src public  subroutine axpby (n, alpha, x, beta, y) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: n real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), value :: beta real(kind=dp), intent(inout), device, dimension(:, :, :) :: y public  subroutine pwmul (y, x, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: y real(kind=dp), intent(in), device, dimension(:, :, :) :: x integer, intent(in), value :: n public  subroutine buffer_copy (u_send_s, u_send_e, u, n, n_halo) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_s real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_send_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n integer, intent(in), value :: n_halo public  subroutine field_scale (f, alpha, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: f real(kind=dp), intent(in), value :: alpha integer, intent(in), value :: n public  subroutine field_shift (f, const, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: f real(kind=dp), intent(in), value :: const integer, intent(in), value :: n public  subroutine scalar_product (s, x, y, n, n_i_pad, n_j) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: s real(kind=dp), intent(in), device, dimension(:, :, :) :: x real(kind=dp), intent(in), device, dimension(:, :, :) :: y integer, intent(in), value :: n integer, intent(in), value :: n_i_pad integer, intent(in), value :: n_j public  subroutine field_max_sum (max_f, sum_f, f, n, n_i_pad, n_j) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: max_f real(kind=dp), intent(inout), device :: sum_f real(kind=dp), intent(in), device, dimension(:, :, :) :: f integer, intent(in), value :: n integer, intent(in), value :: n_i_pad integer, intent(in), value :: n_j public  subroutine field_set_y_face (f, c_start, c_end, nx, ny, nz) Set domain Y_FACE to a constant\nc_start at the bottom and c_end at the top Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: f real(kind=dp), intent(in), value :: c_start real(kind=dp), intent(in), value :: c_end integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz public  subroutine volume_integral (s, f, n, n_i_pad, n_j) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device :: s real(kind=dp), intent(in), device, dimension(:, :, :) :: f integer, intent(in), value :: n integer, intent(in), value :: n_i_pad integer, intent(in), value :: n_j","tags":"","url":"module/m_cuda_kernels_fieldops.html"},{"title":"m_poisson_fft – x3d2","text":"Uses m_common m_mesh m_tdsops m_field module~~m_poisson_fft~~UsesGraph module~m_poisson_fft m_poisson_fft module~m_common m_common module~m_poisson_fft->module~m_common module~m_field m_field module~m_poisson_fft->module~m_field module~m_mesh m_mesh module~m_poisson_fft->module~m_mesh module~m_tdsops m_tdsops module~m_poisson_fft->module~m_tdsops mpi mpi module~m_common->mpi module~m_field->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field iso_fortran_env iso_fortran_env module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_mesh->mpi module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_poisson_fft~~UsedByGraph module~m_poisson_fft m_poisson_fft module~m_base_backend m_base_backend module~m_base_backend->module~m_poisson_fft module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_poisson_fft->module~m_poisson_fft module~m_omp_poisson_fft m_omp_poisson_fft module~m_omp_poisson_fft->module~m_poisson_fft module~m_base_case m_base_case module~m_base_case->module~m_base_backend module~m_solver m_solver module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_base_case module~m_case_channel->module~m_solver module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_base_case module~m_case_cylinder->module~m_solver module~m_case_generic m_case_generic module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_base_case module~m_case_generic->module~m_solver module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_base_case module~m_case_tgv->module~m_solver module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_base_backend module~m_cuda_backend->module~m_cuda_poisson_fft module~m_ibm m_ibm module~m_ibm->module~m_base_backend module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_base_backend module~m_solver->module~m_base_backend module~m_solver->module~m_ibm module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_base_backend proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft program~xcompact xcompact program~xcompact->module~m_base_backend program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv program~xcompact->module~m_cuda_backend program~xcompact->module~m_omp_backend module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  subroutine fft_forward(self, f_in) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in abstract interface public  subroutine fft_backward(self, f_out) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out abstract interface public  subroutine fft_postprocess(self) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self abstract interface public  subroutine poisson_xxx(self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp abstract interface public  subroutine field_process(self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in Derived Types type, public, abstract :: poisson_fft_t FFT based Poisson solver Components Type Visibility Attributes Name Initial type( mesh_t ), public, pointer :: mesh => null() integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: x_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: z_sp_st Offset in y and z directions in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants real(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ky Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: exs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: eys Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ezs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2x Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2y Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2z Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: trans_x_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_x_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_im Staggared grid transformation logical, public :: periodic_x Periodicity in x, y, and z logical, public :: periodic_y Periodicity in x, y, and z logical, public :: periodic_z Periodicity in x, y, and z logical, public :: stretched_y = .false. Periodicity in x, y, and z logical, public :: stretched_y_sym Periodicity in x, y, and z real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_im Stretching operator matrices logical, public :: lowmem = .false. lowmem option, only used in CUDA backend procedure( poisson_xxx ), public, pointer :: poisson => null() Procedure pointer to BC specific poisson solvers Type-Bound Procedures procedure( fft_forward ), public, deferred :: fft_forward_010 procedure( fft_forward ), public, deferred :: fft_forward_100 procedure( fft_forward ), public, deferred :: fft_forward_110 procedure( fft_forward ), public, deferred :: fft_forward procedure( fft_backward ), public, deferred :: fft_backward_010 procedure( fft_backward ), public, deferred :: fft_backward_100 procedure( fft_backward ), public, deferred :: fft_backward_110 procedure( fft_backward ), public, deferred :: fft_backward procedure( fft_postprocess ), public, deferred :: fft_postprocess_000 procedure( fft_postprocess ), public, deferred :: fft_postprocess_010 procedure( fft_postprocess ), public, deferred :: fft_postprocess_100 procedure( fft_postprocess ), public, deferred :: fft_postprocess_110 procedure( field_process ), public, deferred :: enforce_periodicity_x procedure( field_process ), public, deferred :: undo_periodicity_x procedure( field_process ), public, deferred :: enforce_periodicity_y procedure( field_process ), public, deferred :: undo_periodicity_y procedure, public :: base_init procedure, public :: solve_poisson procedure, public :: stretching_matrix procedure, public :: waves_set procedure, public :: get_km procedure, public :: get_km_re procedure, public :: get_km_im Functions public  function get_km_re (self, i, j, k) result(re) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) public  function get_km_im (self, i, j, k) result(re) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(kind=dp) public  function get_km (self, i, j, k) result(km) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value complex(kind=dp) public  function get_real (complx) result(re) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: complx Return Value real(kind=dp) public  function get_imag (complx) result(im) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: complx Return Value real(kind=dp) Subroutines public  subroutine base_init (self, mesh, xdirps, ydirps, zdirps, n_spec, n_sp_st) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( mesh_t ), intent(in), target :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps integer, intent(in), dimension(3) :: n_spec integer, intent(in), dimension(3) :: n_sp_st public  subroutine solve_poisson (self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp public  subroutine poisson_000 (self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp public  subroutine poisson_010 (self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp public  subroutine poisson_100 (self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp public  subroutine poisson_110 (self, f, temp) Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self class( field_t ), intent(inout) :: f class( field_t ), intent(inout) :: temp public  subroutine stretching_matrix (self, geo, xdirps, ydirps, zdirps) Stretching necessitates a special operation in spectral space.\nThe coefficients for the operation are stored in matrix form. Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps public  subroutine waves_set (self, geo, xdirps, ydirps, zdirps) Spectral equivalence constants Read more… Arguments Type Intent Optional Attributes Name class( poisson_fft_t ) :: self type( geo_t ), intent(in) :: geo type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps public  subroutine wave_numbers (a, b, k, e, k2, n, L, d, periodic, c_a, c_b, c_alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:) :: a real(kind=dp), intent(out), dimension(:) :: b complex(kind=dp), intent(out), dimension(:) :: k complex(kind=dp), intent(out), dimension(:) :: e complex(kind=dp), intent(out), dimension(:) :: k2 integer, intent(in) :: n real(kind=dp), intent(in) :: L real(kind=dp), intent(in) :: d logical, intent(in) :: periodic real(kind=dp), intent(in) :: c_a real(kind=dp), intent(in) :: c_b real(kind=dp), intent(in) :: c_alpha","tags":"","url":"module/m_poisson_fft.html"},{"title":"m_cuda_kernels_thom – x3d2","text":"Uses m_common cudafor module~~m_cuda_kernels_thom~~UsesGraph module~m_cuda_kernels_thom m_cuda_kernels_thom cudafor cudafor module~m_cuda_kernels_thom->cudafor module~m_common m_common module~m_cuda_kernels_thom->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_kernels_thom~~UsedByGraph module~m_cuda_kernels_thom m_cuda_kernels_thom module~m_cuda_exec_thom m_cuda_exec_thom module~m_cuda_exec_thom->module~m_cuda_kernels_thom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine der_univ_thom (du, u, n_tds, n_rhs, coeffs_s, coeffs_e, coeffs, thom_f, thom_s, thom_w, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n_tds integer, intent(in), value :: n_rhs real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs real(kind=dp), intent(in), device, dimension(:) :: thom_f real(kind=dp), intent(in), device, dimension(:) :: thom_s real(kind=dp), intent(in), device, dimension(:) :: thom_w real(kind=dp), intent(in), device, dimension(:) :: strch public  subroutine der_univ_thom_per (du, u, n, coeffs, alpha, thom_f, thom_s, thom_w, thom_p, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: coeffs real(kind=dp), intent(in), value :: alpha real(kind=dp), intent(in), device, dimension(:) :: thom_f real(kind=dp), intent(in), device, dimension(:) :: thom_s real(kind=dp), intent(in), device, dimension(:) :: thom_w real(kind=dp), intent(in), device, dimension(:) :: thom_p real(kind=dp), intent(in), device, dimension(:) :: strch","tags":"","url":"module/m_cuda_kernels_thom.html"},{"title":"m_common – x3d2","text":"Uses mpi module~~m_common~~UsesGraph module~m_common m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_common~~UsedByGraph module~m_common m_common module~m_allocator m_allocator module~m_allocator->module~m_common module~m_field m_field module~m_allocator->module~m_field module~m_base_backend m_base_backend module~m_base_backend->module~m_common module~m_base_backend->module~m_allocator module~m_base_backend->module~m_field module~m_mesh m_mesh module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops module~m_base_case m_base_case module~m_base_case->module~m_common module~m_base_case->module~m_allocator module~m_base_case->module~m_base_backend module~m_base_case->module~m_field module~m_base_case->module~m_mesh module~m_solver m_solver module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_common module~m_case_channel->module~m_allocator module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_base_case module~m_config m_config module~m_case_channel->module~m_config module~m_case_channel->module~m_mesh module~m_case_channel->module~m_solver module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_common module~m_case_cylinder->module~m_allocator module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_base_case module~m_case_cylinder->module~m_config module~m_case_cylinder->module~m_field module~m_case_cylinder->module~m_mesh module~m_case_cylinder->module~m_solver module~m_case_generic m_case_generic module~m_case_generic->module~m_common module~m_case_generic->module~m_allocator module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_base_case module~m_case_generic->module~m_field module~m_case_generic->module~m_mesh module~m_case_generic->module~m_solver module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_common module~m_case_tgv->module~m_allocator module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_base_case module~m_case_tgv->module~m_field module~m_case_tgv->module~m_mesh module~m_case_tgv->module~m_solver module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_common module~m_checkpoint_manager->module~m_config module~m_checkpoint_manager->module~m_field module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session m_io_session module~m_checkpoint_manager->module~m_io_session module~m_checkpoint_manager->module~m_solver module~m_config->module~m_common module~m_cuda_allocator m_cuda_allocator module~m_cuda_allocator->module~m_common module~m_cuda_allocator->module~m_allocator module~m_cuda_allocator->module~m_field module~m_cuda_allocator->module~m_mesh module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_common module~m_cuda_backend->module~m_allocator module~m_cuda_backend->module~m_base_backend module~m_cuda_backend->module~m_cuda_allocator module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend->module~m_cuda_exec_dist module~m_cuda_kernels_dist m_cuda_kernels_dist module~m_cuda_backend->module~m_cuda_kernels_dist module~m_cuda_kernels_fieldops m_cuda_kernels_fieldops module~m_cuda_backend->module~m_cuda_kernels_fieldops module~m_cuda_kernels_reorder m_cuda_kernels_reorder module~m_cuda_backend->module~m_cuda_kernels_reorder module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_cuda_sendrecv m_cuda_sendrecv module~m_cuda_backend->module~m_cuda_sendrecv module~m_cuda_tdsops m_cuda_tdsops module~m_cuda_backend->module~m_cuda_tdsops module~m_cuda_backend->module~m_field module~m_cuda_backend->module~m_mesh module~m_cuda_backend->module~m_tdsops module~m_cuda_exec_dist->module~m_common module~m_cuda_exec_dist->module~m_cuda_kernels_dist module~m_cuda_exec_dist->module~m_cuda_sendrecv module~m_cuda_exec_dist->module~m_cuda_tdsops module~m_cuda_exec_thom m_cuda_exec_thom module~m_cuda_exec_thom->module~m_common module~m_cuda_kernels_thom m_cuda_kernels_thom module~m_cuda_exec_thom->module~m_cuda_kernels_thom module~m_cuda_exec_thom->module~m_cuda_tdsops module~m_cuda_kernels_dist->module~m_common module~m_cuda_kernels_fieldops->module~m_common module~m_cuda_kernels_reorder->module~m_common module~m_cuda_kernels_thom->module~m_common module~m_cuda_poisson_fft->module~m_common module~m_cuda_poisson_fft->module~m_cuda_allocator module~m_cuda_spectral m_cuda_spectral module~m_cuda_poisson_fft->module~m_cuda_spectral module~m_cuda_poisson_fft->module~m_field module~m_cuda_poisson_fft->module~m_mesh module~m_cuda_poisson_fft->module~m_poisson_fft module~m_cuda_poisson_fft->module~m_tdsops module~m_cuda_sendrecv->module~m_common module~m_cuda_spectral->module~m_common module~m_cuda_tdsops->module~m_common module~m_cuda_tdsops->module~m_tdsops module~m_exec_thom m_exec_thom module~m_exec_thom->module~m_common module~m_omp_kernels_thom m_omp_kernels_thom module~m_exec_thom->module~m_omp_kernels_thom module~m_exec_thom->module~m_tdsops module~m_field->module~m_common module~m_ibm m_ibm module~m_ibm->module~m_common module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_field module~m_ibm->module~m_io_session module~m_ibm->module~m_mesh module~m_io_backend m_io_backend module~m_io_backend->module~m_common module~m_io_base m_io_base module~m_io_backend->module~m_io_base module~m_io_backend~2 m_io_backend module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_io_base module~m_io_field_utils->module~m_solver module~m_io_session->module~m_common module~m_io_session->module~m_io_backend~2 module~m_io_session->module~m_io_base module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_mesh_content->module~m_common module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_common module~m_omp_backend->module~m_allocator module~m_omp_backend->module~m_base_backend module~m_omp_backend->module~m_field module~m_omp_backend->module~m_mesh module~m_omp_exec_dist m_omp_exec_dist module~m_omp_backend->module~m_omp_exec_dist module~m_omp_sendrecv m_omp_sendrecv module~m_omp_backend->module~m_omp_sendrecv module~m_ordering m_ordering module~m_omp_backend->module~m_ordering module~m_omp_backend->module~m_tdsops module~m_omp_exec_dist->module~m_common module~m_omp_kernels_dist m_omp_kernels_dist module~m_omp_exec_dist->module~m_omp_kernels_dist module~m_omp_exec_dist->module~m_omp_sendrecv module~m_omp_exec_dist->module~m_tdsops module~m_omp_kernels_dist->module~m_common module~m_omp_kernels_thom->module~m_common module~m_omp_poisson_fft m_omp_poisson_fft module~m_omp_poisson_fft->module~m_common module~m_omp_poisson_fft->module~m_field module~m_omp_poisson_fft->module~m_mesh module~m_omp_spectral m_omp_spectral module~m_omp_poisson_fft->module~m_omp_spectral module~m_omp_poisson_fft->module~m_poisson_fft module~m_omp_poisson_fft->module~m_tdsops module~m_omp_sendrecv->module~m_common module~m_omp_spectral->module~m_common module~m_ordering->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_snapshot_manager m_snapshot_manager module~m_snapshot_manager->module~m_common module~m_snapshot_manager->module~m_config module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_io_field_utils module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->module~m_solver module~m_solver->module~m_common module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_config module~m_solver->module~m_field module~m_solver->module~m_ibm module~m_solver->module~m_mesh module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_tdsops->module~m_common module~m_time_integrator->module~m_common module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_field module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_tdsops program~xcompact xcompact program~xcompact->module~m_common program~xcompact->module~m_allocator program~xcompact->module~m_base_backend program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv program~xcompact->module~m_config program~xcompact->module~m_cuda_allocator program~xcompact->module~m_cuda_backend program~xcompact->module~m_mesh program~xcompact->module~m_omp_backend module~m_io_manager->module~m_checkpoint_manager module~m_io_manager->module~m_snapshot_manager module~m_io_manager->module~m_solver proc~decomposition_2decomp m_decomp::decomposition_2decomp proc~decomposition_2decomp->module~m_mesh_content proc~decomposition_2decomp~2 m_decomp::decomposition_2decomp proc~decomposition_2decomp~2->module~m_mesh_content proc~decomposition_generic m_mesh::decomposition_generic proc~decomposition_generic->module~m_mesh_content proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(0.0e0) integer, public, parameter :: nbytes = 4 integer, public, parameter :: MPI_X3D2_DP = MPI_REAL logical, public, parameter :: is_sp = .true. integer, public, parameter :: dp = kind(0.0d0) integer, public, parameter :: nbytes = 8 integer, public, parameter :: MPI_X3D2_DP = MPI_DOUBLE_PRECISION logical, public, parameter :: is_sp = .false. integer, public, parameter :: sp = kind(0.0e0) integer, public, parameter :: i8 = selected_int_kind(18) real(kind=dp), public, parameter :: pi = 4*atan(1.0_dp) integer, public, parameter :: RDR_X2Y = 12 integer, public, parameter :: RDR_X2Z = 13 integer, public, parameter :: RDR_Y2X = 21 integer, public, parameter :: RDR_Y2Z = 23 integer, public, parameter :: RDR_Z2X = 31 integer, public, parameter :: RDR_Z2Y = 32 integer, public, parameter :: RDR_C2X = 41 integer, public, parameter :: RDR_C2Y = 42 integer, public, parameter :: RDR_C2Z = 43 integer, public, parameter :: RDR_X2C = 14 integer, public, parameter :: RDR_Y2C = 24 integer, public, parameter :: RDR_Z2C = 34 integer, public, parameter :: DIR_X = 1 integer, public, parameter :: DIR_Y = 2 integer, public, parameter :: DIR_Z = 3 integer, public, parameter :: DIR_C = 4 integer, public, parameter :: POISSON_SOLVER_FFT = 0 integer, public, parameter :: POISSON_SOLVER_CG = 1 integer, public, parameter :: VERT = 0000 integer, public, parameter :: CELL = 1110 integer, public, parameter :: X_FACE = 1100 integer, public, parameter :: Y_FACE = 1010 integer, public, parameter :: Z_FACE = 0110 integer, public, parameter :: X_EDGE = 0010 integer, public, parameter :: Y_EDGE = 0100 integer, public, parameter :: Z_EDGE = 1000 integer, public, parameter :: NULL_LOC = -0001 integer, public, parameter :: BC_PERIODIC = 0 integer, public, parameter :: BC_NEUMANN = 1 integer, public, parameter :: BC_DIRICHLET = 2 integer, public, parameter :: BC_HALO = -1 integer, protected :: rdr_map (4,4) = reshape([0, RDR_Y2X, RDR_Z2X, RDR_C2X, RDR_X2Y, 0, RDR_Z2Y, RDR_C2Y, RDR_X2Z, RDR_Y2Z, 0, RDR_C2Z, RDR_X2C, RDR_Y2C, RDR_Z2C, 0], shape=[4, 4]) Functions public pure function get_rdr_from_dirs (dir_from, dir_to) result(rdr_dir) Returns RDR_?2? value based on two direction inputs Arguments Type Intent Optional Attributes Name integer, intent(in) :: dir_from integer, intent(in) :: dir_to Return Value integer public  function get_argument (pos) result(arg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pos Return Value character(len=:), allocatable public  function move_data_loc (in_data_loc, dir, move) result(out_data_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: in_data_loc integer, intent(in) :: dir integer, intent(in) :: move Return Value integer Subroutines public pure subroutine get_dirs_from_rdr (dir_from, dir_to, rdr_dir) Arguments Type Intent Optional Attributes Name integer, intent(out) :: dir_from integer, intent(out) :: dir_to integer, intent(in) :: rdr_dir","tags":"","url":"module/m_common.html"},{"title":"m_io_backend – x3d2","text":"(ADaptive Input Output System v2) library. It acts as a translation layer\nconverting generic I/O calls from the session interface into specific calls\nto the ADIOS2 API. The adios2_reader_t and adios2_writer_t types defined here extend the\nabstract base types from m_io_base and implement required procedures This backend leverages several key features of the underlying ADIOS2 library\n- engine abstraction - the same API can be used for different transport\nmethods (e.g. BP4, BP5, HDF5)\n- Asynchronous I/O - by default ADIOS2 uses a deferred transport mode\nwhich can improve performance by overlapping computation and I/O\n- MPI integration - it is designed for large-scale paralle I/O and\nintegrates with MPI, though serial operation is also supported Note This is an internal backend module and should never be used directly.\nAll user interaction must go through m_io_session . Uses m_io_base m_common adios2 mpi module~~m_io_backend~~UsesGraph module~m_io_backend m_io_backend adios2 adios2 module~m_io_backend->adios2 module~m_common m_common module~m_io_backend->module~m_common module~m_io_base m_io_base module~m_io_backend->module~m_io_base mpi mpi module~m_io_backend->mpi module~m_common->mpi module~m_io_base->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: IO_BACKEND_DUMMY = 0 integer, public, parameter :: IO_BACKEND_ADIOS2 = 1 Functions public  function get_default_backend () result(backend) Arguments None Return Value integer Subroutines public  subroutine allocate_io_reader (reader) Arguments Type Intent Optional Attributes Name class( io_reader_t ), intent(out), allocatable :: reader public  subroutine allocate_io_writer (writer) Arguments Type Intent Optional Attributes Name class( io_writer_t ), intent(out), allocatable :: writer","tags":"","url":"module/m_io_backend.html"},{"title":"m_snapshot_manager – x3d2","text":"and visualisation. data to files intended for analysis and visualisation\nUnlike checkpoints, which are always full-resolution for exact restarts,\nsnapshots can be strided to reduce file size. Uses m_io_field_utils m_field m_solver m_config m_io_session mpi m_common module~~m_snapshot_manager~~UsesGraph module~m_snapshot_manager m_snapshot_manager module~m_common m_common module~m_snapshot_manager->module~m_common module~m_config m_config module~m_snapshot_manager->module~m_config module~m_field m_field module~m_snapshot_manager->module~m_field module~m_io_field_utils m_io_field_utils module~m_snapshot_manager->module~m_io_field_utils module~m_io_session m_io_session module~m_snapshot_manager->module~m_io_session module~m_solver m_solver module~m_snapshot_manager->module~m_solver mpi mpi module~m_snapshot_manager->mpi module~m_common->mpi module~m_config->module~m_common iso_fortran_env iso_fortran_env module~m_config->iso_fortran_env module~m_field->module~m_common module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_solver module~m_io_base m_io_base module~m_io_field_utils->module~m_io_base module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_session->module~m_io_base module~m_solver->module~m_common module~m_solver->module~m_config module~m_solver->module~m_field module~m_solver->mpi module~m_solver->iso_fortran_env module~m_allocator m_allocator module~m_solver->module~m_allocator module~m_base_backend m_base_backend module~m_solver->module~m_base_backend module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_mesh m_mesh module~m_solver->module~m_mesh module~m_tdsops m_tdsops module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_allocator->iso_fortran_env module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->mpi module~m_base_backend->module~m_allocator module~m_base_backend->module~m_mesh module~m_base_backend->module~m_tdsops module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->module~m_io_session module~m_ibm->mpi module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_mesh module~m_io_backend~2->module~m_common module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_tdsops module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_snapshot_manager~~UsedByGraph module~m_snapshot_manager m_snapshot_manager module~m_io_manager m_io_manager module~m_io_manager->module~m_snapshot_manager module~m_base_case m_base_case module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_base_case program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: snapshot_manager_t Components Type Visibility Attributes Name Initial type( checkpoint_config_t ), public :: config integer, public, dimension(3) :: output_stride = [1, 1, 1] type( field_buffer_map_t ), public, allocatable :: field_buffers (:) integer(kind=i8), public, dimension(3) :: last_shape_dims = 0 integer, public, dimension(3) :: last_stride_factors = 0 integer(kind=i8), public, dimension(3) :: last_output_shape = 0 character(len=4096), public :: vtk_xml = \"\" logical, public :: is_snapshot_file_open = .false. type( writer_session_t ), public :: snapshot_writer logical, public :: convert_to_sp = .false. Flag for single precision snapshots Type-Bound Procedures procedure, public :: init procedure, public :: handle_snapshot_step procedure, public :: finalise","tags":"","url":"module/m_snapshot_manager.html"},{"title":"m_mesh – x3d2","text":"Uses m_field iso_fortran_env m_mesh_content mpi m_common module~~m_mesh~~UsesGraph module~m_mesh m_mesh iso_fortran_env iso_fortran_env module~m_mesh->iso_fortran_env module~m_common m_common module~m_mesh->module~m_common module~m_field m_field module~m_mesh->module~m_field module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content mpi mpi module~m_mesh->mpi module~m_common->mpi module~m_field->module~m_common module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_mesh~~UsedByGraph module~m_mesh m_mesh module~m_base_backend m_base_backend module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_base_case m_base_case module~m_base_case->module~m_mesh module~m_base_case->module~m_base_backend module~m_solver m_solver module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_mesh module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_base_case module~m_case_channel->module~m_solver module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_mesh module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_base_case module~m_case_cylinder->module~m_solver module~m_case_generic m_case_generic module~m_case_generic->module~m_mesh module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_base_case module~m_case_generic->module~m_solver module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_mesh module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_base_case module~m_case_tgv->module~m_solver module~m_cuda_allocator m_cuda_allocator module~m_cuda_allocator->module~m_mesh module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_mesh module~m_cuda_backend->module~m_base_backend module~m_cuda_backend->module~m_cuda_allocator module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_cuda_poisson_fft->module~m_mesh module~m_cuda_poisson_fft->module~m_cuda_allocator module~m_cuda_poisson_fft->module~m_poisson_fft module~m_ibm m_ibm module~m_ibm->module~m_mesh module~m_ibm->module~m_base_backend module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_mesh module~m_omp_backend->module~m_base_backend module~m_omp_poisson_fft m_omp_poisson_fft module~m_omp_poisson_fft->module~m_mesh module~m_omp_poisson_fft->module~m_poisson_fft module~m_poisson_fft->module~m_mesh module~m_solver->module~m_mesh module~m_solver->module~m_base_backend module~m_solver->module~m_ibm module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus program~xcompact xcompact program~xcompact->module~m_mesh program~xcompact->module~m_base_backend program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv program~xcompact->module~m_cuda_allocator program~xcompact->module~m_cuda_backend program~xcompact->module~m_omp_backend module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_base_backend proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface mesh_t public  function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z, stretching, beta, use_2decomp) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z character(len=*), intent(in), optional, dimension(3) :: stretching real(kind=dp), intent(in), optional, dimension(3) :: beta logical, intent(in), optional :: use_2decomp Return Value class( mesh_t ), allocatable Derived Types type, public :: mesh_t Components Type Visibility Attributes Name Initial type( geo_t ), public, allocatable :: geo class( grid_t ), public, allocatable :: grid class( par_t ), public, allocatable :: par Constructor public\n\n                    \n                    function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z, stretching, beta, use_2decomp) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Type-Bound Procedures procedure, public :: get_dims procedure, public :: get_global_dims procedure, public :: get_n_dir procedure, public :: get_n_phi generic, public :: get_n => get_n_dir , get_n_phi procedure, public :: get_coordinates Functions public  function mesh_init (dims_global, nproc_dir, L_global, BC_x, BC_y, BC_z, stretching, beta, use_2decomp) result(mesh) Completely initialise the mesh object.\nUpon initialisation the mesh object can be read-only and shouldn't be edited\nTakes as argument global information about the mesh like its length, number of cells and decomposition in each direction Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dims_global integer, intent(in), dimension(3) :: nproc_dir real(kind=dp), intent(in), dimension(3) :: L_global character(len=*), intent(in), dimension(2) :: BC_x character(len=*), intent(in), dimension(2) :: BC_y character(len=*), intent(in), dimension(2) :: BC_z character(len=*), intent(in), optional, dimension(3) :: stretching real(kind=dp), intent(in), optional, dimension(3) :: beta logical, intent(in), optional :: use_2decomp Return Value class( mesh_t ), allocatable public pure function get_dims (self, data_loc) result(dims) Getter for local domain dimensions Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) public pure function get_global_dims (self, data_loc) result(dims) Getter for local domain dimensions Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: data_loc Return Value integer, dimension(3) public pure function get_dims_dataloc (data_loc, vert_dims, cell_dims) result(dims) Getter for domain dimensions Arguments Type Intent Optional Attributes Name integer, intent(in) :: data_loc integer, intent(in), dimension(3) :: vert_dims integer, intent(in), dimension(3) :: cell_dims Return Value integer, dimension(3) public pure function get_n_phi (self, phi) result(n) Getter for the main dimension of field phi Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self class( field_t ), intent(in) :: phi Return Value integer public pure function get_n_dir (self, dir, data_loc) result(n) Getter for the main dimension a field oriented along dir with data on data_loc Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: dir integer, intent(in) :: data_loc Return Value integer public pure function get_coordinates (self, i, j, k, data_loc_op) result(coords) Get the coordinates of a vertex with i, j, k local cartesian indices\nAvoid calling this in hot loops Arguments Type Intent Optional Attributes Name class( mesh_t ), intent(in) :: self integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in), optional :: data_loc_op Return Value real(kind=dp), dimension(3) Subroutines public  subroutine decomposition_generic (grid, par) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: grid class( par_t ), intent(inout) :: par","tags":"","url":"module/m_mesh.html"},{"title":"m_omp_kernels_dist – x3d2","text":"Uses m_common omp_lib m_omp_common module~~m_omp_kernels_dist~~UsesGraph module~m_omp_kernels_dist m_omp_kernels_dist module~m_common m_common module~m_omp_kernels_dist->module~m_common module~m_omp_common m_omp_common module~m_omp_kernels_dist->module~m_omp_common omp_lib omp_lib module~m_omp_kernels_dist->omp_lib mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_omp_kernels_dist~~UsedByGraph module~m_omp_kernels_dist m_omp_kernels_dist module~m_omp_exec_dist m_omp_exec_dist module~m_omp_exec_dist->module~m_omp_kernels_dist module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_omp_exec_dist program~xcompact xcompact program~xcompact->module~m_omp_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine der_univ_dist (du, send_u_s, send_u_e, u, u_s, u_e, n_tds, n_rhs, coeffs_s, coeffs_e, coeffs, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(out), dimension(:, :) :: send_u_s real(kind=dp), intent(out), dimension(:, :) :: send_u_e real(kind=dp), intent(in), dimension(:, :) :: u real(kind=dp), intent(in), dimension(:, :) :: u_s real(kind=dp), intent(in), dimension(:, :) :: u_e integer, intent(in) :: n_tds integer, intent(in) :: n_rhs real(kind=dp), intent(in), dimension(:, :) :: coeffs_s real(kind=dp), intent(in), dimension(:, :) :: coeffs_e real(kind=dp), intent(in), dimension(:) :: coeffs real(kind=dp), intent(in), dimension(:) :: ffr real(kind=dp), intent(in), dimension(:) :: fbc real(kind=dp), intent(in), dimension(:) :: faf public  subroutine der_univ_subs (du, recv_u_s, recv_u_e, n, dist_sa, dist_sc, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: recv_u_s real(kind=dp), intent(in), dimension(:, :) :: recv_u_e integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: dist_sa real(kind=dp), intent(in), dimension(:) :: dist_sc real(kind=dp), intent(in), dimension(:) :: strch public  subroutine der_univ_fused_subs (rhs_du, dud, d2u, v, du_recv_s, du_recv_e, dud_recv_s, dud_recv_e, d2u_recv_s, d2u_recv_e, nu, n, du_dist_sa, du_dist_sc, du_strch, dud_dist_sa, dud_dist_sc, dud_strch, d2u_dist_sa, d2u_dist_sc, d2u_strch, d2u_strch_cor) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), dimension(:, :) :: rhs_du real(kind=dp), intent(in), dimension(:, :) :: dud real(kind=dp), intent(in), dimension(:, :) :: d2u real(kind=dp), intent(in), dimension(:, :) :: v real(kind=dp), intent(in), dimension(:, :) :: du_recv_s real(kind=dp), intent(in), dimension(:, :) :: du_recv_e real(kind=dp), intent(in), dimension(:, :) :: dud_recv_s real(kind=dp), intent(in), dimension(:, :) :: dud_recv_e real(kind=dp), intent(in), dimension(:, :) :: d2u_recv_s real(kind=dp), intent(in), dimension(:, :) :: d2u_recv_e real(kind=dp), intent(in) :: nu integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: du_dist_sa real(kind=dp), intent(in), dimension(:) :: du_dist_sc real(kind=dp), intent(in), dimension(:) :: du_strch real(kind=dp), intent(in), dimension(:) :: dud_dist_sa real(kind=dp), intent(in), dimension(:) :: dud_dist_sc real(kind=dp), intent(in), dimension(:) :: dud_strch real(kind=dp), intent(in), dimension(:) :: d2u_dist_sa real(kind=dp), intent(in), dimension(:) :: d2u_dist_sc real(kind=dp), intent(in), dimension(:) :: d2u_strch real(kind=dp), intent(in), dimension(:) :: d2u_strch_cor","tags":"","url":"module/m_omp_kernels_dist.html"},{"title":"m_case_channel – x3d2","text":"Uses m_base_case m_config iso_fortran_env m_mesh m_solver m_allocator mpi m_base_backend m_common module~~m_case_channel~~UsesGraph module~m_case_channel m_case_channel iso_fortran_env iso_fortran_env module~m_case_channel->iso_fortran_env module~m_allocator m_allocator module~m_case_channel->module~m_allocator module~m_base_backend m_base_backend module~m_case_channel->module~m_base_backend module~m_base_case m_base_case module~m_case_channel->module~m_base_case module~m_common m_common module~m_case_channel->module~m_common module~m_config m_config module~m_case_channel->module~m_config module~m_mesh m_mesh module~m_case_channel->module~m_mesh module~m_solver m_solver module~m_case_channel->module~m_solver mpi mpi module~m_case_channel->mpi module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_field m_field module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_mesh module~m_base_backend->mpi module~m_base_backend->module~m_field module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops module~m_base_case->module~m_allocator module~m_base_case->module~m_base_backend module~m_base_case->module~m_common module~m_base_case->module~m_mesh module~m_base_case->module~m_solver module~m_base_case->mpi module~m_base_case->module~m_field module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_common->mpi module~m_config->iso_fortran_env module~m_config->module~m_common module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->mpi module~m_mesh->module~m_field module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_solver->iso_fortran_env module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_common module~m_solver->module~m_config module~m_solver->module~m_mesh module~m_solver->mpi module~m_solver->module~m_field module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_field->module~m_common module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_common module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_ibm->module~m_field module~m_io_session m_io_session module~m_ibm->module~m_io_session module~m_io_manager->module~m_solver module~m_checkpoint_manager m_checkpoint_manager module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_tdsops module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_tdsops module~m_checkpoint_manager->module~m_common module~m_checkpoint_manager->module~m_config module~m_checkpoint_manager->module~m_solver module~m_checkpoint_manager->mpi module~m_checkpoint_manager->module~m_field module~m_checkpoint_manager->module~m_io_session module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_base m_io_base module~m_io_session->module~m_io_base module~m_snapshot_manager->module~m_common module~m_snapshot_manager->module~m_config module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->mpi module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->module~m_io_field_utils module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_solver module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_io_base Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_case_channel~~UsedByGraph module~m_case_channel m_case_channel program~xcompact xcompact program~xcompact->module~m_case_channel Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface case_channel_t public  function case_channel_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_channel_t ) Derived Types type, public, extends( base_case_t ) :: case_channel_t Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr type( channel_config_t ), public :: channel_cfg Constructor public\n\n                    \n                    function case_channel_init (backend, mesh, host_allocator) Type-Bound Procedures procedure, public :: case_init procedure, public :: case_finalise procedure, public :: set_init procedure, public :: run procedure, public :: print_enstrophy procedure, public :: print_div_max_mean procedure, public :: boundary_conditions => boundary_conditions_channel procedure, public :: initial_conditions => initial_conditions_channel procedure, public :: forcings => forcings_channel procedure, public :: pre_correction => pre_correction_channel procedure, public :: postprocess => postprocess_channel Functions public  function case_channel_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_channel_t ) Subroutines public  subroutine boundary_conditions_channel (self) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self public  subroutine initial_conditions_channel (self) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self public  subroutine forcings_channel (self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter public  subroutine pre_correction_channel (self, u, v, w) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w public  subroutine postprocess_channel (self, iter, t) Arguments Type Intent Optional Attributes Name class( case_channel_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t","tags":"","url":"module/m_case_channel.html"},{"title":"m_cuda_allocator – x3d2","text":"Uses m_allocator m_mesh m_field m_common module~~m_cuda_allocator~~UsesGraph module~m_cuda_allocator m_cuda_allocator module~m_allocator m_allocator module~m_cuda_allocator->module~m_allocator module~m_common m_common module~m_cuda_allocator->module~m_common module~m_field m_field module~m_cuda_allocator->module~m_field module~m_mesh m_mesh module~m_cuda_allocator->module~m_mesh module~m_allocator->module~m_common module~m_allocator->module~m_field iso_fortran_env iso_fortran_env module~m_allocator->iso_fortran_env mpi mpi module~m_common->mpi module~m_field->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_mesh->mpi module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_allocator~~UsedByGraph module~m_cuda_allocator m_cuda_allocator module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_allocator module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_cuda_poisson_fft->module~m_cuda_allocator program~xcompact xcompact program~xcompact->module~m_cuda_allocator program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface cuda_allocator_t public  function cuda_allocator_init (dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( cuda_allocator_t ) public        interface cuda_field_t public  function cuda_field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) Derived Types type, public, extends( allocator_t ) :: cuda_allocator_t Components Type Visibility Attributes Name Initial integer, public :: ngrid integer, public :: sz integer, public :: next_id = 0 The id for the next allocated block.  This counter is\nincremented each time a new block is allocated. class( field_t ), public, pointer :: first => null() The pointer to the first block on the list.  Non associated if\nthe list is empty Constructor public\n\n                    \n                    function cuda_allocator_init (dims, sz) Type-Bound Procedures procedure, public :: get_block procedure, public :: release_block procedure, public :: get_block_ids procedure, public :: destroy procedure, public :: get_padded_dims procedure, public :: get_n_groups procedure, public :: create_block => create_cuda_block type, public, extends( field_t ) :: cuda_field_t Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, pointer, contiguous :: data (:,:,:) integer, public :: dir integer, public :: data_loc integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. real(kind=dp), public, device, pointer, contiguous :: data_d (:,:,:) Constructor public\n\n                    \n                    function cuda_field_init (ngrid, next, id) Type-Bound Procedures procedure, public :: set_data_loc procedure, public :: fill => fill_cuda procedure, public :: get_shape => get_shape_cuda procedure, public :: set_shape => set_shape_cuda Functions public  function cuda_field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( cuda_field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( cuda_field_t ) public  function get_shape_cuda (self) result(dims) Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self Return Value integer, (3) public  function cuda_allocator_init (dims, sz) result(allocator) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dims (3) integer, intent(in) :: sz Return Value type( cuda_allocator_t ) public  function create_cuda_block (self, next) result(ptr) Arguments Type Intent Optional Attributes Name class( cuda_allocator_t ), intent(inout) :: self type( cuda_field_t ), intent(in), pointer :: next Return Value class( field_t ), pointer Subroutines public  subroutine fill_cuda (self, c) Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self real(kind=dp), intent(in) :: c public  subroutine set_shape_cuda (self, dims) Arguments Type Intent Optional Attributes Name class( cuda_field_t ) :: self integer, intent(in) :: dims (3)","tags":"","url":"module/m_cuda_allocator.html"},{"title":"m_checkpoint_manager – x3d2","text":"for restart capabilities. simulation state to a file. This allows a simulation to be stopped and resumed\nfrom the exact state it was in. Key features include:\n- Reading all checkpoint settings from a configuration file\n- Periodically writing the full-resolution simulation state\n- Handling the full logic for restarting a simulation from\na specified checkpoint file.\n- A safe-write strategy that writes to a temporary file first,\n  then atomically renames it to the final filename to\nprevent corrupted checkpoints.\n- Optional cleanup of old checkpoint files to conserve disk space. Uses m_io_field_utils m_field m_solver m_config m_io_session mpi m_common module~~m_checkpoint_manager~~UsesGraph module~m_checkpoint_manager m_checkpoint_manager module~m_common m_common module~m_checkpoint_manager->module~m_common module~m_config m_config module~m_checkpoint_manager->module~m_config module~m_field m_field module~m_checkpoint_manager->module~m_field module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session m_io_session module~m_checkpoint_manager->module~m_io_session module~m_solver m_solver module~m_checkpoint_manager->module~m_solver mpi mpi module~m_checkpoint_manager->mpi module~m_common->mpi module~m_config->module~m_common iso_fortran_env iso_fortran_env module~m_config->iso_fortran_env module~m_field->module~m_common module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_solver module~m_io_base m_io_base module~m_io_field_utils->module~m_io_base module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_session->module~m_io_base module~m_solver->module~m_common module~m_solver->module~m_config module~m_solver->module~m_field module~m_solver->mpi module~m_solver->iso_fortran_env module~m_allocator m_allocator module~m_solver->module~m_allocator module~m_base_backend m_base_backend module~m_solver->module~m_base_backend module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_mesh m_mesh module~m_solver->module~m_mesh module~m_tdsops m_tdsops module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_allocator->iso_fortran_env module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->mpi module~m_base_backend->module~m_allocator module~m_base_backend->module~m_mesh module~m_base_backend->module~m_tdsops module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->module~m_io_session module~m_ibm->mpi module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_mesh module~m_io_backend~2->module~m_common module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_tdsops module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_checkpoint_manager~~UsedByGraph module~m_checkpoint_manager m_checkpoint_manager module~m_io_manager m_io_manager module~m_io_manager->module~m_checkpoint_manager module~m_base_case m_base_case module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_base_case program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: raw_old_field_buffer_t Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: data (:,:,:) type, public :: checkpoint_manager_t Components Type Visibility Attributes Name Initial type( checkpoint_config_t ), public :: config integer, public :: last_checkpoint_step = -1 integer, public, dimension(3) :: full_resolution = [1, 1, 1] type( field_buffer_map_t ), public, allocatable :: field_buffers (:) integer(kind=i8), public, dimension(3) :: last_shape_dims = 0 integer, public, dimension(3) :: last_stride_factors = 0 integer(kind=i8), public, dimension(3) :: last_output_shape = 0 Type-Bound Procedures procedure, public :: init procedure, public :: handle_restart procedure, public :: handle_checkpoint_step procedure, public :: is_restart procedure, public :: finalise","tags":"","url":"module/m_checkpoint_manager.html"},{"title":"m_cuda_tdsops – x3d2","text":"Uses iso_fortran_env m_tdsops m_common module~~m_cuda_tdsops~~UsesGraph module~m_cuda_tdsops m_cuda_tdsops iso_fortran_env iso_fortran_env module~m_cuda_tdsops->iso_fortran_env module~m_common m_common module~m_cuda_tdsops->module~m_common module~m_tdsops m_tdsops module~m_cuda_tdsops->module~m_tdsops mpi mpi module~m_common->mpi module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_tdsops~~UsedByGraph module~m_cuda_tdsops m_cuda_tdsops module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_tdsops module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend->module~m_cuda_exec_dist module~m_cuda_exec_dist->module~m_cuda_tdsops module~m_cuda_exec_thom m_cuda_exec_thom module~m_cuda_exec_thom->module~m_cuda_tdsops program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface cuda_tdsops_t public  function cuda_tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function Derived Types type, public, extends( tdsops_t ) :: cuda_tdsops_t CUDA extension of the Tridiagonal Solver Operators class. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: thom_f real(kind=dp), public, allocatable, dimension(:) :: thom_s real(kind=dp), public, allocatable, dimension(:) :: thom_w real(kind=dp), public, allocatable, dimension(:) :: thom_p real(kind=dp), public, allocatable :: stretch (:) real(kind=dp), public, allocatable :: stretch_correct (:) real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha Compact scheme coeffs real(kind=dp), public :: a Compact scheme coeffs real(kind=dp), public :: b Compact scheme coeffs real(kind=dp), public :: c = 0._dp Compact scheme coeffs real(kind=dp), public :: d = 0._dp Compact scheme coeffs logical, public :: periodic integer, public :: n_tds Tridiagonal system size integer, public :: n_rhs Right-hand-side builder size integer, public :: move = 0 move between vertices and cell centres integer, public :: n_halo number of halo points real(kind=dp), public, device, allocatable :: dist_fw_dev (:) real(kind=dp), public, device, allocatable :: dist_bw_dev (:) real(kind=dp), public, device, allocatable :: dist_sa_dev (:) real(kind=dp), public, device, allocatable :: dist_sc_dev (:) real(kind=dp), public, device, allocatable :: dist_af_dev (:) real(kind=dp), public, device, allocatable :: thom_f_dev (:) real(kind=dp), public, device, allocatable :: thom_s_dev (:) real(kind=dp), public, device, allocatable :: thom_w_dev (:) real(kind=dp), public, device, allocatable :: thom_p_dev (:) real(kind=dp), public, device, allocatable :: stretch_dev (:) real(kind=dp), public, device, allocatable :: stretch_correct_dev (:) real(kind=dp), public, device, allocatable :: coeffs_dev (:) real(kind=dp), public, device, allocatable :: coeffs_s_dev (:,:) real(kind=dp), public, device, allocatable :: coeffs_e_dev (:,:) Constructor public\n\n                    \n                    function cuda_tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Type-Bound Procedures procedure, public :: stagder_1st procedure, public :: interpl_mid procedure, public :: deriv_2nd procedure, public :: deriv_1st procedure, public :: preprocess_thom procedure, public :: preprocess_dist Functions public  function cuda_tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the cuda_tdsops_t class.\nSee tdsops_t for details. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu Return Value type( cuda_tdsops_t ) return value of the function","tags":"","url":"module/m_cuda_tdsops.html"},{"title":"m_omp_common – x3d2","text":"Used by module~~m_omp_common~~UsedByGraph module~m_omp_common m_omp_common module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_omp_common module~m_omp_exec_dist m_omp_exec_dist module~m_omp_backend->module~m_omp_exec_dist module~m_omp_exec_dist->module~m_omp_common module~m_omp_kernels_dist m_omp_kernels_dist module~m_omp_exec_dist->module~m_omp_kernels_dist module~m_omp_kernels_dist->module~m_omp_common module~m_omp_kernels_thom m_omp_kernels_thom module~m_omp_kernels_thom->module~m_omp_common program~xcompact xcompact program~xcompact->module~m_omp_common program~xcompact->module~m_omp_backend module~m_exec_thom m_exec_thom module~m_exec_thom->module~m_omp_kernels_thom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: SZ = 16","tags":"","url":"module/m_omp_common.html"},{"title":"m_solver – x3d2","text":"Uses m_tdsops m_field m_config iso_fortran_env m_mesh m_allocator mpi m_ibm m_base_backend m_common m_time_integrator m_vector_calculus module~~m_solver~~UsesGraph module~m_solver m_solver iso_fortran_env iso_fortran_env module~m_solver->iso_fortran_env module~m_allocator m_allocator module~m_solver->module~m_allocator module~m_base_backend m_base_backend module~m_solver->module~m_base_backend module~m_common m_common module~m_solver->module~m_common module~m_config m_config module~m_solver->module~m_config module~m_field m_field module~m_solver->module~m_field module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_mesh m_mesh module~m_solver->module~m_mesh module~m_tdsops m_tdsops module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus mpi mpi module~m_solver->mpi module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_base_backend->module~m_tdsops module~m_base_backend->mpi module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_common->mpi module~m_config->iso_fortran_env module~m_config->module~m_common module~m_field->module~m_common module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_io_session m_io_session module~m_ibm->module~m_io_session module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_tdsops module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_base m_io_base module~m_io_session->module~m_io_base module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_solver~~UsedByGraph module~m_solver m_solver module~m_base_case m_base_case module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_solver module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface solver_t public  function init (backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t ) Abstract Interfaces abstract interface public  subroutine poisson_solver(self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u abstract interface public  subroutine transport_equation(self, rhs, variables) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(inout) :: variables (:) Derived Types type, public :: solver_t solver class defines the Incompact3D algorithm at a very high level. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt real(kind=dp), public :: nu real(kind=dp), public, dimension(:), allocatable :: nu_species integer, public :: n_iters integer, public :: n_output integer, public :: current_iter = 0 integer, public :: ngrid integer, public :: nvars = 3 integer, public :: nspecies = 0 class( field_t ), public, pointer :: u class( field_t ), public, pointer :: v class( field_t ), public, pointer :: w type( flist_t ), public, dimension(:), pointer :: species => null() class( base_backend_t ), public, pointer :: backend type( mesh_t ), public, pointer :: mesh type( time_intg_t ), public :: time_integrator type( allocator_t ), public, pointer :: host_allocator type( dirps_t ), public, pointer :: xdirps type( dirps_t ), public, pointer :: ydirps type( dirps_t ), public, pointer :: zdirps type( vector_calculus_t ), public :: vector_calculus type( ibm_t ), public :: ibm logical, public :: ibm_on procedure( poisson_solver ), public, pointer :: poisson => null() procedure( transport_equation ), public, pointer :: transeq => null() Constructor public\n\n                    \n                    function init (backend, mesh, host_allocator) Type-Bound Procedures procedure, public :: transeq_species procedure, public :: pressure_correction procedure, public :: divergence_v2p procedure, public :: gradient_p2v procedure, public :: curl Functions public  function init (backend, mesh, host_allocator) result(solver) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( solver_t ) Subroutines public  subroutine allocate_tdsops (dirps, backend, mesh, der1st_scheme, der2nd_scheme, interpl_scheme, stagder_scheme) Arguments Type Intent Optional Attributes Name type( dirps_t ), intent(inout) :: dirps class( base_backend_t ), intent(in) :: backend type( mesh_t ), intent(in) :: mesh character(len=*), intent(in) :: der1st_scheme character(len=*), intent(in) :: der2nd_scheme character(len=*), intent(in) :: interpl_scheme character(len=*), intent(in) :: stagder_scheme public  subroutine transeq_default (self, rhs, variables) Skew-symmetric form of convection-diffusion terms in the\nincompressible Navier-Stokes momemtum equations, excluding\npressure terms.\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(inout) :: variables (:) public  subroutine transeq_lowmem (self, rhs, variables) low memory version of the transport equation, roughly %2 slower overall Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(inout) :: variables (:) public  subroutine transeq_species (self, rhs, variables) Skew-symmetric form of convection-diffusion terms in the\nspecies equation.\nInputs from velocity grid and outputs to velocity grid. Arguments Type Intent Optional Attributes Name class( solver_t ) :: self type( flist_t ), intent(inout) :: rhs (:) type( flist_t ), intent(in) :: variables (:) public  subroutine divergence_v2p (self, div_u, u, v, w) Wrapper for divergence_v2p Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: div_u class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine gradient_p2v (self, dpdx, dpdy, dpdz, pressure) Wrapper for gradient_p2v Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: dpdx class( field_t ), intent(inout) :: dpdy class( field_t ), intent(inout) :: dpdz class( field_t ), intent(in) :: pressure public  subroutine curl (self, o_i_hat, o_j_hat, o_k_hat, u, v, w) Wrapper for curl Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: o_i_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_j_hat Vector components of the output vector field Omega class( field_t ), intent(inout) :: o_k_hat Vector components of the output vector field Omega class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine poisson_fft (self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u public  subroutine poisson_cg (self, pressure, div_u) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: pressure class( field_t ), intent(in) :: div_u public  subroutine pressure_correction (self, u, v, w) Arguments Type Intent Optional Attributes Name class( solver_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w","tags":"","url":"module/m_solver.html"},{"title":"m_mesh_content – x3d2","text":"Uses m_common module~~m_mesh_content~~UsesGraph module~m_mesh_content m_mesh_content module~m_common m_common module~m_mesh_content->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_mesh_content~~UsedByGraph module~m_mesh_content m_mesh_content module~m_mesh m_mesh module~m_mesh->module~m_mesh_content proc~decomposition_2decomp m_decomp::decomposition_2decomp proc~decomposition_2decomp->module~m_mesh_content proc~decomposition_2decomp~2 m_decomp::decomposition_2decomp proc~decomposition_2decomp~2->module~m_mesh_content proc~decomposition_generic m_mesh::decomposition_generic proc~decomposition_generic->module~m_mesh_content module~m_base_backend m_base_backend module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_base_case m_base_case module~m_base_case->module~m_mesh module~m_base_case->module~m_base_backend module~m_solver m_solver module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_mesh module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_base_case module~m_case_channel->module~m_solver module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_mesh module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_base_case module~m_case_cylinder->module~m_solver module~m_case_generic m_case_generic module~m_case_generic->module~m_mesh module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_base_case module~m_case_generic->module~m_solver module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_mesh module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_base_case module~m_case_tgv->module~m_solver module~m_cuda_allocator m_cuda_allocator module~m_cuda_allocator->module~m_mesh module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_mesh module~m_cuda_backend->module~m_base_backend module~m_cuda_backend->module~m_cuda_allocator module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_cuda_poisson_fft->module~m_mesh module~m_cuda_poisson_fft->module~m_cuda_allocator module~m_cuda_poisson_fft->module~m_poisson_fft module~m_ibm m_ibm module~m_ibm->module~m_mesh module~m_ibm->module~m_base_backend module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_mesh module~m_omp_backend->module~m_base_backend module~m_omp_poisson_fft m_omp_poisson_fft module~m_omp_poisson_fft->module~m_mesh module~m_omp_poisson_fft->module~m_poisson_fft module~m_poisson_fft->module~m_mesh module~m_solver->module~m_mesh module~m_solver->module~m_base_backend module~m_solver->module~m_ibm module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus program~xcompact xcompact program~xcompact->module~m_mesh program~xcompact->module~m_base_backend program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv program~xcompact->module~m_cuda_allocator program~xcompact->module~m_cuda_backend program~xcompact->module~m_omp_backend module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_base_backend proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: geo_t Stores geometry information Components Type Visibility Attributes Name Initial real(kind=dp), public :: origin (3) Origin: coordinates of vertex (1, 1, 1) real(kind=dp), public :: d (3) size of a cell in each direction for a uniform mesh real(kind=dp), public :: L (3) Global dimensions of the domain in each direction real(kind=dp), public, allocatable, dimension(:, :) :: vert_coords Global coordinates at vertices real(kind=dp), public, allocatable, dimension(:, :) :: midp_coords Global coordinates at midpoints character(len=20), public, dimension(3) :: stretching Stretching type logical, public :: stretched (3) Stretching real(kind=dp), public :: alpha (3) Stretching parameters real(kind=dp), public :: beta (3) Stretching parameters real(kind=dp), public, allocatable, dimension(:, :) :: vert_ds Stretching factors at vertices real(kind=dp), public, allocatable, dimension(:, :) :: vert_ds2 Stretching factors at vertices real(kind=dp), public, allocatable, dimension(:, :) :: vert_d2s Stretching factors at vertices real(kind=dp), public, allocatable, dimension(:, :) :: midp_ds Stretching factors at midpoints real(kind=dp), public, allocatable, dimension(:, :) :: midp_ds2 Stretching factors at midpoints real(kind=dp), public, allocatable, dimension(:, :) :: midp_d2s Stretching factors at midpoints Type-Bound Procedures procedure, public :: obtain_coordinates type, public :: grid_t Stores grid information Components Type Visibility Attributes Name Initial integer, public, dimension(3) :: global_vert_dims integer, public, dimension(3) :: global_cell_dims integer, public, dimension(3) :: vert_dims integer, public, dimension(3) :: cell_dims logical, public, dimension(3) :: periodic_BC integer, public, dimension(3, 2) :: BCs_global integer, public, dimension(3, 2) :: BCs Type-Bound Procedures procedure, public :: copy_cell2vert_dims procedure, public :: copy_vert2cell_dims type, public :: par_t Stores parallel domain related information Components Type Visibility Attributes Name Initial integer, public :: nrank integer, public :: nproc integer, public, dimension(3) :: nrank_dir integer, public, dimension(3) :: nproc_dir integer, public, dimension(3) :: n_offset integer, public, dimension(3) :: pnext integer, public, dimension(3) :: pprev Type-Bound Procedures procedure, public :: is_root procedure, public :: compute_rank_pos_from_global Functions public pure function is_root (self) result(is_root_rank) Returns wether or not the current rank is the root rank Arguments Type Intent Optional Attributes Name class( par_t ), intent(in) :: self Return Value logical Subroutines public pure subroutine compute_rank_pos_from_global (self, global_ranks) From the global rank maps, fills in the rank position as well\nas the previous and next rank in the par structure Arguments Type Intent Optional Attributes Name class( par_t ), intent(inout) :: self integer, intent(in), dimension(:, :, :) :: global_ranks public pure subroutine copy_vert2cell_dims (self, par) Copies vert_dims information to cell_dims taking\nperiodicity into account Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: self type( par_t ), intent(in) :: par public pure subroutine copy_cell2vert_dims (self, par) Copies cell_dims information to vert_dims taking\nperiodicity into account Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: self type( par_t ), intent(in) :: par public  subroutine obtain_coordinates (self, vert_dims, cell_dims, n_offset) Obtains global coordinates for all the vertices and midpoints Arguments Type Intent Optional Attributes Name class( geo_t ) :: self integer, intent(in) :: vert_dims (3) integer, intent(in) :: cell_dims (3) integer, intent(in) :: n_offset (3)","tags":"","url":"module/m_mesh_content.html"},{"title":"m_cuda_common – x3d2","text":"Used by module~~m_cuda_common~~UsedByGraph module~m_cuda_common m_cuda_common module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_common module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend->module~m_cuda_exec_dist module~m_cuda_kernels_fieldops m_cuda_kernels_fieldops module~m_cuda_backend->module~m_cuda_kernels_fieldops module~m_cuda_kernels_reorder m_cuda_kernels_reorder module~m_cuda_backend->module~m_cuda_kernels_reorder module~m_cuda_exec_dist->module~m_cuda_common module~m_cuda_kernels_fieldops->module~m_cuda_common module~m_cuda_kernels_reorder->module~m_cuda_common program~xcompact xcompact program~xcompact->module~m_cuda_common program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: SZ = 32","tags":"","url":"module/m_cuda_common.html"},{"title":"m_cuda_exec_dist – x3d2","text":"Uses cudafor m_cuda_sendrecv m_cuda_common mpi m_cuda_tdsops m_common m_cuda_kernels_dist module~~m_cuda_exec_dist~~UsesGraph module~m_cuda_exec_dist m_cuda_exec_dist cudafor cudafor module~m_cuda_exec_dist->cudafor module~m_common m_common module~m_cuda_exec_dist->module~m_common module~m_cuda_common m_cuda_common module~m_cuda_exec_dist->module~m_cuda_common module~m_cuda_kernels_dist m_cuda_kernels_dist module~m_cuda_exec_dist->module~m_cuda_kernels_dist module~m_cuda_sendrecv m_cuda_sendrecv module~m_cuda_exec_dist->module~m_cuda_sendrecv module~m_cuda_tdsops m_cuda_tdsops module~m_cuda_exec_dist->module~m_cuda_tdsops mpi mpi module~m_cuda_exec_dist->mpi module~m_common->mpi module~m_cuda_kernels_dist->cudafor module~m_cuda_kernels_dist->module~m_common module~m_cuda_sendrecv->cudafor module~m_cuda_sendrecv->module~m_common module~m_cuda_sendrecv->mpi module~m_cuda_tdsops->module~m_common iso_fortran_env iso_fortran_env module~m_cuda_tdsops->iso_fortran_env module~m_tdsops m_tdsops module~m_cuda_tdsops->module~m_tdsops module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_exec_dist~~UsedByGraph module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_exec_dist program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine exec_dist_tds_compact (du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e type( cuda_tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine exec_dist_transeq_3fused (r_du, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, tdsops_du, tdsops_dud, tdsops_d2u, nu, nproc, pprev, pnext, blocks, threads) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: r_du The result array, it is also used as temporary storage real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u_recv_e type( cuda_tdsops_t ), intent(in) :: tdsops_du type( cuda_tdsops_t ), intent(in) :: tdsops_dud type( cuda_tdsops_t ), intent(in) :: tdsops_d2u real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads","tags":"","url":"module/m_cuda_exec_dist.html"},{"title":"m_cuda_poisson_fft – x3d2","text":"Uses m_tdsops iso_c_binding cudafor m_field m_cuda_spectral iso_fortran_env cufftXt cufft m_mesh m_cuda_allocator mpi m_common m_poisson_fft module~~m_cuda_poisson_fft~~UsesGraph module~m_cuda_poisson_fft m_cuda_poisson_fft cudafor cudafor module~m_cuda_poisson_fft->cudafor cufft cufft module~m_cuda_poisson_fft->cufft cufftXt cufftXt module~m_cuda_poisson_fft->cufftXt iso_c_binding iso_c_binding module~m_cuda_poisson_fft->iso_c_binding iso_fortran_env iso_fortran_env module~m_cuda_poisson_fft->iso_fortran_env module~m_common m_common module~m_cuda_poisson_fft->module~m_common module~m_cuda_allocator m_cuda_allocator module~m_cuda_poisson_fft->module~m_cuda_allocator module~m_cuda_spectral m_cuda_spectral module~m_cuda_poisson_fft->module~m_cuda_spectral module~m_field m_field module~m_cuda_poisson_fft->module~m_field module~m_mesh m_mesh module~m_cuda_poisson_fft->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_cuda_poisson_fft->module~m_poisson_fft module~m_tdsops m_tdsops module~m_cuda_poisson_fft->module~m_tdsops mpi mpi module~m_cuda_poisson_fft->mpi module~m_common->mpi module~m_cuda_allocator->module~m_common module~m_cuda_allocator->module~m_field module~m_cuda_allocator->module~m_mesh module~m_allocator m_allocator module~m_cuda_allocator->module~m_allocator module~m_cuda_spectral->cudafor module~m_cuda_spectral->module~m_common module~m_field->module~m_common module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_poisson_fft~~UsedByGraph module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_poisson_fft program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface cuda_poisson_fft_t private  function init(mesh, xdirps, ydirps, zdirps, lowmem) result(poisson_fft) if stretching in y is 'bottom' Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem Return Value type( cuda_poisson_fft_t ) interface public  function cufftExecR2C_C(plan, idata, odata) bind(C, name='cufftExecR2C') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: plan type(c_ptr), value :: idata type(c_ptr), value :: odata Return Value integer(kind=c_int) interface public  function cufftExecC2R_C(plan, idata, odata) bind(C, name='cufftExecC2R') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: plan type(c_ptr), value :: idata type(c_ptr), value :: odata Return Value integer(kind=c_int) Derived Types type, public, extends( poisson_fft_t ) :: cuda_poisson_fft_t FFT based Poisson solver Components Type Visibility Attributes Name Initial type( mesh_t ), public, pointer :: mesh => null() integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: x_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: z_sp_st Offset in y and z directions in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants real(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ky Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: exs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: eys Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ezs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2x Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2y Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2z Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: trans_x_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_x_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_im Staggared grid transformation logical, public :: periodic_x Periodicity in x, y, and z logical, public :: periodic_y Periodicity in x, y, and z logical, public :: periodic_z Periodicity in x, y, and z logical, public :: stretched_y = .false. Periodicity in x, y, and z logical, public :: stretched_y_sym Periodicity in x, y, and z real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_im Stretching operator matrices logical, public :: lowmem = .false. lowmem option, only used in CUDA backend procedure( poisson_xxx ), public, pointer :: poisson => null() Procedure pointer to BC specific poisson solvers complex(kind=dp), public, device, allocatable, dimension(:, :, :) :: waves_dev Local domain sized array storing the spectral equivalence constants real(kind=dp), public, device, allocatable, dimension(:) :: ax_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: bx_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: ay_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: by_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: az_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:) :: bz_dev Wave numbers in x, y, and z real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_odd_re_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_odd_im_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_even_re_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_even_im_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_re_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: store_a_im_dev Stretching operator matrices stores real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_odd_re_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_odd_im_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_even_re_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_even_im_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_re_dev Stretching operator matrices real(kind=dp), public, device, allocatable, dimension(:, :, :, :) :: a_im_dev Stretching operator matrices integer, public :: plan3D_fw Forward and backward FFT transform plans integer, public :: plan3D_bw Forward and backward FFT transform plans logical, public :: use_cufftmp = .true. Flag to indicate whether cuFFTMp is used type(cudaLibXtDesc), public, pointer :: xtdesc cuFFTMp object manages decomposition and data storage complex(kind=dp), public, device, allocatable, dimension(:, :, :) :: c_dev Standard cuFFT storage real(kind=dp), public, device, allocatable, dimension(:, :, :) :: r_dev cuFFT real workspace (input/output of R2C/C2R) Constructor private\n\n                    \n                    function init (mesh, xdirps, ydirps, zdirps, lowmem) if stretching in y is 'bottom' Type-Bound Procedures procedure, public :: base_init procedure, public :: solve_poisson procedure, public :: stretching_matrix procedure, public :: waves_set procedure, public :: get_km procedure, public :: get_km_re procedure, public :: get_km_im procedure, public :: fft_forward => fft_forward_cuda procedure, public :: fft_forward_010 => fft_forward_cuda procedure, public :: fft_forward_100 => fft_forward_100_cuda procedure, public :: fft_forward_110 => fft_forward_cuda procedure, public :: fft_backward => fft_backward_cuda procedure, public :: fft_backward_010 => fft_backward_cuda procedure, public :: fft_backward_100 => fft_backward_100_cuda procedure, public :: fft_backward_110 => fft_backward_cuda procedure, public :: fft_postprocess_000 => fft_postprocess_000_cuda procedure, public :: fft_postprocess_010 => fft_postprocess_010_cuda procedure, public :: fft_postprocess_100 => fft_postprocess_100_cuda procedure, public :: fft_postprocess_110 => fft_postprocess_110_cuda procedure, public :: enforce_periodicity_x => enforce_periodicity_x_cuda procedure, public :: undo_periodicity_x => undo_periodicity_x_cuda procedure, public :: enforce_periodicity_y => enforce_periodicity_y_cuda procedure, public :: undo_periodicity_y => undo_periodicity_y_cuda Subroutines public  subroutine fft_forward_100_cuda (self, f) Forward FFT for non-periodic-X case\nWe transpose X<->Y so that the non-periodic direction becomes the\n\"Y\" direction in the transposed space, then use the same FFT approach as 010 Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f public  subroutine fft_backward_100_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f public  subroutine fft_forward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(in) :: f public  subroutine fft_backward_cuda (self, f) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f public  subroutine fft_postprocess_000_cuda (self) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self public  subroutine fft_postprocess_100_cuda (self) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self public  subroutine fft_postprocess_010_cuda (self) if stretching in y is 'bottom' Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self public  subroutine fft_postprocess_110_cuda (self) if stretching in y is 'bottom' Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self public  subroutine enforce_periodicity_x_cuda (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in public  subroutine undo_periodicity_x_cuda (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in public  subroutine enforce_periodicity_y_cuda (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in public  subroutine undo_periodicity_y_cuda (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( cuda_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"module/m_cuda_poisson_fft.html"},{"title":"m_omp_kernels_thom – x3d2","text":"Uses m_common m_omp_common module~~m_omp_kernels_thom~~UsesGraph module~m_omp_kernels_thom m_omp_kernels_thom module~m_common m_common module~m_omp_kernels_thom->module~m_common module~m_omp_common m_omp_common module~m_omp_kernels_thom->module~m_omp_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_omp_kernels_thom~~UsedByGraph module~m_omp_kernels_thom m_omp_kernels_thom module~m_exec_thom m_exec_thom module~m_exec_thom->module~m_omp_kernels_thom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine der_univ_thom (du, u, n_tds, n_rhs, coeffs_s, coeffs_e, coeffs, thom_f, thom_s, thom_w, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: u integer, intent(in) :: n_tds integer, intent(in) :: n_rhs real(kind=dp), intent(in), dimension(:, :) :: coeffs_s real(kind=dp), intent(in), dimension(:, :) :: coeffs_e real(kind=dp), intent(in), dimension(:) :: coeffs real(kind=dp), intent(in), dimension(:) :: thom_f real(kind=dp), intent(in), dimension(:) :: thom_s real(kind=dp), intent(in), dimension(:) :: thom_w real(kind=dp), intent(in), dimension(:) :: strch public  subroutine der_univ_thom_per (du, u, n, coeffs, alpha, thom_f, thom_s, thom_w, thom_p, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :) :: du real(kind=dp), intent(in), dimension(:, :) :: u integer, intent(in) :: n real(kind=dp), intent(in), dimension(:) :: coeffs real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in), dimension(:) :: thom_f real(kind=dp), intent(in), dimension(:) :: thom_s real(kind=dp), intent(in), dimension(:) :: thom_w real(kind=dp), intent(in), dimension(:) :: thom_p real(kind=dp), intent(in), dimension(:) :: strch","tags":"","url":"module/m_omp_kernels_thom.html"},{"title":"m_base_case – x3d2","text":"Provides the base case for running a simulation. New cases are\nimplemented by extending this to specify the initial and boundary\nconditions, forcing terms and case-specific postprocessing and analysis. Uses m_field m_io_manager m_solver m_mesh m_allocator mpi m_base_backend m_common module~~m_base_case~~UsesGraph module~m_base_case m_base_case module~m_allocator m_allocator module~m_base_case->module~m_allocator module~m_base_backend m_base_backend module~m_base_case->module~m_base_backend module~m_common m_common module~m_base_case->module~m_common module~m_field m_field module~m_base_case->module~m_field module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_mesh m_mesh module~m_base_case->module~m_mesh module~m_solver m_solver module~m_base_case->module~m_solver mpi mpi module~m_base_case->mpi module~m_allocator->module~m_common module~m_allocator->module~m_field iso_fortran_env iso_fortran_env module~m_allocator->iso_fortran_env module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_base_backend->mpi module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops module~m_common->mpi module~m_field->module~m_common module~m_io_manager->module~m_solver module~m_checkpoint_manager m_checkpoint_manager module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_common module~m_solver->module~m_field module~m_solver->module~m_mesh module~m_solver->mpi module~m_solver->iso_fortran_env module~m_config m_config module~m_solver->module~m_config module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_checkpoint_manager->module~m_common module~m_checkpoint_manager->module~m_field module~m_checkpoint_manager->module~m_solver module~m_checkpoint_manager->mpi module~m_checkpoint_manager->module~m_config module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session m_io_session module~m_checkpoint_manager->module~m_io_session module~m_config->module~m_common module~m_config->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_ibm->iso_fortran_env module~m_ibm->module~m_io_session module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_snapshot_manager->module~m_common module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->mpi module~m_snapshot_manager->module~m_config module~m_snapshot_manager->module~m_io_field_utils module~m_snapshot_manager->module~m_io_session module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_tdsops module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_solver module~m_io_base m_io_base module~m_io_field_utils->module~m_io_base module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_session->module~m_io_base module~m_io_backend~2->module~m_common module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_base_case~~UsedByGraph module~m_base_case m_base_case module~m_case_channel m_case_channel module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_base_case program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  subroutine boundary_conditions(self) Applies case-specific boundary coinditions Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self abstract interface public  subroutine initial_conditions(self) Sets case-specific initial conditions Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self abstract interface public  subroutine forcings(self, du, dv, dw, iter) Applies case-specific or model realated forcings after transeq Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter abstract interface public  subroutine pre_correction(self, u, v, w) Applies case-specific pre-correction to the velocity fields before\npressure correction Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w abstract interface public  subroutine postprocess(self, iter, t) Triggers case-specific postprocessings at user specified intervals Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t Derived Types type, public, abstract :: base_case_t Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr Type-Bound Procedures procedure( boundary_conditions ), public, deferred :: boundary_conditions procedure( initial_conditions ), public, deferred :: initial_conditions procedure( forcings ), public, deferred :: forcings procedure( pre_correction ), public, deferred :: pre_correction procedure( postprocess ), public, deferred :: postprocess procedure, public :: case_init procedure, public :: case_finalise procedure, public :: set_init procedure, public :: run procedure, public :: print_enstrophy procedure, public :: print_div_max_mean Subroutines public  subroutine case_init (self, backend, mesh, host_allocator) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator public  subroutine case_finalise (self) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self public  subroutine set_init (self, field, field_func) Arguments Type Intent Optional Attributes Name class( base_case_t ) :: self class( field_t ), intent(inout) :: field public pure function field_func(coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) public  subroutine print_enstrophy (self, u, v, w) Reports the enstrophy Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine print_div_max_mean (self, u, v, w) Reports the div(u) at cell centres Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(in) :: self class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w public  subroutine run (self) Runs the solver forwards in time from t=t_0 to t=T, performing\npostprocessing/IO and reporting diagnostics. Arguments Type Intent Optional Attributes Name class( base_case_t ), intent(inout) :: self","tags":"","url":"module/m_base_case.html"},{"title":"m_omp_exec_dist – x3d2","text":"Uses m_tdsops m_omp_sendrecv m_omp_common m_omp_kernels_dist mpi m_common module~~m_omp_exec_dist~~UsesGraph module~m_omp_exec_dist m_omp_exec_dist module~m_common m_common module~m_omp_exec_dist->module~m_common module~m_omp_common m_omp_common module~m_omp_exec_dist->module~m_omp_common module~m_omp_kernels_dist m_omp_kernels_dist module~m_omp_exec_dist->module~m_omp_kernels_dist module~m_omp_sendrecv m_omp_sendrecv module~m_omp_exec_dist->module~m_omp_sendrecv module~m_tdsops m_tdsops module~m_omp_exec_dist->module~m_tdsops mpi mpi module~m_omp_exec_dist->mpi module~m_common->mpi module~m_omp_kernels_dist->module~m_common module~m_omp_kernels_dist->module~m_omp_common omp_lib omp_lib module~m_omp_kernels_dist->omp_lib module~m_omp_sendrecv->module~m_common module~m_omp_sendrecv->mpi module~m_tdsops->module~m_common iso_fortran_env iso_fortran_env module~m_tdsops->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_omp_exec_dist~~UsedByGraph module~m_omp_exec_dist m_omp_exec_dist module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_omp_exec_dist program~xcompact xcompact program~xcompact->module~m_omp_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine exec_dist_tds_compact (du, u, u_recv_s, u_recv_e, du_send_s, du_send_e, du_recv_s, du_recv_e, tdsops, nproc, pprev, pnext, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e type( tdsops_t ), intent(in) :: tdsops integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_groups public  subroutine exec_dist_transeq_compact (rhs_du, dud, d2u, du_send_s, du_send_e, du_recv_s, du_recv_e, dud_send_s, dud_send_e, dud_recv_s, dud_recv_e, d2u_send_s, d2u_send_e, d2u_recv_s, d2u_recv_e, u, u_recv_s, u_recv_e, v, v_recv_s, v_recv_e, tdsops_du, tdsops_dud, tdsops_d2u, nu, nproc, pprev, pnext, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: rhs_du The result array, it is also used as temporary storage real(kind=dp), intent(out), dimension(:, :, :) :: dud Temporary storage arrays real(kind=dp), intent(out), dimension(:, :, :) :: d2u Temporary storage arrays real(kind=dp), intent(out), dimension(:, :, :) :: du_send_s real(kind=dp), intent(out), dimension(:, :, :) :: du_send_e real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: du_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_send_e real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: dud_recv_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_send_e real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_s real(kind=dp), intent(out), dimension(:, :, :) :: d2u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: u real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: u_recv_e real(kind=dp), intent(in), dimension(:, :, :) :: v real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_s real(kind=dp), intent(in), dimension(:, :, :) :: v_recv_e type( tdsops_t ), intent(in) :: tdsops_du type( tdsops_t ), intent(in) :: tdsops_dud type( tdsops_t ), intent(in) :: tdsops_d2u real(kind=dp), intent(in) :: nu integer, intent(in) :: nproc integer, intent(in) :: pprev integer, intent(in) :: pnext integer, intent(in) :: n_groups","tags":"","url":"module/m_omp_exec_dist.html"},{"title":"m_case_tgv – x3d2","text":"Uses m_base_case m_field m_solver iso_fortran_env m_mesh m_allocator m_base_backend m_common module~~m_case_tgv~~UsesGraph module~m_case_tgv m_case_tgv iso_fortran_env iso_fortran_env module~m_case_tgv->iso_fortran_env module~m_allocator m_allocator module~m_case_tgv->module~m_allocator module~m_base_backend m_base_backend module~m_case_tgv->module~m_base_backend module~m_base_case m_base_case module~m_case_tgv->module~m_base_case module~m_common m_common module~m_case_tgv->module~m_common module~m_field m_field module~m_case_tgv->module~m_field module~m_mesh m_mesh module~m_case_tgv->module~m_mesh module~m_solver m_solver module~m_case_tgv->module~m_solver module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops mpi mpi module~m_base_backend->mpi module~m_base_case->module~m_allocator module~m_base_case->module~m_base_backend module~m_base_case->module~m_common module~m_base_case->module~m_field module~m_base_case->module~m_mesh module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_base_case->mpi module~m_common->mpi module~m_field->module~m_common module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_mesh->mpi module~m_solver->iso_fortran_env module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_common module~m_solver->module~m_field module~m_solver->module~m_mesh module~m_config m_config module~m_solver->module~m_config module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_solver->mpi module~m_config->iso_fortran_env module~m_config->module~m_common module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_io_session m_io_session module~m_ibm->module~m_io_session module~m_io_manager->module~m_solver module~m_checkpoint_manager m_checkpoint_manager module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_tdsops module~m_checkpoint_manager->module~m_common module~m_checkpoint_manager->module~m_field module~m_checkpoint_manager->module~m_solver module~m_checkpoint_manager->module~m_config module~m_checkpoint_manager->mpi module~m_checkpoint_manager->module~m_io_session module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_base m_io_base module~m_io_session->module~m_io_base module~m_snapshot_manager->module~m_common module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_config module~m_snapshot_manager->mpi module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->module~m_io_field_utils module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_solver module~m_io_field_utils->module~m_io_base Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_case_tgv~~UsedByGraph module~m_case_tgv m_case_tgv program~xcompact xcompact program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface case_tgv_t public  function case_tgv_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_tgv_t ) Derived Types type, public, extends( base_case_t ) :: case_tgv_t Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr Constructor public\n\n                    \n                    function case_tgv_init (backend, mesh, host_allocator) Type-Bound Procedures procedure, public :: case_init procedure, public :: case_finalise procedure, public :: set_init procedure, public :: run procedure, public :: print_enstrophy procedure, public :: print_div_max_mean procedure, public :: boundary_conditions => boundary_conditions_tgv procedure, public :: initial_conditions => initial_conditions_tgv procedure, public :: forcings => forcings_tgv procedure, public :: pre_correction => pre_correction_tgv procedure, public :: postprocess => postprocess_tgv Functions public  function case_tgv_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_tgv_t ) public pure function u_func (coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) public pure function v_func (coords) result(r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (3) Return Value real(kind=dp) Subroutines public  subroutine initial_conditions_tgv (self) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self public  subroutine boundary_conditions_tgv (self) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self public  subroutine forcings_tgv (self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter public  subroutine pre_correction_tgv (self, u, v, w) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w public  subroutine postprocess_tgv (self, iter, t) Arguments Type Intent Optional Attributes Name class( case_tgv_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t","tags":"","url":"module/m_case_tgv.html"},{"title":"m_omp_poisson_fft – x3d2","text":"Uses m_tdsops m_field m_mesh m_omp_spectral decomp_2d_fft decomp_2d_constants m_common m_poisson_fft module~~m_omp_poisson_fft~~UsesGraph module~m_omp_poisson_fft m_omp_poisson_fft decomp_2d_constants decomp_2d_constants module~m_omp_poisson_fft->decomp_2d_constants decomp_2d_fft decomp_2d_fft module~m_omp_poisson_fft->decomp_2d_fft module~m_common m_common module~m_omp_poisson_fft->module~m_common module~m_field m_field module~m_omp_poisson_fft->module~m_field module~m_mesh m_mesh module~m_omp_poisson_fft->module~m_mesh module~m_omp_spectral m_omp_spectral module~m_omp_poisson_fft->module~m_omp_spectral module~m_poisson_fft m_poisson_fft module~m_omp_poisson_fft->module~m_poisson_fft module~m_tdsops m_tdsops module~m_omp_poisson_fft->module~m_tdsops mpi mpi module~m_common->mpi module~m_field->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field iso_fortran_env iso_fortran_env module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_mesh->mpi module~m_omp_spectral->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_omp_poisson_fft~~UsedByGraph module~m_omp_poisson_fft m_omp_poisson_fft proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface omp_poisson_fft_t private  function init(mesh, xdirps, ydirps, zdirps, lowmem) result(poisson_fft) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(in) :: mesh class( dirps_t ), intent(in) :: xdirps class( dirps_t ), intent(in) :: ydirps class( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem Return Value type( omp_poisson_fft_t ) Derived Types type, public, extends( poisson_fft_t ) :: omp_poisson_fft_t FFT based Poisson solver Components Type Visibility Attributes Name Initial type( mesh_t ), public, pointer :: mesh => null() integer, public :: nx_glob Global dimensions integer, public :: ny_glob Global dimensions integer, public :: nz_glob Global dimensions integer, public :: nx_loc Local dimensions integer, public :: ny_loc Local dimensions integer, public :: nz_loc Local dimensions integer, public :: nx_perm Local dimensions in the permuted slabs integer, public :: ny_perm Local dimensions in the permuted slabs integer, public :: nz_perm Local dimensions in the permuted slabs integer, public :: nx_spec Local dimensions in the permuted slabs in spectral space integer, public :: ny_spec Local dimensions in the permuted slabs in spectral space integer, public :: nz_spec Local dimensions in the permuted slabs in spectral space integer, public :: x_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: y_sp_st Offset in y and z directions in the permuted slabs in spectral space integer, public :: z_sp_st Offset in y and z directions in the permuted slabs in spectral space complex(kind=dp), public, allocatable, dimension(:, :, :) :: waves Local domain sized array storing the spectral equivalence constants real(kind=dp), public, allocatable, dimension(:) :: ax Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bx Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: ay Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: by Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: az Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: bz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kx Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ky Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: kz Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: exs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: eys Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: ezs Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2x Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2y Wave numbers in x, y, and z complex(kind=dp), public, allocatable, dimension(:) :: k2z Wave numbers in x, y, and z real(kind=dp), public, allocatable, dimension(:) :: trans_x_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_x_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_y_im Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_re Staggared grid transformation real(kind=dp), public, allocatable, dimension(:) :: trans_z_im Staggared grid transformation logical, public :: periodic_x Periodicity in x, y, and z logical, public :: periodic_y Periodicity in x, y, and z logical, public :: periodic_z Periodicity in x, y, and z logical, public :: stretched_y = .false. Periodicity in x, y, and z logical, public :: stretched_y_sym Periodicity in x, y, and z real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_odd_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_even_im Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_re Stretching operator matrices real(kind=dp), public, allocatable, dimension(:, :, :, :) :: a_im Stretching operator matrices logical, public :: lowmem = .false. lowmem option, only used in CUDA backend procedure( poisson_xxx ), public, pointer :: poisson => null() Procedure pointer to BC specific poisson solvers complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_x complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_y complex(kind=dp), public, allocatable, dimension(:, :, :) :: c_z Constructor private\n\n                    \n                    function init (mesh, xdirps, ydirps, zdirps, lowmem) Type-Bound Procedures procedure, public :: base_init procedure, public :: solve_poisson procedure, public :: stretching_matrix procedure, public :: waves_set procedure, public :: get_km procedure, public :: get_km_re procedure, public :: get_km_im procedure, public :: fft_forward => fft_forward_omp procedure, public :: fft_forward_010 => fft_forward_omp procedure, public :: fft_forward_100 => fft_forward_100_omp procedure, public :: fft_forward_110 => fft_forward_110_omp procedure, public :: fft_backward => fft_backward_omp procedure, public :: fft_backward_010 => fft_backward_omp procedure, public :: fft_backward_100 => fft_backward_100_omp procedure, public :: fft_backward_110 => fft_backward_110_omp procedure, public :: fft_postprocess_000 => fft_postprocess_000_omp procedure, public :: fft_postprocess_010 => fft_postprocess_010_omp procedure, public :: fft_postprocess_100 => fft_postprocess_100_omp procedure, public :: fft_postprocess_110 => fft_postprocess_110_omp procedure, public :: enforce_periodicity_x => enforce_periodicity_x_omp procedure, public :: undo_periodicity_x => undo_periodicity_x_omp procedure, public :: enforce_periodicity_y => enforce_periodicity_y_omp procedure, public :: undo_periodicity_y => undo_periodicity_y_omp Subroutines public  subroutine fft_forward_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in public  subroutine fft_forward_010_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in public  subroutine fft_forward_100_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in public  subroutine fft_forward_110_omp (self, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(in) :: f_in public  subroutine fft_backward_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out public  subroutine fft_backward_010_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out public  subroutine fft_backward_100_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out public  subroutine fft_backward_110_omp (self, f_out) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out public  subroutine fft_postprocess_000_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self public  subroutine fft_postprocess_010_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self public  subroutine fft_postprocess_100_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self public  subroutine fft_postprocess_110_omp (self) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self public  subroutine enforce_periodicity_x_omp (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in public  subroutine undo_periodicity_x_omp (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in public  subroutine enforce_periodicity_y_omp (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in public  subroutine undo_periodicity_y_omp (self, f_out, f_in) Arguments Type Intent Optional Attributes Name class( omp_poisson_fft_t ) :: self class( field_t ), intent(inout) :: f_out class( field_t ), intent(in) :: f_in","tags":"","url":"module/m_omp_poisson_fft.html"},{"title":"m_cuda_kernels_reorder – x3d2","text":"Uses m_common cudafor m_cuda_common module~~m_cuda_kernels_reorder~~UsesGraph module~m_cuda_kernels_reorder m_cuda_kernels_reorder cudafor cudafor module~m_cuda_kernels_reorder->cudafor module~m_common m_common module~m_cuda_kernels_reorder->module~m_common module~m_cuda_common m_cuda_common module~m_cuda_kernels_reorder->module~m_cuda_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_kernels_reorder~~UsedByGraph module~m_cuda_kernels_reorder m_cuda_kernels_reorder module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_kernels_reorder program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine reorder_c2x (u_x, u_c, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_c integer, intent(in), value :: nz public  subroutine reorder_x2c (u_c, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_c real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_x2y (u_y, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_x2z (u_z, u_x, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_x integer, intent(in), value :: nz public  subroutine reorder_y2x (u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz public  subroutine reorder_y2z (u_z, u_y, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_z real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nx integer, intent(in), value :: nz public  subroutine reorder_z2x (u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz public  subroutine reorder_z2y (u_y, u_z, nx, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_y real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nx integer, intent(in), value :: nz public  subroutine sum_yintox (u_x, u_y, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_y integer, intent(in), value :: nz public  subroutine sum_zintox (u_x, u_z, nz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: u_x real(kind=dp), intent(in), device, dimension(:, :, :) :: u_z integer, intent(in), value :: nz","tags":"","url":"module/m_cuda_kernels_reorder.html"},{"title":"m_ibm – x3d2","text":"This module implements the IBM capabilities. When iibm = 0, the IBM object is never used. When iibm = 1, the basic IBM capability is used.\nIt only requires ep1, a 3D field, as input.\nThis field should be one (zero) in the fluid (solid)\ndomain. Uses m_field iso_fortran_env m_mesh m_allocator mpi m_base_backend m_io_session m_common module~~m_ibm~~UsesGraph module~m_ibm m_ibm iso_fortran_env iso_fortran_env module~m_ibm->iso_fortran_env module~m_allocator m_allocator module~m_ibm->module~m_allocator module~m_base_backend m_base_backend module~m_ibm->module~m_base_backend module~m_common m_common module~m_ibm->module~m_common module~m_field m_field module~m_ibm->module~m_field module~m_io_session m_io_session module~m_ibm->module~m_io_session module~m_mesh m_mesh module~m_ibm->module~m_mesh mpi mpi module~m_ibm->mpi module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_base_backend->mpi module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops module~m_common->mpi module~m_field->module~m_common module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_base m_io_base module~m_io_session->module~m_io_base module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_ibm~~UsedByGraph module~m_ibm m_ibm module~m_solver m_solver module~m_solver->module~m_ibm module~m_base_case m_base_case module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_solver module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: iibm_basic = 1 Interfaces public        interface ibm_t private  function init(backend, mesh, host_allocator) result(ibm) Initialize the basic IBM Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( ibm_t ) Derived Types type, public :: ibm_t Components Type Visibility Attributes Name Initial class( base_backend_t ), public, pointer :: backend => null() class( mesh_t ), public, pointer :: mesh => null() type( allocator_t ), public, pointer :: host_allocator => null() integer, public :: iibm = 0 class( field_t ), public, pointer :: ep1 => null() Constructor private\n\n                    \n                    function init (backend, mesh, host_allocator) Initialize the basic IBM Type-Bound Procedures procedure, public :: body","tags":"","url":"module/m_ibm.html"},{"title":"m_base_backend – x3d2","text":"Uses m_tdsops m_field m_mesh m_allocator mpi m_common m_poisson_fft module~~m_base_backend~~UsesGraph module~m_base_backend m_base_backend module~m_allocator m_allocator module~m_base_backend->module~m_allocator module~m_common m_common module~m_base_backend->module~m_common module~m_field m_field module~m_base_backend->module~m_field module~m_mesh m_mesh module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops mpi mpi module~m_base_backend->mpi module~m_allocator->module~m_common module~m_allocator->module~m_field iso_fortran_env iso_fortran_env module~m_allocator->iso_fortran_env module~m_common->mpi module~m_field->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh->iso_fortran_env module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_base_backend~~UsedByGraph module~m_base_backend m_base_backend module~m_base_case m_base_case module~m_base_case->module~m_base_backend module~m_solver m_solver module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_base_case module~m_case_channel->module~m_solver module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_base_case module~m_case_cylinder->module~m_solver module~m_case_generic m_case_generic module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_base_case module~m_case_generic->module~m_solver module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_base_case module~m_case_tgv->module~m_solver module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_base_backend module~m_ibm m_ibm module~m_ibm->module~m_base_backend module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_base_backend module~m_solver->module~m_base_backend module~m_solver->module~m_ibm module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_base_backend program~xcompact xcompact program~xcompact->module~m_base_backend program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv program~xcompact->module~m_cuda_backend program~xcompact->module~m_omp_backend module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public  subroutine transeq_ders(self, du, dv, dw, u, v, w, nu, dirps) transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps abstract interface public  subroutine transeq_ders_spec(self, dspec, uvw, spec, nu, dirps, sync) transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to transeq_ders into\nthe correct algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync abstract interface public  subroutine tds_solve(self, du, u, tdsops) transeq equation obtains the derivatives direction by\ndirection, and the exact algorithm used to obtain these\nderivatives are decided at runtime. Backend implementations\nare responsible from directing calls to tds_solve to the\ncorrect algorithm. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops abstract interface public  subroutine reorder(self, u_, u, direction) reorder subroutines are straightforward, they rearrange\ndata into our specialist data structure so that regardless\nof the direction tridiagonal systems are solved efficiently\nand fast. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u_ class( field_t ), intent(in) :: u integer, intent(in) :: direction abstract interface public  subroutine sum_intox(self, u, u_) sum9into3 subroutine combines all the directional velocity\nderivatives into the corresponding x directional fields. Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_ abstract interface public  subroutine veccopy(self, dst, src) copy vectors: y = x Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src abstract interface public  subroutine vecadd(self, a, x, b, y) adds two vectors together: y = a x + b y Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y abstract interface public  subroutine vecmult(self, y, x) pointwise multiplication between two vectors: y(:) = y(:) * x(:) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x abstract interface public  function scalar_product(self, x, y) result(s) Calculates the scalar product of two input fields Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) abstract interface public  subroutine field_ops(self, f, a) Scales or shifts a field by a Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a abstract interface public  function field_reduce(self, f) result(s) Reduces field to a scalar, example: volume integral Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) abstract interface public  subroutine field_max_mean(self, max_val, mean_val, f, enforced_data_loc) Obtains maximum and mean values in a field Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc abstract interface public  subroutine field_set_face(self, f, c_start, c_end, face) A field is a subdomain with a rectangular cuboid shape.\nIt has 6 faces, and these faces are either a subdomain boundary\nor a global domain boundary based on the location of the subdomain.\nThis subroutine allows us to set any of these faces to a value,\n'c_start' and 'c_end' for faces at opposite sides.\n'face' is one of X_FACE, Y_FACE, Z_FACE from common.f90 Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face abstract interface public  subroutine copy_data_to_f(self, f, data) Copy the specialist data structure from device or host back\nto a regular 3D data array in host memory. Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in), dimension(:, :, :) :: data abstract interface public  subroutine copy_f_to_data(self, data, f) Copy a regular 3D array in host memory into the specialist\ndata structure field that lives on device or host Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f abstract interface public  subroutine alloc_tdsops(self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu abstract interface public  subroutine init_poisson_fft(self, mesh, xdirps, ydirps, zdirps, lowmem) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem Derived Types type, public, abstract :: base_backend_t base_backend class defines all the abstract operations that the\nsolver class requires. Read more… Components Type Visibility Attributes Name Initial integer, public :: n_halo = 4 DistD2 implementation is hardcoded for 4 halo layers for all backends type( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft Type-Bound Procedures procedure( transeq_ders ), public, deferred :: transeq_x procedure( transeq_ders ), public, deferred :: transeq_y procedure( transeq_ders ), public, deferred :: transeq_z procedure( transeq_ders_spec ), public, deferred :: transeq_species procedure( tds_solve ), public, deferred :: tds_solve procedure( reorder ), public, deferred :: reorder procedure( sum_intox ), public, deferred :: sum_yintox procedure( sum_intox ), public, deferred :: sum_zintox procedure( veccopy ), public, deferred :: veccopy procedure( vecadd ), public, deferred :: vecadd procedure( vecmult ), public, deferred :: vecmult procedure( scalar_product ), public, deferred :: scalar_product procedure( field_max_mean ), public, deferred :: field_max_mean procedure( field_ops ), public, deferred :: field_scale procedure( field_ops ), public, deferred :: field_shift procedure( field_reduce ), public, deferred :: field_volume_integral procedure( field_set_face ), public, deferred :: field_set_face procedure( copy_data_to_f ), public, deferred :: copy_data_to_f procedure( copy_f_to_data ), public, deferred :: copy_f_to_data procedure( alloc_tdsops ), public, deferred :: alloc_tdsops procedure( init_poisson_fft ), public, deferred :: init_poisson_fft procedure, public :: base_init procedure, public :: get_field_data procedure, public :: set_field_data Subroutines public  subroutine base_init (self) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self public  subroutine get_field_data (self, data, f, dir) Extract data from field f optionally reordering into dir orientation.\nTo output in same orientation as f , use call ...%get_field_data(data, f, f%dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data Output array class( field_t ), intent(in) :: f Field integer, intent(in), optional :: dir Desired orientation of output array (defaults to Cartesian) public  subroutine set_field_data (self, f, data, dir) Arguments Type Intent Optional Attributes Name class( base_backend_t ) :: self class( field_t ), intent(inout) :: f Field real(kind=dp), intent(in), dimension(:, :, :) :: data Input array integer, intent(in), optional :: dir Orientation of input array (defaults to Cartesian)","tags":"","url":"module/m_base_backend.html"},{"title":"m_field – x3d2","text":"Uses m_common module~~m_field~~UsesGraph module~m_field m_field module~m_common m_common module~m_field->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_field~~UsedByGraph module~m_field m_field module~m_allocator m_allocator module~m_allocator->module~m_field module~m_base_backend m_base_backend module~m_base_backend->module~m_field module~m_base_backend->module~m_allocator module~m_mesh m_mesh module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_base_case m_base_case module~m_base_case->module~m_field module~m_base_case->module~m_allocator module~m_base_case->module~m_base_backend module~m_base_case->module~m_mesh module~m_solver m_solver module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_field module~m_case_cylinder->module~m_allocator module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_base_case module~m_case_cylinder->module~m_mesh module~m_case_cylinder->module~m_solver module~m_case_generic m_case_generic module~m_case_generic->module~m_field module~m_case_generic->module~m_allocator module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_base_case module~m_case_generic->module~m_mesh module~m_case_generic->module~m_solver module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_field module~m_case_tgv->module~m_allocator module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_base_case module~m_case_tgv->module~m_mesh module~m_case_tgv->module~m_solver module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_field module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_checkpoint_manager->module~m_solver module~m_cuda_allocator m_cuda_allocator module~m_cuda_allocator->module~m_field module~m_cuda_allocator->module~m_allocator module~m_cuda_allocator->module~m_mesh module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_field module~m_cuda_backend->module~m_allocator module~m_cuda_backend->module~m_base_backend module~m_cuda_backend->module~m_cuda_allocator module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_cuda_backend->module~m_mesh module~m_cuda_poisson_fft->module~m_field module~m_cuda_poisson_fft->module~m_cuda_allocator module~m_cuda_poisson_fft->module~m_mesh module~m_cuda_poisson_fft->module~m_poisson_fft module~m_ibm m_ibm module~m_ibm->module~m_field module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_mesh module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_solver module~m_mesh->module~m_field module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_field module~m_omp_backend->module~m_allocator module~m_omp_backend->module~m_base_backend module~m_omp_backend->module~m_mesh module~m_omp_poisson_fft m_omp_poisson_fft module~m_omp_poisson_fft->module~m_field module~m_omp_poisson_fft->module~m_mesh module~m_omp_poisson_fft->module~m_poisson_fft module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_snapshot_manager m_snapshot_manager module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_io_field_utils module~m_snapshot_manager->module~m_solver module~m_solver->module~m_field module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_ibm module~m_solver->module~m_mesh module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_time_integrator->module~m_field module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_case_channel m_case_channel module~m_case_channel->module~m_allocator module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_base_case module~m_case_channel->module~m_mesh module~m_case_channel->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_io_manager->module~m_snapshot_manager module~m_io_manager->module~m_solver proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft program~xcompact xcompact program~xcompact->module~m_allocator program~xcompact->module~m_base_backend program~xcompact->module~m_base_case program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv program~xcompact->module~m_cuda_allocator program~xcompact->module~m_cuda_backend program~xcompact->module~m_mesh program~xcompact->module~m_omp_backend program~xcompact->module~m_case_channel Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface field_t public  function field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) Derived Types type, public :: field_t Memory block type holding both a data field and a pointer\nto the next block.  The field_t type also holds a integer refcount that counts the number of references to this\nfield.  User code is currently responsible for incrementing\nthe reference count. Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: next real(kind=dp), public, pointer, contiguous :: data (:,:,:) integer, public :: dir integer, public :: data_loc integer, public :: refcount = 0 integer, public :: id An integer identifying the memory block. Constructor public\n\n                    \n                    function field_init (ngrid, next, id) Type-Bound Procedures procedure, public :: fill procedure, public :: get_shape procedure, public :: set_shape procedure, public :: set_data_loc type, public :: flist_t Use for creating a list of field pointers Components Type Visibility Attributes Name Initial class( field_t ), public, pointer :: ptr Functions public  function field_init (ngrid, next, id) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngrid type( field_t ), intent(in), pointer :: next integer, intent(in) :: id Return Value type( field_t ) public  function get_shape (self) result(dims) Arguments Type Intent Optional Attributes Name class( field_t ) :: self Return Value integer, (3) Subroutines public  subroutine fill (self, c) Arguments Type Intent Optional Attributes Name class( field_t ) :: self real(kind=dp), intent(in) :: c public  subroutine set_data_loc (self, data_loc) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: data_loc public  subroutine set_shape (self, dims) Arguments Type Intent Optional Attributes Name class( field_t ) :: self integer, intent(in) :: dims (3)","tags":"","url":"module/m_field.html"},{"title":"m_exec_thom – x3d2","text":"Uses m_common m_omp_kernels_thom m_tdsops module~~m_exec_thom~~UsesGraph module~m_exec_thom m_exec_thom module~m_common m_common module~m_exec_thom->module~m_common module~m_omp_kernels_thom m_omp_kernels_thom module~m_exec_thom->module~m_omp_kernels_thom module~m_tdsops m_tdsops module~m_exec_thom->module~m_tdsops mpi mpi module~m_common->mpi module~m_omp_kernels_thom->module~m_common module~m_omp_common m_omp_common module~m_omp_kernels_thom->module~m_omp_common module~m_tdsops->module~m_common iso_fortran_env iso_fortran_env module~m_tdsops->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine exec_thom_tds_compact (du, u, tdsops, n_groups) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:, :, :) :: du real(kind=dp), intent(in), dimension(:, :, :) :: u type( tdsops_t ), intent(in) :: tdsops integer, intent(in) :: n_groups","tags":"","url":"module/m_exec_thom.html"},{"title":"m_case_cylinder – x3d2","text":"An example case set up to run a cylinder flow. Uses m_base_case m_field m_config iso_fortran_env m_mesh m_solver m_allocator m_base_backend m_common module~~m_case_cylinder~~UsesGraph module~m_case_cylinder m_case_cylinder iso_fortran_env iso_fortran_env module~m_case_cylinder->iso_fortran_env module~m_allocator m_allocator module~m_case_cylinder->module~m_allocator module~m_base_backend m_base_backend module~m_case_cylinder->module~m_base_backend module~m_base_case m_base_case module~m_case_cylinder->module~m_base_case module~m_common m_common module~m_case_cylinder->module~m_common module~m_config m_config module~m_case_cylinder->module~m_config module~m_field m_field module~m_case_cylinder->module~m_field module~m_mesh m_mesh module~m_case_cylinder->module~m_mesh module~m_solver m_solver module~m_case_cylinder->module~m_solver module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops mpi mpi module~m_base_backend->mpi module~m_base_case->module~m_allocator module~m_base_case->module~m_base_backend module~m_base_case->module~m_common module~m_base_case->module~m_field module~m_base_case->module~m_mesh module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_base_case->mpi module~m_common->mpi module~m_config->iso_fortran_env module~m_config->module~m_common module~m_field->module~m_common module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_mesh->mpi module~m_solver->iso_fortran_env module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_common module~m_solver->module~m_config module~m_solver->module~m_field module~m_solver->module~m_mesh module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_solver->module~m_tdsops module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_solver->mpi module~m_ibm->iso_fortran_env module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_common module~m_ibm->module~m_field module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_io_session m_io_session module~m_ibm->module~m_io_session module~m_io_manager->module~m_solver module~m_checkpoint_manager m_checkpoint_manager module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_tdsops module~m_checkpoint_manager->module~m_common module~m_checkpoint_manager->module~m_config module~m_checkpoint_manager->module~m_field module~m_checkpoint_manager->module~m_solver module~m_checkpoint_manager->mpi module~m_checkpoint_manager->module~m_io_session module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_base m_io_base module~m_io_session->module~m_io_base module~m_snapshot_manager->module~m_common module~m_snapshot_manager->module~m_config module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->mpi module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->module~m_io_field_utils module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_common module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_solver module~m_io_field_utils->module~m_io_base Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_case_cylinder~~UsedByGraph module~m_case_cylinder m_case_cylinder program~xcompact xcompact program~xcompact->module~m_case_cylinder Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface case_cylinder_t public  function case_cylinder_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_cylinder_t ) Derived Types type, public, extends( base_case_t ) :: case_cylinder_t Components Type Visibility Attributes Name Initial class( solver_t ), public, allocatable :: solver type( io_manager_t ), public :: checkpoint_mgr type( cylinder_config_t ), public :: cylinder_cfg Constructor public\n\n                    \n                    function case_cylinder_init (backend, mesh, host_allocator) Type-Bound Procedures procedure, public :: case_init procedure, public :: case_finalise procedure, public :: set_init procedure, public :: run procedure, public :: print_enstrophy procedure, public :: print_div_max_mean procedure, public :: boundary_conditions => boundary_conditions_cylinder procedure, public :: initial_conditions => initial_conditions_cylinder procedure, public :: forcings => forcings_cylinder procedure, public :: pre_correction => pre_correction_cylinder procedure, public :: postprocess => postprocess_cylinder Functions public  function case_cylinder_init (backend, mesh, host_allocator) result(flow_case) Arguments Type Intent Optional Attributes Name class( base_backend_t ), intent(inout), target :: backend type( mesh_t ), intent(inout), target :: mesh type( allocator_t ), intent(inout), target :: host_allocator Return Value type( case_cylinder_t ) Subroutines public  subroutine boundary_conditions_cylinder (self) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self public  subroutine initial_conditions_cylinder (self) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self public  subroutine forcings_cylinder (self, du, dv, dw, iter) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw integer, intent(in) :: iter public  subroutine pre_correction_cylinder (self, u, v, w) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(inout) :: v class( field_t ), intent(inout) :: w public  subroutine postprocess_cylinder (self, iter, t) Arguments Type Intent Optional Attributes Name class( case_cylinder_t ) :: self integer, intent(in) :: iter real(kind=dp), intent(in) :: t","tags":"","url":"module/m_case_cylinder.html"},{"title":"m_decomp – x3d2","text":"Dummy implementation of the decomposition to be linked against when 2decomp&fft isn't available. Functions public  function is_avail_2decomp () result(avail) Arguments None Return Value logical Subroutines public  subroutine decomposition_2decomp (grid, par) Arguments Type Intent Optional Attributes Name class( grid_t ), intent(inout) :: grid class( par_t ), intent(inout) :: par","tags":"","url":"module/m_decomp.html"},{"title":"m_cuda_backend – x3d2","text":"Uses m_tdsops cudafor m_field m_cuda_kernels_fieldops m_cuda_kernels_reorder iso_fortran_env m_mesh m_cuda_allocator m_cuda_sendrecv m_cuda_common m_allocator m_cuda_exec_dist mpi m_cuda_tdsops m_base_backend m_cuda_poisson_fft m_common m_cuda_kernels_dist module~~m_cuda_backend~~UsesGraph module~m_cuda_backend m_cuda_backend cudafor cudafor module~m_cuda_backend->cudafor iso_fortran_env iso_fortran_env module~m_cuda_backend->iso_fortran_env module~m_allocator m_allocator module~m_cuda_backend->module~m_allocator module~m_base_backend m_base_backend module~m_cuda_backend->module~m_base_backend module~m_common m_common module~m_cuda_backend->module~m_common module~m_cuda_allocator m_cuda_allocator module~m_cuda_backend->module~m_cuda_allocator module~m_cuda_common m_cuda_common module~m_cuda_backend->module~m_cuda_common module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend->module~m_cuda_exec_dist module~m_cuda_kernels_dist m_cuda_kernels_dist module~m_cuda_backend->module~m_cuda_kernels_dist module~m_cuda_kernels_fieldops m_cuda_kernels_fieldops module~m_cuda_backend->module~m_cuda_kernels_fieldops module~m_cuda_kernels_reorder m_cuda_kernels_reorder module~m_cuda_backend->module~m_cuda_kernels_reorder module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_cuda_sendrecv m_cuda_sendrecv module~m_cuda_backend->module~m_cuda_sendrecv module~m_cuda_tdsops m_cuda_tdsops module~m_cuda_backend->module~m_cuda_tdsops module~m_field m_field module~m_cuda_backend->module~m_field module~m_mesh m_mesh module~m_cuda_backend->module~m_mesh module~m_tdsops m_tdsops module~m_cuda_backend->module~m_tdsops mpi mpi module~m_cuda_backend->mpi module~m_allocator->iso_fortran_env module~m_allocator->module~m_common module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_base_backend->module~m_mesh module~m_base_backend->module~m_tdsops module~m_base_backend->mpi module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_common->mpi module~m_cuda_allocator->module~m_allocator module~m_cuda_allocator->module~m_common module~m_cuda_allocator->module~m_field module~m_cuda_allocator->module~m_mesh module~m_cuda_exec_dist->cudafor module~m_cuda_exec_dist->module~m_common module~m_cuda_exec_dist->module~m_cuda_common module~m_cuda_exec_dist->module~m_cuda_kernels_dist module~m_cuda_exec_dist->module~m_cuda_sendrecv module~m_cuda_exec_dist->module~m_cuda_tdsops module~m_cuda_exec_dist->mpi module~m_cuda_kernels_dist->cudafor module~m_cuda_kernels_dist->module~m_common module~m_cuda_kernels_fieldops->cudafor module~m_cuda_kernels_fieldops->module~m_common module~m_cuda_kernels_fieldops->module~m_cuda_common module~m_cuda_kernels_reorder->cudafor module~m_cuda_kernels_reorder->module~m_common module~m_cuda_kernels_reorder->module~m_cuda_common module~m_cuda_poisson_fft->cudafor module~m_cuda_poisson_fft->iso_fortran_env module~m_cuda_poisson_fft->module~m_common module~m_cuda_poisson_fft->module~m_cuda_allocator module~m_cuda_poisson_fft->module~m_field module~m_cuda_poisson_fft->module~m_mesh module~m_cuda_poisson_fft->module~m_tdsops module~m_cuda_poisson_fft->mpi cufft cufft module~m_cuda_poisson_fft->cufft cufftXt cufftXt module~m_cuda_poisson_fft->cufftXt iso_c_binding iso_c_binding module~m_cuda_poisson_fft->iso_c_binding module~m_cuda_spectral m_cuda_spectral module~m_cuda_poisson_fft->module~m_cuda_spectral module~m_cuda_poisson_fft->module~m_poisson_fft module~m_cuda_sendrecv->cudafor module~m_cuda_sendrecv->module~m_common module~m_cuda_sendrecv->mpi module~m_cuda_tdsops->iso_fortran_env module~m_cuda_tdsops->module~m_common module~m_cuda_tdsops->module~m_tdsops module~m_field->module~m_common module~m_mesh->iso_fortran_env module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->mpi module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_tdsops->iso_fortran_env module~m_tdsops->module~m_common module~m_cuda_spectral->cudafor module~m_cuda_spectral->module~m_common module~m_mesh_content->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_backend~~UsedByGraph module~m_cuda_backend m_cuda_backend program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface cuda_backend_t public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) Derived Types type, public, extends( base_backend_t ) :: cuda_backend_t Components Type Visibility Attributes Name Initial integer, public :: n_halo = 4 DistD2 implementation is hardcoded for 4 halo layers for all backends type( mesh_t ), public, pointer :: mesh class( allocator_t ), public, pointer :: allocator class( poisson_fft_t ), public, pointer :: poisson_fft real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: v_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: w_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: du_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: dud_recv_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_send_e_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_s_dev real(kind=dp), public, device, allocatable, dimension(:, :, :) :: d2u_recv_e_dev type(dim3), public :: xblocks type(dim3), public :: xthreads type(dim3), public :: yblocks type(dim3), public :: ythreads type(dim3), public :: zblocks type(dim3), public :: zthreads Constructor public\n\n                    \n                    function init (mesh, allocator) Type-Bound Procedures procedure, public :: base_init procedure, public :: get_field_data procedure, public :: set_field_data procedure, public :: alloc_tdsops => alloc_cuda_tdsops procedure, public :: transeq_x => transeq_x_cuda procedure, public :: transeq_y => transeq_y_cuda procedure, public :: transeq_z => transeq_z_cuda procedure, public :: transeq_species => transeq_species_cuda procedure, public :: tds_solve => tds_solve_cuda procedure, public :: reorder => reorder_cuda procedure, public :: sum_yintox => sum_yintox_cuda procedure, public :: sum_zintox => sum_zintox_cuda procedure, public :: veccopy => veccopy_cuda procedure, public :: vecadd => vecadd_cuda procedure, public :: vecmult => vecmult_cuda procedure, public :: scalar_product => scalar_product_cuda procedure, public :: field_max_mean => field_max_mean_cuda procedure, public :: field_scale => field_scale_cuda procedure, public :: field_shift => field_shift_cuda procedure, public :: field_set_face => field_set_face_cuda procedure, public :: field_volume_integral => field_volume_integral_cuda procedure, public :: copy_data_to_f => copy_data_to_f_cuda procedure, public :: copy_f_to_data => copy_f_to_data_cuda procedure, public :: init_poisson_fft => init_cuda_poisson_fft procedure, public :: transeq_cuda_dist procedure, public :: transeq_cuda_thom procedure, public :: tds_solve_dist Functions public  function init (mesh, allocator) result(backend) Arguments Type Intent Optional Attributes Name type( mesh_t ), intent(inout), target :: mesh class( allocator_t ), intent(inout), target :: allocator Return Value type( cuda_backend_t ) public  function scalar_product_cuda (self, x, y) result(s) m_base_backend Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: x class( field_t ), intent(in) :: y Return Value real(kind=dp) public  function field_volume_integral_cuda (self, f) result(s) volume integral of a field Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f Return Value real(kind=dp) Subroutines public  subroutine alloc_cuda_tdsops (self, tdsops, n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( tdsops_t ), intent(inout), allocatable :: tdsops integer, intent(in) :: n_tds real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end real(kind=dp), intent(in), optional :: stretch (:) real(kind=dp), intent(in), optional :: stretch_correct (:) integer, intent(in), optional :: n_halo character(len=*), intent(in), optional :: from_to logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine transeq_x_cuda (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps public  subroutine transeq_y_cuda (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps public  subroutine transeq_z_cuda (self, du, dv, dw, u, v, w, nu, dirps) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps public  subroutine transeq_species_cuda (self, dspec, uvw, spec, nu, dirps, sync) Compute the convection and diffusion for the given field\nin the given direction.\nHalo exchange for the given field is necessary\nWhen sync is true, halo exchange of momentum is necessary Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: dspec class( field_t ), intent(in) :: uvw class( field_t ), intent(in) :: spec real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps logical, intent(in) :: sync public  subroutine transeq_cuda_dist (self, du, dv, dw, u, v, w, nu, dirps, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w real(kind=dp), intent(in) :: nu type( dirps_t ), intent(in) :: dirps type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine transeq_cuda_thom (self, du, dv, dw, u, v, w, dirps) Thomas algorithm implementation. So much more easier than the\ndistributed algorithm. It is intended to work only on a single rank\nso there is no MPI communication. Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(inout) :: dv class( field_t ), intent(inout) :: dw class( field_t ), intent(in) :: u class( field_t ), intent(in) :: v class( field_t ), intent(in) :: w type( dirps_t ), intent(in) :: dirps public  subroutine tds_solve_cuda (self, du, u, tdsops) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops public  subroutine tds_solve_dist (self, du, u, tdsops, blocks, threads) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: du class( field_t ), intent(in) :: u class( tdsops_t ), intent(in) :: tdsops type(dim3), intent(in) :: blocks type(dim3), intent(in) :: threads public  subroutine reorder_cuda (self, u_o, u_i, direction) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u_o class( field_t ), intent(in) :: u_i integer, intent(in) :: direction public  subroutine sum_yintox_cuda (self, u, u_y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_y public  subroutine sum_zintox_cuda (self, u, u_z) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: u class( field_t ), intent(in) :: u_z public  subroutine veccopy_cuda (self, dst, src) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: dst class( field_t ), intent(in) :: src public  subroutine vecadd_cuda (self, a, x, b, y) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(in) :: a class( field_t ), intent(in) :: x real(kind=dp), intent(in) :: b class( field_t ), intent(inout) :: y public  subroutine vecmult_cuda (self, y, x) m_base_backend Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: y class( field_t ), intent(in) :: x public  subroutine copy_into_buffers (u_send_s_dev, u_send_e_dev, u_dev, n) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_s_dev real(kind=dp), intent(out), device, dimension(:, :, :) :: u_send_e_dev real(kind=dp), intent(in), device, dimension(:, :, :) :: u_dev integer, intent(in) :: n public  subroutine field_max_mean_cuda (self, max_val, mean_val, f, enforced_data_loc) m_base_backend Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self real(kind=dp), intent(out) :: max_val real(kind=dp), intent(out) :: mean_val class( field_t ), intent(in) :: f integer, intent(in), optional :: enforced_data_loc public  subroutine field_scale_cuda (self, f, a) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a public  subroutine field_shift_cuda (self, f, a) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(in) :: f real(kind=dp), intent(in) :: a public  subroutine field_set_face_cuda (self, f, c_start, c_end, face) m_base_backend Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(in) :: c_start real(kind=dp), intent(in) :: c_end integer, intent(in) :: face public  subroutine copy_data_to_f_cuda (self, f, data) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self class( field_t ), intent(inout) :: f real(kind=dp), intent(inout), dimension(:, :, :) :: data public  subroutine copy_f_to_data_cuda (self, data, f) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ), intent(inout) :: self real(kind=dp), intent(out), dimension(:, :, :) :: data class( field_t ), intent(in) :: f public  subroutine init_cuda_poisson_fft (self, mesh, xdirps, ydirps, zdirps, lowmem) Arguments Type Intent Optional Attributes Name class( cuda_backend_t ) :: self type( mesh_t ), intent(in) :: mesh type( dirps_t ), intent(in) :: xdirps type( dirps_t ), intent(in) :: ydirps type( dirps_t ), intent(in) :: zdirps logical, intent(in), optional :: lowmem public  subroutine resolve_field_t (u_dev, u) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, pointer, dimension(:, :, :) :: u_dev class( field_t ), intent(in) :: u","tags":"","url":"module/m_cuda_backend.html"},{"title":"m_tdsops – x3d2","text":"Uses iso_fortran_env m_common module~~m_tdsops~~UsesGraph module~m_tdsops m_tdsops iso_fortran_env iso_fortran_env module~m_tdsops->iso_fortran_env module~m_common m_common module~m_tdsops->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_tdsops~~UsedByGraph module~m_tdsops m_tdsops module~m_base_backend m_base_backend module~m_base_backend->module~m_tdsops module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_tdsops module~m_cuda_backend->module~m_base_backend module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_cuda_tdsops m_cuda_tdsops module~m_cuda_backend->module~m_cuda_tdsops module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend->module~m_cuda_exec_dist module~m_cuda_poisson_fft->module~m_tdsops module~m_cuda_poisson_fft->module~m_poisson_fft module~m_cuda_tdsops->module~m_tdsops module~m_exec_thom m_exec_thom module~m_exec_thom->module~m_tdsops module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_tdsops module~m_omp_backend->module~m_base_backend module~m_omp_exec_dist m_omp_exec_dist module~m_omp_backend->module~m_omp_exec_dist module~m_omp_exec_dist->module~m_tdsops module~m_omp_poisson_fft m_omp_poisson_fft module~m_omp_poisson_fft->module~m_tdsops module~m_omp_poisson_fft->module~m_poisson_fft module~m_poisson_fft->module~m_tdsops module~m_solver m_solver module~m_solver->module~m_tdsops module~m_solver->module~m_base_backend module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus->module~m_tdsops module~m_vector_calculus->module~m_base_backend module~m_base_case m_base_case module~m_base_case->module~m_base_backend module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_solver module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_cuda_exec_dist->module~m_cuda_tdsops module~m_cuda_exec_thom m_cuda_exec_thom module~m_cuda_exec_thom->module~m_cuda_tdsops module~m_ibm->module~m_base_backend module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils module~m_time_integrator->module~m_base_backend proc~init_omp_poisson_fft m_omp_backend::omp_backend_t%init_omp_poisson_fft proc~init_omp_poisson_fft->module~m_omp_poisson_fft program~xcompact xcompact program~xcompact->module~m_base_backend program~xcompact->module~m_cuda_backend program~xcompact->module~m_omp_backend program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface tdsops_t public  function tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. 'n_tds', 'delta', 'operation', 'scheme', 'bc_start', and 'bc_end' are\nnecessary arguments. The remaining arguments are optional. 'stretch' is for obtaining the correct derivations in a stretched mesh\n'stretch_correct' is for correcting the second derivative with the first 'from_to' is necessary for interpolation and staggared derivative, and\nit can be 'v2p' or 'p2v'.\nIf the specific region the instance is operating is not a boundary\nregion, then 'bc_start' and 'bc_end' are BC_HALO. 'sym' is relevant when the BC is free-slip. If sym is .true. then it\nmeans the field we operate on is assumed to be an even function\n(symmetric, cos type) accross the boundary. If it is .false. it means\nthe field is assumed to be an odd function (anti-symmetric, sin type). 'c_nu', 'nu0_nu' are relevant when operation is second order\nderivative and scheme is compact6-hyperviscous. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds Tridiagonal system size real(kind=dp), intent(in) :: delta Grid spacing character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start Boundary Cond. integer, intent(in) :: bc_end Boundary Cond. real(kind=dp), intent(in), optional :: stretch (:) Stretching coefficients real(kind=dp), intent(in), optional :: stretch_correct (:) Stretch correction integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Derived Types type, public :: tdsops_t Tridiagonal Solver Operators class. Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: dist_fw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_bw fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sa fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_sc fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: dist_af fw/bw phase\nback subs.\nthe auxiliary factors real(kind=dp), public, allocatable, dimension(:) :: thom_f real(kind=dp), public, allocatable, dimension(:) :: thom_s real(kind=dp), public, allocatable, dimension(:) :: thom_w real(kind=dp), public, allocatable, dimension(:) :: thom_p real(kind=dp), public, allocatable :: stretch (:) real(kind=dp), public, allocatable :: stretch_correct (:) real(kind=dp), public, allocatable :: coeffs (:) real(kind=dp), public, allocatable :: coeffs_s (:,:) real(kind=dp), public, allocatable :: coeffs_e (:,:) real(kind=dp), public :: alpha Compact scheme coeffs real(kind=dp), public :: a Compact scheme coeffs real(kind=dp), public :: b Compact scheme coeffs real(kind=dp), public :: c = 0._dp Compact scheme coeffs real(kind=dp), public :: d = 0._dp Compact scheme coeffs logical, public :: periodic integer, public :: n_tds Tridiagonal system size integer, public :: n_rhs Right-hand-side builder size integer, public :: move = 0 move between vertices and cell centres integer, public :: n_halo number of halo points Constructor public\n\n                    \n                    function tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) Constructor function for the tdsops_t class. Read more… Type-Bound Procedures procedure, public :: stagder_1st procedure, public :: interpl_mid procedure, public :: deriv_2nd procedure, public :: deriv_1st procedure, public :: preprocess_thom procedure, public :: preprocess_dist type, public :: dirps_t Directional tridiagonal solver container. Read more… Components Type Visibility Attributes Name Initial class( tdsops_t ), public, allocatable :: der1st class( tdsops_t ), public, allocatable :: der1st_sym class( tdsops_t ), public, allocatable :: der2nd class( tdsops_t ), public, allocatable :: der2nd_sym class( tdsops_t ), public, allocatable :: stagder_v2p class( tdsops_t ), public, allocatable :: stagder_p2v class( tdsops_t ), public, allocatable :: interpl_v2p class( tdsops_t ), public, allocatable :: interpl_p2v integer, public :: dir Functions public  function tdsops_init (n_tds, delta, operation, scheme, bc_start, bc_end, stretch, stretch_correct, n_halo, from_to, sym, c_nu, nu0_nu) result(tdsops) Constructor function for the tdsops_t class. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_tds Tridiagonal system size real(kind=dp), intent(in) :: delta Grid spacing character(len=*), intent(in) :: operation character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start Boundary Cond. integer, intent(in) :: bc_end Boundary Cond. real(kind=dp), intent(in), optional :: stretch (:) Stretching coefficients real(kind=dp), intent(in), optional :: stretch_correct (:) Stretch correction integer, intent(in), optional :: n_halo Number of halo cells character(len=*), intent(in), optional :: from_to 'v2p' or 'p2v' logical, intent(in), optional :: sym (==npaire), only for Neumann BCs real(kind=dp), intent(in), optional :: c_nu params for hypervisc. real(kind=dp), intent(in), optional :: nu0_nu params for hypervisc. Return Value type( tdsops_t ) return value of the function Subroutines public  subroutine deriv_1st (self, delta, scheme, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym public  subroutine deriv_2nd (self, delta, scheme, bc_start, bc_end, sym, c_nu, nu0_nu) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym real(kind=dp), intent(in), optional :: c_nu real(kind=dp), intent(in), optional :: nu0_nu public  subroutine interpl_mid (self, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym public  subroutine stagder_1st (self, delta, scheme, from_to, bc_start, bc_end, sym) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in) :: delta character(len=*), intent(in) :: scheme character(len=*), intent(in) :: from_to integer, intent(in) :: bc_start integer, intent(in) :: bc_end logical, intent(in), optional :: sym public  subroutine preprocess_dist (self, dist_b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: dist_b public  subroutine preprocess_thom (self, b) Arguments Type Intent Optional Attributes Name class( tdsops_t ), intent(inout) :: self real(kind=dp), intent(in), dimension(:) :: b","tags":"","url":"module/m_tdsops.html"},{"title":"m_time_integrator – x3d2","text":"Uses m_allocator m_field m_common m_base_backend module~~m_time_integrator~~UsesGraph module~m_time_integrator m_time_integrator module~m_allocator m_allocator module~m_time_integrator->module~m_allocator module~m_base_backend m_base_backend module~m_time_integrator->module~m_base_backend module~m_common m_common module~m_time_integrator->module~m_common module~m_field m_field module~m_time_integrator->module~m_field module~m_allocator->module~m_common module~m_allocator->module~m_field iso_fortran_env iso_fortran_env module~m_allocator->iso_fortran_env module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_field module~m_mesh m_mesh module~m_base_backend->module~m_mesh module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops mpi mpi module~m_base_backend->mpi module~m_common->mpi module~m_field->module~m_common module~m_mesh->module~m_common module~m_mesh->module~m_field module~m_mesh->iso_fortran_env module~m_mesh->mpi module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_tdsops module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_mesh_content->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_time_integrator~~UsedByGraph module~m_time_integrator m_time_integrator module~m_solver m_solver module~m_solver->module~m_time_integrator module~m_base_case m_base_case module~m_base_case->module~m_solver module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_case_channel m_case_channel module~m_case_channel->module~m_solver module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_field_utils->module~m_solver module~m_io_manager->module~m_solver module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface time_intg_t public  function init (backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in) :: nvars Return Value type( time_intg_t ) Abstract Interfaces abstract interface public  subroutine stepper_func(self, curr, deriv, dt) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self type( flist_t ), intent(inout) :: curr (:) type( flist_t ), intent(in) :: deriv (:) real(kind=dp), intent(in) :: dt Derived Types type, public :: time_intg_t Components Type Visibility Attributes Name Initial integer, public :: method integer, public :: istep integer, public :: istage integer, public :: order integer, public :: nstep integer, public :: nstage integer, public :: nvars integer, public :: nolds real(kind=dp), public :: coeffs (4,4) real(kind=dp), public :: rk_b (4,4) real(kind=dp), public :: rk_a (3,3,4) character(len=3), public :: sname type( flist_t ), public, allocatable :: olds (:,:) class( base_backend_t ), public, pointer :: backend class( allocator_t ), public, pointer :: allocator procedure( stepper_func ), public, pointer :: step => null() Constructor public\n\n                    \n                    function init (backend, allocator, method, nvars) Type-Bound Procedures procedure, public :: finalize procedure, public :: runge_kutta procedure, public :: adams_bashforth Functions public  function init (backend, allocator, method, nvars) Arguments Type Intent Optional Attributes Name class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator character(len=3), intent(in) :: method integer, intent(in) :: nvars Return Value type( time_intg_t ) Subroutines public  subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( time_intg_t ), intent(inout) :: self public  subroutine rotate (sol, n) Arguments Type Intent Optional Attributes Name type( flist_t ), intent(inout) :: sol (:) integer, intent(in) :: n","tags":"","url":"module/m_time_integrator.html"},{"title":"m_ordering – x3d2","text":"\"Application storage\" stores spatial data with a directionality for better cache locality\n This set of functions converts indices from this application storage (_dir) to cartesian indices (_ijk) Uses m_common module~~m_ordering~~UsesGraph module~m_ordering m_ordering module~m_common m_common module~m_ordering->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_ordering~~UsedByGraph module~m_ordering m_ordering module~m_omp_backend m_omp_backend module~m_omp_backend->module~m_ordering program~xcompact xcompact program~xcompact->module~m_omp_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public pure subroutine get_index_ijk (i, j, k, dir_i, dir_j, dir_k, dir, SZ, nx_padded, ny_padded, nz_padded) Get cartesian index from application storage directional one Arguments Type Intent Optional Attributes Name integer, intent(out) :: i integer, intent(out) :: j integer, intent(out) :: k integer, intent(in) :: dir_i integer, intent(in) :: dir_j integer, intent(in) :: dir_k integer, intent(in) :: dir integer, intent(in) :: SZ integer, intent(in) :: nx_padded integer, intent(in) :: ny_padded integer, intent(in) :: nz_padded public pure subroutine get_index_dir (dir_i, dir_j, dir_k, i, j, k, dir, SZ, nx_padded, ny_padded, nz_padded) Get application storage directional index from cartesian index Arguments Type Intent Optional Attributes Name integer, intent(out) :: dir_i integer, intent(out) :: dir_j integer, intent(out) :: dir_k integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: dir integer, intent(in) :: SZ integer, intent(in) :: nx_padded integer, intent(in) :: ny_padded integer, intent(in) :: nz_padded public pure subroutine get_index_reordering (out_i, out_j, out_k, in_i, in_j, in_k, dir_from, dir_to, sz, cart_padded) Converts indices in between any two DIR_? Arguments Type Intent Optional Attributes Name integer, intent(out) :: out_i integer, intent(out) :: out_j integer, intent(out) :: out_k integer, intent(in) :: in_i integer, intent(in) :: in_j integer, intent(in) :: in_k integer, intent(in) :: dir_from integer, intent(in) :: dir_to integer, intent(in) :: sz integer, intent(in) :: cart_padded (3)","tags":"","url":"module/m_ordering.html"},{"title":"m_cuda_spectral – x3d2","text":"Uses m_common cudafor module~~m_cuda_spectral~~UsesGraph module~m_cuda_spectral m_cuda_spectral cudafor cudafor module~m_cuda_spectral->cudafor module~m_common m_common module~m_cuda_spectral->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_spectral~~UsedByGraph module~m_cuda_spectral m_cuda_spectral module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_poisson_fft->module~m_cuda_spectral module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_poisson_fft program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine memcpy3D (dst, src, nx, ny, nz) Copy data between x3d2 padded arrays and cuFFTMp descriptors Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: dst real(kind=dp), intent(in), device, dimension(:, :, :) :: src integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz public  subroutine memcpy3D_with_transpose (dst, src, nx, ny, nz) Copy with transpose: src(nx, ny, nz) -> dst(ny, nx, nz)\nUsed for 100 case forward FFT Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: dst real(kind=dp), intent(in), device, dimension(:, :, :) :: src integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz public  subroutine memcpy3D_with_transpose_back (dst, src, nx, ny, nz) Copy with transpose back: src(ny, nx, nz) -> dst(nx, ny, nz)\nUsed for 100 case backward FFT Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: dst real(kind=dp), intent(in), device, dimension(:, :, :) :: src integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz public  subroutine process_spectral_000 (div_u, waves, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz public  subroutine process_spectral_010 (div_u, waves, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves Spectral equivalence constants integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz public  subroutine process_spectral_010_fw (div_u, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: bx Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: ay Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: by Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: az Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: bz Spectral equivalence constants public  subroutine process_spectral_010_poisson (div_u, a_re, a_im, off, inc, nx_spec, n, nx, ny, nz) Solve the Poisson equation at cell centres with non-perioic BC along y Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space real(kind=dp), intent(inout), device, dimension(:, :, :, :) :: a_re Spectral equivalence constants real(kind=dp), intent(inout), device, dimension(:, :, :, :) :: a_im Spectral equivalence constants integer, intent(in), value :: off offset and increment. increment is 2 when considering only odd or even integer, intent(in), value :: inc offset and increment. increment is 2 when considering only odd or even integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: n Grid size in spectral space integer, intent(in), value :: nx Grid size in spectral space integer, intent(in), value :: ny Grid size in spectral space integer, intent(in), value :: nz Grid size in spectral space public  subroutine process_spectral_010_bw (div_u, nx_spec, ny_spec, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes the divergence of velocity in spectral space, including\nscaling w.r.t. grid size. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u Divergence of velocity in spectral space integer, intent(in), value :: nx_spec Grid size in spectral space integer, intent(in), value :: ny_spec Grid size in spectral space integer, intent(in), value :: y_sp_st Offset in y direction in the permuted slabs in spectral space integer, intent(in), value :: nx Grid size integer, intent(in), value :: ny Grid size integer, intent(in), value :: nz Grid size real(kind=dp), intent(in), device, dimension(:) :: ax Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: bx Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: ay Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: by Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: az Spectral equivalence constants real(kind=dp), intent(in), device, dimension(:) :: bz Spectral equivalence constants public  subroutine process_spectral_110 (div_u, waves, nx_spec, ny_spec, x_sp_st, y_sp_st, nx, ny, nz, ax, bx, ay, by, az, bz) Post-processes for Dirichlet BC in X and Y, periodic in Z Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), device, dimension(:, :, :) :: div_u complex(kind=dp), intent(in), device, dimension(:, :, :) :: waves integer, intent(in), value :: nx_spec integer, intent(in), value :: ny_spec integer, intent(in), value :: x_sp_st integer, intent(in), value :: y_sp_st integer, intent(in), value :: nx integer, intent(in), value :: ny integer, intent(in), value :: nz real(kind=dp), intent(in), device, dimension(:) :: ax real(kind=dp), intent(in), device, dimension(:) :: bx real(kind=dp), intent(in), device, dimension(:) :: ay real(kind=dp), intent(in), device, dimension(:) :: by real(kind=dp), intent(in), device, dimension(:) :: az real(kind=dp), intent(in), device, dimension(:) :: bz public  subroutine enforce_periodicity_x (f_out, f_in, nx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_out real(kind=dp), intent(in), device, dimension(:, :, :) :: f_in integer, intent(in), value :: nx public  subroutine undo_periodicity_x (f_out, f_in, nx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_out real(kind=dp), intent(in), device, dimension(:, :, :) :: f_in integer, intent(in), value :: nx public  subroutine enforce_periodicity_y (f_out, f_in, ny) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_out real(kind=dp), intent(in), device, dimension(:, :, :) :: f_in integer, intent(in), value :: ny public  subroutine undo_periodicity_y (f_out, f_in, ny) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: f_out real(kind=dp), intent(in), device, dimension(:, :, :) :: f_in integer, intent(in), value :: ny","tags":"","url":"module/m_cuda_spectral.html"},{"title":"m_cuda_kernels_dist – x3d2","text":"Uses m_common cudafor module~~m_cuda_kernels_dist~~UsesGraph module~m_cuda_kernels_dist m_cuda_kernels_dist cudafor cudafor module~m_cuda_kernels_dist->cudafor module~m_common m_common module~m_cuda_kernels_dist->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_cuda_kernels_dist~~UsedByGraph module~m_cuda_kernels_dist m_cuda_kernels_dist module~m_cuda_backend m_cuda_backend module~m_cuda_backend->module~m_cuda_kernels_dist module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend->module~m_cuda_exec_dist module~m_cuda_exec_dist->module~m_cuda_kernels_dist program~xcompact xcompact program~xcompact->module~m_cuda_backend Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine der_univ_dist (du, send_u_s, send_u_e, u, u_s, u_e, n_tds, n_rhs, coeffs_s, coeffs_e, coeffs, ffr, fbc, faf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e integer, intent(in), value :: n_tds integer, intent(in), value :: n_rhs real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_s real(kind=dp), intent(in), device, dimension(:, :) :: coeffs_e real(kind=dp), intent(in), device, dimension(:) :: coeffs real(kind=dp), intent(in), device, dimension(:) :: ffr real(kind=dp), intent(in), device, dimension(:) :: fbc real(kind=dp), intent(in), device, dimension(:) :: faf public  subroutine der_univ_subs (du, recv_u_s, recv_u_e, n, dist_sa, dist_sc, strch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_u_e integer, intent(in), value :: n real(kind=dp), intent(in), device, dimension(:) :: dist_sa real(kind=dp), intent(in), device, dimension(:) :: dist_sc real(kind=dp), intent(in), device, dimension(:) :: strch public  subroutine transeq_3fused_dist (du, dud, d2u, send_du_s, send_du_e, send_dud_s, send_dud_e, send_d2u_s, send_d2u_e, u, u_s, u_e, v, v_s, v_e, n_tds, n_rhs, du_coeffs_s, du_coeffs_e, du_coeffs, du_fw, du_bw, du_af, dud_coeffs_s, dud_coeffs_e, dud_coeffs, dud_fw, dud_bw, dud_af, d2u_coeffs_s, d2u_coeffs_e, d2u_coeffs, d2u_fw, d2u_bw, d2u_af) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), device, dimension(:, :, :) :: du real(kind=dp), intent(out), device, dimension(:, :, :) :: dud real(kind=dp), intent(out), device, dimension(:, :, :) :: d2u real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_du_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_dud_e real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_s real(kind=dp), intent(out), device, dimension(:, :, :) :: send_d2u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: u real(kind=dp), intent(in), device, dimension(:, :, :) :: u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: u_e real(kind=dp), intent(in), device, dimension(:, :, :) :: v real(kind=dp), intent(in), device, dimension(:, :, :) :: v_s real(kind=dp), intent(in), device, dimension(:, :, :) :: v_e integer, intent(in), value :: n_tds integer, intent(in), value :: n_rhs real(kind=dp), intent(in), device :: du_coeffs_s (:,:) real(kind=dp), intent(in), device :: du_coeffs_e (:,:) real(kind=dp), intent(in), device :: du_coeffs (:) real(kind=dp), intent(in), device :: du_fw (:) real(kind=dp), intent(in), device :: du_bw (:) real(kind=dp), intent(in), device :: du_af (:) real(kind=dp), intent(in), device :: dud_coeffs_s (:,:) real(kind=dp), intent(in), device :: dud_coeffs_e (:,:) real(kind=dp), intent(in), device :: dud_coeffs (:) real(kind=dp), intent(in), device :: dud_fw (:) real(kind=dp), intent(in), device :: dud_bw (:) real(kind=dp), intent(in), device :: dud_af (:) real(kind=dp), intent(in), device :: d2u_coeffs_s (:,:) real(kind=dp), intent(in), device :: d2u_coeffs_e (:,:) real(kind=dp), intent(in), device :: d2u_coeffs (:) real(kind=dp), intent(in), device :: d2u_fw (:) real(kind=dp), intent(in), device :: d2u_bw (:) real(kind=dp), intent(in), device :: d2u_af (:) public  subroutine transeq_3fused_subs (r_du, conv, dud, d2u, recv_du_s, recv_du_e, recv_dud_s, recv_dud_e, recv_d2u_s, recv_d2u_e, n, nu, du_sa, du_sc, du_strch, dud_sa, dud_sc, dud_strch, d2u_sa, d2u_sc, d2u_strch, d2u_strch_cor) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), device, dimension(:, :, :) :: r_du The result array, it stores 'du' first then its overwritten real(kind=dp), intent(in), device, dimension(:, :, :) :: conv real(kind=dp), intent(in), device, dimension(:, :, :) :: dud real(kind=dp), intent(in), device, dimension(:, :, :) :: d2u real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_du_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_dud_e real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_s real(kind=dp), intent(in), device, dimension(:, :, :) :: recv_d2u_e integer, intent(in), value :: n real(kind=dp), intent(in), value :: nu real(kind=dp), intent(in), device, dimension(:) :: du_sa real(kind=dp), intent(in), device, dimension(:) :: du_sc real(kind=dp), intent(in), device, dimension(:) :: du_strch real(kind=dp), intent(in), device, dimension(:) :: dud_sa real(kind=dp), intent(in), device, dimension(:) :: dud_sc real(kind=dp), intent(in), device, dimension(:) :: dud_strch real(kind=dp), intent(in), device, dimension(:) :: d2u_sa real(kind=dp), intent(in), device, dimension(:) :: d2u_sc real(kind=dp), intent(in), device, dimension(:) :: d2u_strch real(kind=dp), intent(in), device, dimension(:) :: d2u_strch_cor","tags":"","url":"module/m_cuda_kernels_dist.html"},{"title":"m_io_base – x3d2","text":"I/O architecture. the I/O system. It establishes a polymorphic layer that allows the\nhigh-level user session to interact with various I/O backends through a\nconsistent interface. The architecture is designed in distinct layers:\nUser code\n- interacts only with the Session layer Session layer ( m_io_session )\n- manages all I/O complexity (file handles, state, etc.)\n- instantiates the I/O backend selected at compile-time\n- provides reader_session_t and writer_session_t for users Backend layer ( m_io_backend )\n- concrete implementation of an I/O backed (e.g., ADIOS2)\n- extends the abstract base types defined in this module Base layer ( m_io_base , this module)\n- provides abstract reader_base_t and writer_base_t types\n- enforces a consistent interface for all backends Note This is an internal module and should not be used directly by users.\nThe sole public interface for I/O is the high-level session API provided in m_io_session . Uses m_common module~~m_io_base~~UsesGraph module~m_io_base m_io_base module~m_common m_common module~m_io_base->module~m_common mpi mpi module~m_common->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~m_io_base~~UsedByGraph module~m_io_base m_io_base module~m_io_backend m_io_backend module~m_io_backend->module~m_io_base module~m_io_backend~2 m_io_backend module~m_io_backend~2->module~m_io_base module~m_io_field_utils m_io_field_utils module~m_io_field_utils->module~m_io_base module~m_solver m_solver module~m_io_field_utils->module~m_solver module~m_io_session m_io_session module~m_io_session->module~m_io_base module~m_io_session->module~m_io_backend~2 module~m_checkpoint_manager m_checkpoint_manager module~m_checkpoint_manager->module~m_io_field_utils module~m_checkpoint_manager->module~m_io_session module~m_checkpoint_manager->module~m_solver module~m_ibm m_ibm module~m_ibm->module~m_io_session module~m_snapshot_manager m_snapshot_manager module~m_snapshot_manager->module~m_io_field_utils module~m_snapshot_manager->module~m_io_session module~m_snapshot_manager->module~m_solver module~m_io_manager m_io_manager module~m_io_manager->module~m_checkpoint_manager module~m_io_manager->module~m_snapshot_manager module~m_io_manager->module~m_solver module~m_solver->module~m_ibm module~m_base_case m_base_case module~m_base_case->module~m_io_manager module~m_base_case->module~m_solver module~m_case_channel m_case_channel module~m_case_channel->module~m_solver module~m_case_channel->module~m_base_case module~m_case_cylinder m_case_cylinder module~m_case_cylinder->module~m_solver module~m_case_cylinder->module~m_base_case module~m_case_generic m_case_generic module~m_case_generic->module~m_solver module~m_case_generic->module~m_base_case module~m_case_tgv m_case_tgv module~m_case_tgv->module~m_solver module~m_case_tgv->module~m_base_case program~xcompact xcompact program~xcompact->module~m_base_case program~xcompact->module~m_case_channel program~xcompact->module~m_case_cylinder program~xcompact->module~m_case_generic program~xcompact->module~m_case_tgv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: io_mode_read = 1 integer, public, parameter :: io_mode_write = 2 Derived Types type, public :: io_file_t Base file handle for I/O operations Type-Bound Procedures procedure, public :: close => base_close procedure, public :: begin_step => base_begin_step procedure, public :: end_step => base_end_step procedure, public :: is_file_functional => base_is_file_functional type, public :: io_reader_t Base I/O reader type for polymorphic usage Type-Bound Procedures procedure, public :: init => base_reader_init procedure, public :: open => base_reader_open procedure, public :: finalise => base_reader_finalise generic, public :: read_data => read_data_i8, read_data_integer, read_data_real, read_data_array_3d procedure, public :: read_data_i8 procedure, public :: read_data_integer procedure, public :: read_data_real procedure, public :: read_data_array_3d type, public :: io_writer_t Base I/O writer type for polymorphic usage Type-Bound Procedures procedure, public :: init => base_writer_init procedure, public :: open => base_writer_open procedure, public :: finalise => base_writer_finalise generic, public :: write_data => write_data_i8, write_data_integer, write_data_real, write_data_array_3d procedure, public :: write_data_i8 procedure, public :: write_data_integer procedure, public :: write_data_real procedure, public :: write_data_array_3d generic, public :: write_attribute => write_attribute_string, write_attribute_array_1d_real procedure, public :: write_attribute_string procedure, public :: write_attribute_array_1d_real","tags":"","url":"module/m_io_base.html"},{"title":"xcompact – x3d2","text":"Uses m_base_case m_case_cylinder m_case_tgv m_case_channel m_case_generic m_omp_common m_config m_mesh m_cuda_allocator m_cuda_backend m_omp_backend m_cuda_common m_allocator mpi m_base_backend m_common program~~xcompact~~UsesGraph program~xcompact xcompact module~m_allocator m_allocator program~xcompact->module~m_allocator module~m_base_backend m_base_backend program~xcompact->module~m_base_backend module~m_base_case m_base_case program~xcompact->module~m_base_case module~m_case_channel m_case_channel program~xcompact->module~m_case_channel module~m_case_cylinder m_case_cylinder program~xcompact->module~m_case_cylinder module~m_case_generic m_case_generic program~xcompact->module~m_case_generic module~m_case_tgv m_case_tgv program~xcompact->module~m_case_tgv module~m_common m_common program~xcompact->module~m_common module~m_config m_config program~xcompact->module~m_config module~m_cuda_allocator m_cuda_allocator program~xcompact->module~m_cuda_allocator module~m_cuda_backend m_cuda_backend program~xcompact->module~m_cuda_backend module~m_cuda_common m_cuda_common program~xcompact->module~m_cuda_common module~m_mesh m_mesh program~xcompact->module~m_mesh module~m_omp_backend m_omp_backend program~xcompact->module~m_omp_backend module~m_omp_common m_omp_common program~xcompact->module~m_omp_common mpi mpi program~xcompact->mpi module~m_allocator->module~m_common iso_fortran_env iso_fortran_env module~m_allocator->iso_fortran_env module~m_field m_field module~m_allocator->module~m_field module~m_base_backend->module~m_allocator module~m_base_backend->module~m_common module~m_base_backend->module~m_mesh module~m_base_backend->mpi module~m_base_backend->module~m_field module~m_poisson_fft m_poisson_fft module~m_base_backend->module~m_poisson_fft module~m_tdsops m_tdsops module~m_base_backend->module~m_tdsops module~m_base_case->module~m_allocator module~m_base_case->module~m_base_backend module~m_base_case->module~m_common module~m_base_case->module~m_mesh module~m_base_case->mpi module~m_base_case->module~m_field module~m_io_manager m_io_manager module~m_base_case->module~m_io_manager module~m_solver m_solver module~m_base_case->module~m_solver module~m_case_channel->module~m_allocator module~m_case_channel->module~m_base_backend module~m_case_channel->module~m_base_case module~m_case_channel->module~m_common module~m_case_channel->module~m_config module~m_case_channel->module~m_mesh module~m_case_channel->mpi module~m_case_channel->iso_fortran_env module~m_case_channel->module~m_solver module~m_case_cylinder->module~m_allocator module~m_case_cylinder->module~m_base_backend module~m_case_cylinder->module~m_base_case module~m_case_cylinder->module~m_common module~m_case_cylinder->module~m_config module~m_case_cylinder->module~m_mesh module~m_case_cylinder->iso_fortran_env module~m_case_cylinder->module~m_field module~m_case_cylinder->module~m_solver module~m_case_generic->module~m_allocator module~m_case_generic->module~m_base_backend module~m_case_generic->module~m_base_case module~m_case_generic->module~m_common module~m_case_generic->module~m_mesh module~m_case_generic->iso_fortran_env module~m_case_generic->module~m_field module~m_case_generic->module~m_solver module~m_case_tgv->module~m_allocator module~m_case_tgv->module~m_base_backend module~m_case_tgv->module~m_base_case module~m_case_tgv->module~m_common module~m_case_tgv->module~m_mesh module~m_case_tgv->iso_fortran_env module~m_case_tgv->module~m_field module~m_case_tgv->module~m_solver module~m_common->mpi module~m_config->module~m_common module~m_config->iso_fortran_env module~m_cuda_allocator->module~m_allocator module~m_cuda_allocator->module~m_common module~m_cuda_allocator->module~m_mesh module~m_cuda_allocator->module~m_field module~m_cuda_backend->module~m_allocator module~m_cuda_backend->module~m_base_backend module~m_cuda_backend->module~m_common module~m_cuda_backend->module~m_cuda_allocator module~m_cuda_backend->module~m_cuda_common module~m_cuda_backend->module~m_mesh module~m_cuda_backend->mpi cudafor cudafor module~m_cuda_backend->cudafor module~m_cuda_backend->iso_fortran_env module~m_cuda_exec_dist m_cuda_exec_dist module~m_cuda_backend->module~m_cuda_exec_dist module~m_cuda_kernels_dist m_cuda_kernels_dist module~m_cuda_backend->module~m_cuda_kernels_dist module~m_cuda_kernels_fieldops m_cuda_kernels_fieldops module~m_cuda_backend->module~m_cuda_kernels_fieldops module~m_cuda_kernels_reorder m_cuda_kernels_reorder module~m_cuda_backend->module~m_cuda_kernels_reorder module~m_cuda_poisson_fft m_cuda_poisson_fft module~m_cuda_backend->module~m_cuda_poisson_fft module~m_cuda_sendrecv m_cuda_sendrecv module~m_cuda_backend->module~m_cuda_sendrecv module~m_cuda_tdsops m_cuda_tdsops module~m_cuda_backend->module~m_cuda_tdsops module~m_cuda_backend->module~m_field module~m_cuda_backend->module~m_tdsops module~m_mesh->module~m_common module~m_mesh->mpi module~m_mesh->iso_fortran_env module~m_mesh->module~m_field module~m_mesh_content m_mesh_content module~m_mesh->module~m_mesh_content module~m_omp_backend->module~m_allocator module~m_omp_backend->module~m_base_backend module~m_omp_backend->module~m_common module~m_omp_backend->module~m_mesh module~m_omp_backend->module~m_omp_common module~m_omp_backend->mpi module~m_omp_backend->module~m_field module~m_omp_exec_dist m_omp_exec_dist module~m_omp_backend->module~m_omp_exec_dist module~m_omp_sendrecv m_omp_sendrecv module~m_omp_backend->module~m_omp_sendrecv module~m_ordering m_ordering module~m_omp_backend->module~m_ordering module~m_omp_backend->module~m_tdsops module~m_cuda_exec_dist->module~m_common module~m_cuda_exec_dist->module~m_cuda_common module~m_cuda_exec_dist->mpi module~m_cuda_exec_dist->cudafor module~m_cuda_exec_dist->module~m_cuda_kernels_dist module~m_cuda_exec_dist->module~m_cuda_sendrecv module~m_cuda_exec_dist->module~m_cuda_tdsops module~m_cuda_kernels_dist->module~m_common module~m_cuda_kernels_dist->cudafor module~m_cuda_kernels_fieldops->module~m_common module~m_cuda_kernels_fieldops->module~m_cuda_common module~m_cuda_kernels_fieldops->cudafor module~m_cuda_kernels_reorder->module~m_common module~m_cuda_kernels_reorder->module~m_cuda_common module~m_cuda_kernels_reorder->cudafor module~m_cuda_poisson_fft->module~m_common module~m_cuda_poisson_fft->module~m_cuda_allocator module~m_cuda_poisson_fft->module~m_mesh module~m_cuda_poisson_fft->mpi module~m_cuda_poisson_fft->cudafor module~m_cuda_poisson_fft->iso_fortran_env module~m_cuda_poisson_fft->module~m_field module~m_cuda_poisson_fft->module~m_poisson_fft module~m_cuda_poisson_fft->module~m_tdsops cufft cufft module~m_cuda_poisson_fft->cufft cufftXt cufftXt module~m_cuda_poisson_fft->cufftXt iso_c_binding iso_c_binding module~m_cuda_poisson_fft->iso_c_binding module~m_cuda_spectral m_cuda_spectral module~m_cuda_poisson_fft->module~m_cuda_spectral module~m_cuda_sendrecv->module~m_common module~m_cuda_sendrecv->mpi module~m_cuda_sendrecv->cudafor module~m_cuda_tdsops->module~m_common module~m_cuda_tdsops->iso_fortran_env module~m_cuda_tdsops->module~m_tdsops module~m_field->module~m_common module~m_io_manager->module~m_solver module~m_checkpoint_manager m_checkpoint_manager module~m_io_manager->module~m_checkpoint_manager module~m_snapshot_manager m_snapshot_manager module~m_io_manager->module~m_snapshot_manager module~m_mesh_content->module~m_common module~m_omp_exec_dist->module~m_common module~m_omp_exec_dist->module~m_omp_common module~m_omp_exec_dist->mpi module~m_omp_exec_dist->module~m_omp_sendrecv module~m_omp_exec_dist->module~m_tdsops module~m_omp_kernels_dist m_omp_kernels_dist module~m_omp_exec_dist->module~m_omp_kernels_dist module~m_omp_sendrecv->module~m_common module~m_omp_sendrecv->mpi module~m_ordering->module~m_common module~m_poisson_fft->module~m_common module~m_poisson_fft->module~m_mesh module~m_poisson_fft->module~m_field module~m_poisson_fft->module~m_tdsops module~m_solver->module~m_allocator module~m_solver->module~m_base_backend module~m_solver->module~m_common module~m_solver->module~m_config module~m_solver->module~m_mesh module~m_solver->mpi module~m_solver->iso_fortran_env module~m_solver->module~m_field module~m_solver->module~m_tdsops module~m_ibm m_ibm module~m_solver->module~m_ibm module~m_time_integrator m_time_integrator module~m_solver->module~m_time_integrator module~m_vector_calculus m_vector_calculus module~m_solver->module~m_vector_calculus module~m_tdsops->module~m_common module~m_tdsops->iso_fortran_env module~m_checkpoint_manager->module~m_common module~m_checkpoint_manager->module~m_config module~m_checkpoint_manager->mpi module~m_checkpoint_manager->module~m_field module~m_checkpoint_manager->module~m_solver module~m_io_field_utils m_io_field_utils module~m_checkpoint_manager->module~m_io_field_utils module~m_io_session m_io_session module~m_checkpoint_manager->module~m_io_session module~m_cuda_spectral->module~m_common module~m_cuda_spectral->cudafor module~m_ibm->module~m_allocator module~m_ibm->module~m_base_backend module~m_ibm->module~m_common module~m_ibm->module~m_mesh module~m_ibm->mpi module~m_ibm->iso_fortran_env module~m_ibm->module~m_field module~m_ibm->module~m_io_session module~m_omp_kernels_dist->module~m_common module~m_omp_kernels_dist->module~m_omp_common omp_lib omp_lib module~m_omp_kernels_dist->omp_lib module~m_snapshot_manager->module~m_common module~m_snapshot_manager->module~m_config module~m_snapshot_manager->mpi module~m_snapshot_manager->module~m_field module~m_snapshot_manager->module~m_solver module~m_snapshot_manager->module~m_io_field_utils module~m_snapshot_manager->module~m_io_session module~m_time_integrator->module~m_allocator module~m_time_integrator->module~m_base_backend module~m_time_integrator->module~m_common module~m_time_integrator->module~m_field module~m_vector_calculus->module~m_allocator module~m_vector_calculus->module~m_base_backend module~m_vector_calculus->module~m_common module~m_vector_calculus->iso_fortran_env module~m_vector_calculus->module~m_field module~m_vector_calculus->module~m_tdsops module~m_io_field_utils->module~m_common module~m_io_field_utils->module~m_field module~m_io_field_utils->module~m_solver module~m_io_base m_io_base module~m_io_field_utils->module~m_io_base module~m_io_session->module~m_common module~m_io_backend~2 m_io_backend module~m_io_session->module~m_io_backend~2 module~m_io_session->module~m_io_base module~m_io_backend~2->module~m_common module~m_io_backend~2->iso_fortran_env module~m_io_backend~2->module~m_io_base module~m_io_base->module~m_common Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~xcompact~~CallsGraph program~xcompact xcompact cudagetdevice cudagetdevice program~xcompact->cudagetdevice cudagetdevicecount cudagetdevicecount program~xcompact->cudagetdevicecount cudasetdevice cudasetdevice program~xcompact->cudasetdevice mpi_comm_rank mpi_comm_rank program~xcompact->mpi_comm_rank mpi_comm_size mpi_comm_size program~xcompact->mpi_comm_size mpi_finalize mpi_finalize program~xcompact->mpi_finalize mpi_init mpi_init program~xcompact->mpi_init proc~get_argument m_common::get_argument program~xcompact->proc~get_argument proc~get_dims m_mesh::mesh_t%get_dims program~xcompact->proc~get_dims proc~run m_base_case::base_case_t%run program~xcompact->proc~run proc~get_dims_dataloc m_mesh::get_dims_dataloc proc~get_dims->proc~get_dims_dataloc boundary_conditions boundary_conditions proc~run->boundary_conditions forcings forcings proc~run->forcings none~body m_ibm::ibm_t%body proc~run->none~body none~handle_io_step m_io_manager::io_manager_t%handle_io_step proc~run->none~handle_io_step none~is_restart m_io_manager::io_manager_t%is_restart proc~run->none~is_restart postprocess postprocess proc~run->postprocess pre_correction pre_correction proc~run->pre_correction proc~case_finalise m_base_case::base_case_t%case_finalise proc~run->proc~case_finalise proc~get_block m_allocator::allocator_t%get_block proc~run->proc~get_block proc~is_root m_mesh_content::par_t%is_root proc~run->proc~is_root proc~pressure_correction m_solver::solver_t%pressure_correction proc~run->proc~pressure_correction proc~release_block m_allocator::allocator_t%release_block proc~run->proc~release_block vecmult vecmult none~body->vecmult none~handle_checkpoint_step m_checkpoint_manager::checkpoint_manager_t%handle_checkpoint_step none~handle_io_step->none~handle_checkpoint_step none~handle_snapshot_step m_snapshot_manager::snapshot_manager_t%handle_snapshot_step none~handle_io_step->none~handle_snapshot_step none~is_restart~3 m_checkpoint_manager::checkpoint_manager_t%is_restart none~is_restart->none~is_restart~3 proc~case_finalise->proc~is_root none~finalise m_io_manager::io_manager_t%finalise proc~case_finalise->none~finalise proc~create_block m_allocator::allocator_t%create_block proc~get_block->proc~create_block proc~set_shape m_field::field_t%set_shape proc~get_block->proc~set_shape proc~pressure_correction->proc~get_block proc~pressure_correction->proc~release_block proc~divergence_v2p m_solver::solver_t%divergence_v2p proc~pressure_correction->proc~divergence_v2p proc~gradient_p2v m_solver::solver_t%gradient_p2v proc~pressure_correction->proc~gradient_p2v vecadd vecadd proc~pressure_correction->vecadd none~finalise~7 m_checkpoint_manager::checkpoint_manager_t%finalise none~finalise->none~finalise~7 none~handle_checkpoint_step->mpi_comm_rank none~handle_checkpoint_step->proc~get_dims none~is_session_functional m_io_session::io_session_base_t%is_session_functional none~handle_checkpoint_step->none~is_session_functional none~write_data m_io_session::writer_session_t%write_data none~handle_checkpoint_step->none~write_data padded_dims padded_dims none~handle_checkpoint_step->padded_dims proc~cleanup_field_arrays m_io_field_utils::cleanup_field_arrays none~handle_checkpoint_step->proc~cleanup_field_arrays proc~cleanup_field_buffers m_io_field_utils::cleanup_field_buffers none~handle_checkpoint_step->proc~cleanup_field_buffers proc~get_global_dims m_mesh::mesh_t%get_global_dims none~handle_checkpoint_step->proc~get_global_dims proc~get_output_dimensions m_io_field_utils::get_output_dimensions none~handle_checkpoint_step->proc~get_output_dimensions proc~get_shape m_field::field_t%get_shape none~handle_checkpoint_step->proc~get_shape proc~prepare_field_buffers m_io_field_utils::prepare_field_buffers none~handle_checkpoint_step->proc~prepare_field_buffers proc~setup_field_arrays m_io_field_utils::setup_field_arrays none~handle_checkpoint_step->proc~setup_field_arrays proc~write_single_field_to_buffer m_io_field_utils::write_single_field_to_buffer none~handle_checkpoint_step->proc~write_single_field_to_buffer raw_buffers raw_buffers none~handle_checkpoint_step->raw_buffers none~handle_snapshot_step->mpi_comm_rank none~handle_snapshot_step->proc~get_dims none~begin_step m_io_session::writer_session_t%begin_step none~handle_snapshot_step->none~begin_step none~end_step m_io_session::writer_session_t%end_step none~handle_snapshot_step->none~end_step none~handle_snapshot_step->none~is_session_functional none~write_attribute m_io_session::writer_session_t%write_attribute none~handle_snapshot_step->none~write_attribute none~handle_snapshot_step->none~write_data none~handle_snapshot_step->proc~cleanup_field_arrays proc~get_coordinates m_mesh::mesh_t%get_coordinates none~handle_snapshot_step->proc~get_coordinates none~handle_snapshot_step->proc~get_global_dims none~handle_snapshot_step->proc~get_output_dimensions none~handle_snapshot_step->proc~prepare_field_buffers none~handle_snapshot_step->proc~setup_field_arrays none~handle_snapshot_step->proc~write_single_field_to_buffer proc~divergence_v2c m_vector_calculus::vector_calculus_t%divergence_v2c proc~divergence_v2p->proc~divergence_v2c proc~gradient_c2v m_vector_calculus::vector_calculus_t%gradient_c2v proc~gradient_p2v->proc~gradient_c2v begin_step begin_step none~begin_step->begin_step end_step end_step none~end_step->end_step none~finalise~7->proc~cleanup_field_buffers none~write_attribute~2 m_io_base::io_writer_t%write_attribute none~write_attribute->none~write_attribute~2 none~write_data~2 m_io_base::io_writer_t%write_data none~write_data->none~write_data~2 proc~cleanup_field_arrays->proc~release_block proc~divergence_v2c->proc~get_block proc~divergence_v2c->proc~release_block proc~divergence_v2c->vecadd reorder reorder proc~divergence_v2c->reorder tds_solve tds_solve proc~divergence_v2c->tds_solve proc~get_global_dims->proc~get_dims_dataloc proc~gradient_c2v->proc~get_block proc~gradient_c2v->proc~release_block proc~gradient_c2v->reorder proc~gradient_c2v->tds_solve proc~prepare_field_buffers->proc~get_dims proc~prepare_field_buffers->proc~get_global_dims proc~prepare_field_buffers->proc~get_output_dimensions proc~setup_field_arrays->proc~get_block proc~setup_field_arrays->proc~is_root proc~get_field_data m_base_backend::base_backend_t%get_field_data proc~setup_field_arrays->proc~get_field_data proc~write_single_field_to_buffer->proc~get_dims proc~write_single_field_to_buffer->proc~get_global_dims proc~write_single_field_to_buffer->proc~get_output_dimensions proc~stride_data_to_buffer m_io_field_utils::stride_data_to_buffer proc~write_single_field_to_buffer->proc~stride_data_to_buffer proc~get_field_data->proc~get_block proc~get_field_data->proc~release_block proc~get_field_data->reorder copy_f_to_data copy_f_to_data proc~get_field_data->copy_f_to_data proc~get_rdr_from_dirs m_common::get_rdr_from_dirs proc~get_field_data->proc~get_rdr_from_dirs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial class( base_backend_t ), pointer :: backend class( allocator_t ), pointer :: allocator type( allocator_t ), pointer :: host_allocator type( mesh_t ), target :: mesh class( base_case_t ), allocatable :: flow_case type( cuda_backend_t ), target :: cuda_backend type( cuda_allocator_t ), target :: cuda_allocator integer :: ndevs integer :: devnum type( omp_backend_t ), target :: omp_backend type( allocator_t ), target :: omp_allocator real(kind=dp) :: t_start real(kind=dp) :: t_end type( domain_config_t ) :: domain_cfg type( solver_config_t ) :: solver_cfg character(len=32) :: backend_name integer :: dims (3) integer :: nrank integer :: nproc integer :: ierr logical :: use_2decomp","tags":"","url":"program/xcompact.html"},{"title":"  domain_settings – x3d2\n","text":"Variables Name Type Default Description flow_case_name character(len=20) None L_global real(kind=dp) None dims_global integer None nproc_dir integer None BC_x character(len=20) None BC_y character(len=20) None BC_z character(len=20) None stretching character(len=20) ['uniform', 'uniform', 'uniform'] beta real(kind=dp) None","tags":"","url":"namelist/domain_settings.html"},{"title":"  solver_params – x3d2\n","text":"Variables Name Type Default Description Re real(kind=dp) None dt real(kind=dp) None n_iters integer None n_output integer None poisson_solver_type character(len=3) 'FFT' n_species integer 0 pr_species real(kind=dp) 1._dp lowmem_transeq logical .false. triggers the low memory implementations lowmem_fft logical .false. triggers the low memory implementations time_intg character(len=3) None der1st_scheme character(len=30) 'compact6' der2nd_scheme character(len=30) 'compact6' interpl_scheme character(len=30) 'classic' stagder_scheme character(len=30) 'compact6' ibm_on logical .false.","tags":"","url":"namelist/solver_params.html"},{"title":"  channel_nml – x3d2\n","text":"Variables Name Type Default Description noise real(kind=dp) None rotation logical None omega_rot real(kind=dp) None n_rotate integer None","tags":"","url":"namelist/channel_nml.html"},{"title":"  cylinder_nml – x3d2\n","text":"Variables Name Type Default Description init_noise real(kind=dp) None","tags":"","url":"namelist/cylinder_nml.html"},{"title":"  checkpoint_params – x3d2\n","text":"Variables Name Type Default Description checkpoint_freq integer 0 snapshot_freq integer 0 keep_checkpoint logical .false. checkpoint_prefix character(len=256) \"checkpoint\" snapshot_prefix character(len=256) \"snapshot\" restart_from_checkpoint logical .false. restart_file character(len=256) \"\" output_stride integer [1, 1, 1] snapshot_sp logical .false.","tags":"","url":"namelist/checkpoint_params.html"},{"title":"exec_thom.f90 – x3d2","text":"This file depends on sourcefile~~exec_thom.f90~~EfferentGraph sourcefile~exec_thom.f90 exec_thom.f90 sourcefile~common.f90 common.f90 sourcefile~exec_thom.f90->sourcefile~common.f90 sourcefile~tdsops.f90 tdsops.f90 sourcefile~exec_thom.f90->sourcefile~tdsops.f90 sourcefile~thomas.f90 thomas.f90 sourcefile~exec_thom.f90->sourcefile~thomas.f90 sourcefile~tdsops.f90->sourcefile~common.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~tdsops.f90->sourcefile~tdsops.f90~2 sourcefile~thomas.f90->sourcefile~common.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_exec_thom use cudafor use m_common , only : dp use m_cuda_kernels_thom , only : der_univ_thom , der_univ_thom_per use m_cuda_tdsops , only : cuda_tdsops_t implicit none contains subroutine exec_thom_tds_compact ( du , u , tdsops , blocks , threads ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: du real ( dp ), device , dimension (:, :, :), intent ( in ) :: u type ( cuda_tdsops_t ), intent ( in ) :: tdsops type ( dim3 ), intent ( in ) :: blocks , threads if ( tdsops % periodic ) then call der_univ_thom_per <<< blocks , threads >>> ( & !& du , u , tdsops % n_tds , tdsops % coeffs_dev , tdsops % alpha , & tdsops % thom_f_dev , tdsops % thom_s_dev , tdsops % thom_w_dev , & tdsops % thom_p_dev , tdsops % stretch_dev & ) else call der_univ_thom <<< blocks , threads >>> ( & !& du , u , & tdsops % n_tds , tdsops % n_rhs , & tdsops % coeffs_s_dev , tdsops % coeffs_e_dev , tdsops % coeffs_dev , & tdsops % thom_f_dev , tdsops % thom_s_dev , tdsops % thom_w_dev , & tdsops % stretch_dev & ) end if end subroutine exec_thom_tds_compact end module m_cuda_exec_thom","tags":"","url":"sourcefile/exec_thom.f90.html"},{"title":"io_manager.f90 – x3d2","text":"This file depends on sourcefile~~io_manager.f90~~EfferentGraph sourcefile~io_manager.f90 io_manager.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~solver.f90 solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~common.f90 common.f90 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~config.f90 config.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~field.f90 field.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~io_manager.f90~~AfferentGraph sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_io_manager !! @brief Provides a high-level manager that orchestrates all checkpoint and !! snapshot operations. !! !! @details This module acts as a facade to the I/O subsystem. !! Its purpose is to simplify the main simulation loop by providing !! a single point of contact for all I/O-related actions. The mainprogram only !! needs to interact with the `io_manager_t` type, which then delegates tasks !! to the specialised checkpoint and snapshot managers. use m_checkpoint_manager , only : checkpoint_manager_t use m_snapshot_manager , only : snapshot_manager_t use m_solver , only : solver_t implicit none private public :: io_manager_t type :: io_manager_t type ( checkpoint_manager_t ) :: checkpoint_mgr type ( snapshot_manager_t ) :: snapshot_mgr contains procedure :: init => io_init procedure :: handle_restart => io_handle_restart procedure :: handle_io_step => io_handle_step procedure :: finalise => io_finalise procedure :: is_restart => io_is_restart end type io_manager_t contains subroutine io_init ( self , comm ) class ( io_manager_t ), intent ( inout ) :: self integer , intent ( in ) :: comm call self % checkpoint_mgr % init ( comm ) call self % snapshot_mgr % init ( comm ) end subroutine io_init subroutine io_handle_restart ( self , solver , comm ) class ( io_manager_t ), intent ( inout ) :: self class ( solver_t ), intent ( inout ) :: solver integer , intent ( in ), optional :: comm call self % checkpoint_mgr % handle_restart ( solver , comm ) end subroutine io_handle_restart subroutine io_handle_step ( self , solver , timestep , comm ) class ( io_manager_t ), intent ( inout ) :: self class ( solver_t ), intent ( in ) :: solver integer , intent ( in ) :: timestep integer , intent ( in ), optional :: comm call self % checkpoint_mgr % handle_checkpoint_step ( solver , timestep , comm ) call self % snapshot_mgr % handle_snapshot_step ( solver , timestep , comm ) end subroutine io_handle_step function io_is_restart ( self ) result ( is_restart ) class ( io_manager_t ), intent ( in ) :: self logical :: is_restart is_restart = self % checkpoint_mgr % is_restart () end function io_is_restart subroutine io_finalise ( self ) class ( io_manager_t ), intent ( inout ) :: self call self % checkpoint_mgr % finalise () call self % snapshot_mgr % finalise () end subroutine io_finalise end module m_io_manager","tags":"","url":"sourcefile/io_manager.f90.html"},{"title":"config.f90 – x3d2","text":"This file depends on sourcefile~~config.f90~~EfferentGraph sourcefile~config.f90 config.f90 sourcefile~common.f90 common.f90 sourcefile~config.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~config.f90~~AfferentGraph sourcefile~config.f90 config.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~config.f90 sourcefile~solver.f90 solver.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~config.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~config.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_config !! Contains all the namelist configurations used in x3d2 use iso_fortran_env , only : stderr => error_unit use m_common implicit none integer , parameter :: n_species_max = 99 type , abstract :: base_config_t !! All config types have a method read to initialise their data contains procedure ( read ), deferred :: read end type base_config_t type , extends ( base_config_t ) :: domain_config_t character ( len = 30 ) :: flow_case_name real ( dp ) :: L_global ( 3 ) integer :: dims_global ( 3 ), nproc_dir ( 3 ) character ( len = 20 ) :: BC_x ( 2 ), BC_y ( 2 ), BC_z ( 2 ) character ( len = 20 ) :: stretching ( 3 ) real ( dp ) :: beta ( 3 ) contains procedure :: read => read_domain_nml end type domain_config_t type , extends ( base_config_t ) :: solver_config_t real ( dp ) :: Re , dt logical :: ibm_on real ( dp ), dimension (:), allocatable :: pr_species integer :: n_iters , n_output , n_species logical :: lowmem_transeq , lowmem_fft character ( 3 ) :: poisson_solver_type , time_intg character ( 30 ) :: der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme contains procedure :: read => read_solver_nml end type solver_config_t type , extends ( base_config_t ) :: channel_config_t real ( dp ) :: noise , omega_rot logical :: rotation integer :: n_rotate contains procedure :: read => read_channel_nml end type channel_config_t type , extends ( base_config_t ) :: cylinder_config_t real ( dp ) :: init_noise ( 3 ) contains procedure :: read => read_cylinder_nml end type cylinder_config_t type , extends ( base_config_t ) :: checkpoint_config_t integer :: checkpoint_freq = 0 !! Frequency of checkpointing (0 = off) integer :: snapshot_freq = 0 !! Frequency of snapshots (0 = off) logical :: keep_checkpoint = . true . !! If false, only keep latest checkpoint character ( len = 256 ) :: checkpoint_prefix = \"checkpoint\" character ( len = 256 ) :: snapshot_prefix = \"snapshot\" logical :: restart_from_checkpoint = . false . character ( len = 256 ) :: restart_file = \"\" integer , dimension ( 3 ) :: output_stride = [ 2 , 2 , 2 ] !! Spatial stride for snapshot output logical :: snapshot_sp = . false . !! if true, snapshot in single precision contains procedure :: read => read_checkpoint_nml end type checkpoint_config_t abstract interface subroutine read ( self , nml_file , nml_string ) !& !! Assigns the member variables either from a file or text source. !! !! nml_file can be an absolute or relative path !! nml_string is a character string that contains the namelist. !! For example, nml_string=\"&foobar_nml foo=0, bar='this'/\" import :: base_config_t class ( base_config_t ) :: self character ( * ), optional , intent ( in ) :: nml_file character ( * ), optional , intent ( in ) :: nml_string end subroutine read end interface contains subroutine read_domain_nml ( self , nml_file , nml_string ) implicit none class ( domain_config_t ) :: self character ( * ), optional , intent ( in ) :: nml_file character ( * ), optional , intent ( in ) :: nml_string integer :: unit character ( len = 20 ) :: flow_case_name real ( dp ), dimension ( 3 ) :: L_global integer , dimension ( 3 ) :: dims_global integer , dimension ( 3 ) :: nproc_dir character ( len = 20 ) :: BC_x ( 2 ), BC_y ( 2 ), BC_z ( 2 ) character ( len = 20 ) :: stretching ( 3 ) = [ 'uniform' , 'uniform' , 'uniform' ] real ( dp ), dimension ( 3 ) :: beta namelist / domain_settings / flow_case_name , L_global , dims_global , & nproc_dir , BC_x , BC_y , BC_z , stretching , beta if ( present ( nml_file ) . and . present ( nml_string )) then error stop 'Reading domain config failed! & &Provide only a file name or source, not both.' else if ( present ( nml_file )) then open ( newunit = unit , file = nml_file ) read ( unit , nml = domain_settings ) close ( unit ) else if ( present ( nml_string )) then read ( nml_string , nml = domain_settings ) else error stop 'Reading domain config failed! & &Provide at least one of the following: file name or source' end if self % flow_case_name = flow_case_name self % L_global = L_global self % dims_global = dims_global self % nproc_dir = nproc_dir self % BC_x = BC_x self % BC_y = BC_y self % BC_z = BC_z self % stretching = stretching self % beta = beta end subroutine read_domain_nml subroutine read_solver_nml ( self , nml_file , nml_string ) implicit none class ( solver_config_t ) :: self character ( * ), optional , intent ( in ) :: nml_file character ( * ), optional , intent ( in ) :: nml_string integer :: unit real ( dp ) :: Re , dt logical :: ibm_on = . false . real ( dp ), dimension ( n_species_max ) :: pr_species = 1._dp integer :: n_iters , n_output , n_species = 0 !> triggers the low memory implementations logical :: lowmem_transeq = . false ., lowmem_fft = . false . character ( 3 ) :: time_intg character ( 3 ) :: poisson_solver_type = 'FFT' character ( 30 ) :: der1st_scheme = 'compact6' , der2nd_scheme = 'compact6' , & interpl_scheme = 'classic' , stagder_scheme = 'compact6' namelist / solver_params / Re , dt , n_iters , n_output , poisson_solver_type , & n_species , pr_species , lowmem_transeq , lowmem_fft , & time_intg , der1st_scheme , der2nd_scheme , interpl_scheme , & stagder_scheme , ibm_on if ( present ( nml_file ) . and . present ( nml_string )) then error stop 'Reading solver config failed! & &Provide only a file name or source, not both.' else if ( present ( nml_file )) then open ( newunit = unit , file = nml_file ) read ( unit , nml = solver_params ) close ( unit ) else if ( present ( nml_string )) then read ( nml_string , nml = solver_params ) else error stop 'Reading solver config failed! & &Provide at least one of the following: file name or source' end if self % Re = Re self % dt = dt self % n_iters = n_iters self % n_output = n_output self % ibm_on = ibm_on self % n_species = n_species if ( n_species > 0 ) self % pr_species = pr_species ( 1 : n_species ) self % lowmem_transeq = lowmem_transeq self % lowmem_fft = lowmem_fft self % poisson_solver_type = poisson_solver_type self % time_intg = time_intg self % der1st_scheme = der1st_scheme self % der2nd_scheme = der2nd_scheme self % interpl_scheme = interpl_scheme self % stagder_scheme = stagder_scheme end subroutine read_solver_nml subroutine read_channel_nml ( self , nml_file , nml_string ) implicit none class ( channel_config_t ) :: self character ( * ), optional , intent ( in ) :: nml_file character ( * ), optional , intent ( in ) :: nml_string integer :: unit real ( dp ) :: noise , omega_rot logical :: rotation integer :: n_rotate namelist / channel_nml / noise , rotation , omega_rot , n_rotate if ( present ( nml_file ) . and . present ( nml_string )) then error stop 'Reading channel config failed! & &Provide only a file name or source, not both.' else if ( present ( nml_file )) then open ( newunit = unit , file = nml_file ) read ( unit , nml = channel_nml ) close ( unit ) else if ( present ( nml_string )) then read ( nml_string , nml = channel_nml ) else error stop 'Reading channel config failed! & &Provide at least one of the following: file name or source' end if self % noise = noise self % rotation = rotation self % omega_rot = omega_rot self % n_rotate = n_rotate end subroutine read_channel_nml subroutine read_cylinder_nml ( self , nml_file , nml_string ) implicit none class ( cylinder_config_t ) :: self character ( * ), optional , intent ( in ) :: nml_file character ( * ), optional , intent ( in ) :: nml_string integer :: unit real ( dp ) :: init_noise ( 3 ) namelist / cylinder_nml / init_noise if ( present ( nml_file ) . and . present ( nml_string )) then error stop 'Reading cylinder config failed! & &Provide only a file name or source, not both.' else if ( present ( nml_file )) then open ( newunit = unit , file = nml_file ) read ( unit , nml = cylinder_nml ) close ( unit ) else if ( present ( nml_string )) then read ( nml_string , nml = cylinder_nml ) else error stop 'Reading cylinder config failed! & &Provide at least one of the following: file name or source' end if self % init_noise = init_noise end subroutine read_cylinder_nml subroutine read_checkpoint_nml ( self , nml_file , nml_string ) implicit none class ( checkpoint_config_t ) :: self character ( * ), optional , intent ( in ) :: nml_file character ( * ), optional , intent ( in ) :: nml_string integer :: unit , ierr integer :: checkpoint_freq = 0 integer :: snapshot_freq = 0 logical :: keep_checkpoint = . false . character ( len = 256 ) :: checkpoint_prefix = \"checkpoint\" character ( len = 256 ) :: snapshot_prefix = \"snapshot\" logical :: restart_from_checkpoint = . false . character ( len = 256 ) :: restart_file = \"\" integer , dimension ( 3 ) :: output_stride = [ 1 , 1 , 1 ] logical :: snapshot_sp = . false . namelist / checkpoint_params / checkpoint_freq , snapshot_freq , & keep_checkpoint , checkpoint_prefix , snapshot_prefix , & restart_from_checkpoint , restart_file , output_stride , snapshot_sp if ( present ( nml_file ) . and . present ( nml_string )) then error stop 'Reading checkpoint config failed! & &Provide only a file name or source, not both.' else if ( present ( nml_file )) then open ( newunit = unit , file = nml_file , iostat = ierr ) if ( ierr == 0 ) then read ( unit , nml = checkpoint_params , iostat = ierr ) if ( ierr /= 0 . and . ierr /= - 1 ) & print * , 'WARNING: Error in checkpoint_params namelist, & & using defaults' end if close ( unit ) else if ( present ( nml_string )) then read ( nml_string , nml = checkpoint_params ) else error stop 'Reading checkpoint config failed! & &Provide at least one of the following: file name or source' end if self % checkpoint_freq = checkpoint_freq self % snapshot_freq = snapshot_freq self % keep_checkpoint = keep_checkpoint self % checkpoint_prefix = checkpoint_prefix self % snapshot_prefix = snapshot_prefix self % restart_from_checkpoint = restart_from_checkpoint self % restart_file = restart_file self % output_stride = output_stride self % snapshot_sp = snapshot_sp end subroutine read_checkpoint_nml end module m_config","tags":"","url":"sourcefile/config.f90.html"},{"title":"generic.f90 – x3d2","text":"This file depends on sourcefile~~generic.f90~~EfferentGraph sourcefile~generic.f90 generic.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~generic.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~common.f90 common.f90 sourcefile~generic.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~generic.f90->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~generic.f90->sourcefile~mesh.f90 sourcefile~solver.f90 solver.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90->sourcefile~common.f90 sourcefile~base_case.f90->sourcefile~field.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~config.f90 config.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~generic.f90~~AfferentGraph sourcefile~generic.f90 generic.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_case_generic !! An example case set up to run and sustain a freestream flow. !! This is a good place to start for adding a new flow case. use iso_fortran_env , only : stderr => error_unit use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_base_case , only : base_case_t use m_common , only : dp , VERT use m_field , only : field_t use m_mesh , only : mesh_t use m_solver , only : init implicit none type , extends ( base_case_t ) :: case_generic_t contains procedure :: boundary_conditions => boundary_conditions_generic procedure :: initial_conditions => initial_conditions_generic procedure :: forcings => forcings_generic procedure :: pre_correction => pre_correction_generic procedure :: postprocess => postprocess_generic end type case_generic_t interface case_generic_t module procedure case_generic_init end interface case_generic_t contains function case_generic_init ( backend , mesh , host_allocator ) result ( flow_case ) implicit none class ( base_backend_t ), target , intent ( inout ) :: backend type ( mesh_t ), target , intent ( inout ) :: mesh type ( allocator_t ), target , intent ( inout ) :: host_allocator type ( case_generic_t ) :: flow_case call flow_case % case_init ( backend , mesh , host_allocator ) end function case_generic_init subroutine boundary_conditions_generic ( self ) implicit none class ( case_generic_t ) :: self end subroutine boundary_conditions_generic subroutine initial_conditions_generic ( self ) implicit none class ( case_generic_t ) :: self call self % solver % u % fill ( 1._dp ) call self % solver % v % fill ( 0._dp ) call self % solver % w % fill ( 0._dp ) call self % solver % u % set_data_loc ( VERT ) call self % solver % v % set_data_loc ( VERT ) call self % solver % w % set_data_loc ( VERT ) end subroutine initial_conditions_generic subroutine forcings_generic ( self , du , dv , dw , iter ) implicit none class ( case_generic_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw integer , intent ( in ) :: iter end subroutine forcings_generic subroutine pre_correction_generic ( self , u , v , w ) implicit none class ( case_generic_t ) :: self class ( field_t ), intent ( inout ) :: u , v , w end subroutine pre_correction_generic subroutine postprocess_generic ( self , iter , t ) implicit none class ( case_generic_t ) :: self integer , intent ( in ) :: iter real ( dp ), intent ( in ) :: t if ( self % solver % mesh % par % is_root ()) then print * , 'time =' , t , 'iteration =' , iter end if call self % print_enstrophy ( self % solver % u , self % solver % v , self % solver % w ) call self % print_div_max_mean ( self % solver % u , self % solver % v , self % solver % w ) end subroutine postprocess_generic end module m_case_generic","tags":"","url":"sourcefile/generic.f90.html"},{"title":"io_session.f90 – x3d2","text":"This file depends on sourcefile~~io_session.f90~~EfferentGraph sourcefile~io_session.f90 io_session.f90 sourcefile~common.f90 common.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io.f90 io.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~io_session.f90~~AfferentGraph sourcefile~io_session.f90 io_session.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~solver.f90 solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_io_session !! @brief Provides high-level, session-based user interface for all I/O !! operations !! !! @details This module is the sole entry point for file reading and writing. !! It abstracts away all backend details and provides a type-safe interface !! for all I/O tasks. !! !! Key features: !! - Type-safe sessions: specialised `reader_session_t` and `writer_session_t` !!   types for reading and writing operations, respectively. !! - Automatic backend selection: based on compile-time options !! - Resource cleanup: memory is automatically freed when sessions !!   go out of scope (using final subroutines). !! - Simplified workflow - user only needs to manage a simple !! `open -> read/write -> close` workflow, with no need for manual file handle !!   management or explicit cleanup calls. !! !! @example !! A typical usage pattern for reading data and writing data: !! !! @code{.f90} !! use m_io_session, only: writer_session_t, reader_session_t !! !! implicit none !! !! real, dimension(:,:,:), allocatable :: temp_field !! type(writer_session_t)           :: writer !! type(reader_session_t)           :: reader !! !! ! For writing data !! call writer%open(\"output.bp\") !! call writer%write_data(\"temperature\", temp_field) !! call writer%close() !! ! Note: writer is automatically cleaned up when it goes out of scope !! !! ! For reading data !! call reader%open(\"input.bp\") !! call reader%read_data(\"temperature\", temp_field) !! call reader%close() !! ! Note: reader is automatically cleaned up when it goes out of scope !! @endcode !! !! @note Users should only use the types provided by this module. The lower-level !! modules like `m_io_base` and `m_io_backend` are internal components and should !! never be used directly in user code. use m_common , only : dp , i8 use m_io_base , only : io_reader_t , io_writer_t , io_file_t , & io_mode_read , io_mode_write use m_io_backend , only : allocate_io_reader , allocate_io_writer implicit none private !! Public session types for user interaction public :: reader_session_t , writer_session_t !> Base type for common session functionality type :: io_session_base_t private class ( io_file_t ), allocatable :: file logical :: is_open = . false . logical :: is_functional = . true . ! false for dummy I/O contains procedure :: is_session_open procedure :: is_session_functional procedure :: close => session_base_close end type io_session_base_t !> **PRIMARY TYPE FOR READING DATA** - Use this for all file reading operations !! This is the only interface users should use for reading data. !! Provides type-safe reading operations with automatic backend selection. !! !! Usage example: !!   type(reader_session_t) :: reader_session !!   call reader_session%open(\"checkpoint.bp\", MPI_COMM_WORLD) !!   call reader_session%read_data(\"timestep\", timestep) !!   call reader_session%read_data(\"velocity_u\", u_field, start_dims, count_dims) !!   call reader_session%close() type , extends ( io_session_base_t ) :: reader_session_t private class ( io_reader_t ), allocatable :: reader contains ! Open/close operations procedure :: open => reader_session_open ! Generic read_data interface generic :: read_data => read_data_i8 , read_data_integer , & read_data_real , read_data_array_3d procedure , private :: read_data_i8 procedure , private :: read_data_integer procedure , private :: read_data_real procedure , private :: read_data_array_3d final :: reader_session_finaliser end type reader_session_t !> **PRIMARY TYPE FOR WRITING DATA** - Use this for all file writing operations !! This is the only interface users should use for writing data. !! Provides type-safe writing operations with automatic backend selection. !! !! Usage example: !!   type(writer_session_t) :: writer_session !!   call writer_session%open(\"output.bp\", MPI_COMM_WORLD) !!   call writer_session%write_data(\"timestep\", current_step) !!   call writer_session%write_data(\"pressure\", p_field, start_dims, count_dims) !!   call writer_session%close() !!   call writer_session%write_attribute(\"ParaView\", \"vtk_xml_content\") !!   call writer_session%close() type , extends ( io_session_base_t ) :: writer_session_t private class ( io_writer_t ), allocatable :: writer contains ! Open/close operations procedure :: open => writer_session_open procedure :: begin_step => writer_session_begin_step procedure :: end_step => writer_session_end_step ! Generic write_data interface generic :: write_data => write_data_i8 , write_data_integer , & write_data_real , write_data_array_3d procedure , private :: write_data_i8 procedure , private :: write_data_integer procedure , private :: write_data_real procedure , private :: write_data_array_3d ! Write attribute interface procedure :: write_attribute => session_write_attribute final :: writer_session_finaliser end type writer_session_t contains ! Base session procedures logical function is_session_open ( self ) class ( io_session_base_t ), intent ( in ) :: self is_session_open = self % is_open end function is_session_open logical function is_session_functional ( self ) class ( io_session_base_t ), intent ( in ) :: self is_session_functional = self % is_functional end function is_session_functional subroutine session_base_close ( self ) class ( io_session_base_t ), intent ( inout ) :: self if (. not . self % is_open ) return call self % file % close () self % is_open = . false . end subroutine session_base_close ! Reader session procedures subroutine reader_session_open ( self , filename , comm ) class ( reader_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: comm if ( self % is_open ) error stop \"IO session already open\" call allocate_io_reader ( self % reader ) call self % reader % init ( comm , \"session_reader\" ) self % file = self % reader % open ( filename , io_mode_read , comm ) call self % file % begin_step () self % is_open = . true . end subroutine reader_session_open subroutine read_data_i8 ( self , variable_name , value ) class ( reader_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer ( i8 ), intent ( out ) :: value if (. not . self % is_open ) error stop \"IO session not open\" call self % reader % read_data ( variable_name , value , self % file ) end subroutine read_data_i8 subroutine read_data_integer ( self , variable_name , value ) class ( reader_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer , intent ( out ) :: value if (. not . self % is_open ) error stop \"IO session not open\" call self % reader % read_data ( variable_name , value , self % file ) end subroutine read_data_integer subroutine read_data_real ( self , variable_name , value ) class ( reader_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( out ) :: value if (. not . self % is_open ) error stop \"IO session not open\" call self % reader % read_data ( variable_name , value , self % file ) end subroutine read_data_real subroutine read_data_array_3d ( & self , variable_name , array , start_dims , count_dims , shape_dims & ) class ( reader_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( inout ) :: array (:, :, :) integer ( i8 ), intent ( in ), optional :: start_dims ( 3 ) integer ( i8 ), intent ( in ), optional :: count_dims ( 3 ) integer ( i8 ), intent ( in ), optional :: shape_dims ( 3 ) if (. not . self % is_open ) error stop \"IO session not open\" call self % reader % read_data ( & variable_name , array , self % file , & start_dims = start_dims , count_dims = count_dims , shape_dims = shape_dims & ) end subroutine read_data_array_3d ! Writer session procedures subroutine writer_session_open ( self , filename , comm ) class ( writer_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: comm if ( self % is_open ) error stop \"IO session already open\" call allocate_io_writer ( self % writer ) call self % writer % init ( comm , \"session_writer\" ) self % file = self % writer % open ( filename , io_mode_write , comm ) call self % file % begin_step () ! check if backend is functional self % is_functional = self % file % is_file_functional () self % is_open = . true . ! always mark session as open so operations don't fail end subroutine writer_session_open subroutine write_data_i8 ( self , variable_name , value ) class ( writer_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer ( i8 ), intent ( in ) :: value if (. not . self % is_open ) error stop \"IO session not open\" call self % writer % write_data ( variable_name , value , self % file ) end subroutine write_data_i8 subroutine write_data_integer ( self , variable_name , value ) class ( writer_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer , intent ( in ) :: value if (. not . self % is_open ) error stop \"IO session not open\" call self % writer % write_data ( variable_name , value , self % file ) end subroutine write_data_integer subroutine write_data_real ( self , variable_name , value , use_sp ) class ( writer_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( in ) :: value logical , intent ( in ), optional :: use_sp if (. not . self % is_open ) error stop \"IO session not open\" call self % writer % write_data ( variable_name , value , self % file , use_sp ) end subroutine write_data_real subroutine write_data_array_3d ( & self , variable_name , array , shape_dims , start_dims , count_dims , use_sp & ) class ( writer_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( in ) :: array (:, :, :) integer ( i8 ), intent ( in ) :: shape_dims ( 3 ) integer ( i8 ), intent ( in ) :: start_dims ( 3 ) integer ( i8 ), intent ( in ) :: count_dims ( 3 ) logical , intent ( in ), optional :: use_sp if (. not . self % is_open ) error stop \"IO session not open\" call self % writer % write_data ( & variable_name , array , self % file , & shape_dims , start_dims , count_dims , use_sp & ) end subroutine write_data_array_3d subroutine session_write_attribute ( self , attribute_name , attribute_value ) class ( writer_session_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: attribute_name character ( len =* ), intent ( in ) :: attribute_value if (. not . self % is_open ) error stop \"IO session not open\" call self % writer % write_attribute ( & attribute_name , attribute_value , self % file & ) end subroutine session_write_attribute subroutine writer_session_begin_step ( self ) !! Begin a new timestep for writing (used for time-series in single file) class ( writer_session_t ), intent ( inout ) :: self if (. not . self % is_open ) error stop \"IO session not open\" call self % file % begin_step () end subroutine writer_session_begin_step subroutine writer_session_end_step ( self ) !! End the current timestep for writing class ( writer_session_t ), intent ( inout ) :: self if (. not . self % is_open ) error stop \"IO session not open\" call self % file % end_step () end subroutine writer_session_end_step !> Finalisation for reader_session_t !! Called automatically when a reader_session_t goes out of scope !! Ensures proper cleanup even if user forgets to call close subroutine reader_session_finaliser ( self ) type ( reader_session_t ) :: self if ( self % is_open ) call self % close () if ( allocated ( self % file )) then deallocate ( self % file ) end if if ( allocated ( self % reader )) then call self % reader % finalise () deallocate ( self % reader ) end if end subroutine reader_session_finaliser !> Finalisation for writer_session_t !! Called automatically when a writer_session_t goes out of scope !! Ensures proper cleanup even if user forgets to call close subroutine writer_session_finaliser ( self ) type ( writer_session_t ) :: self if ( self % is_open ) call self % close () if ( allocated ( self % file )) then deallocate ( self % file ) end if if ( allocated ( self % writer )) then call self % writer % finalise () deallocate ( self % writer ) end if end subroutine writer_session_finaliser end module m_io_session","tags":"","url":"sourcefile/io_session.f90.html"},{"title":"spectral_processing.f90 – x3d2","text":"This file depends on sourcefile~~spectral_processing.f90~~EfferentGraph sourcefile~spectral_processing.f90 spectral_processing.f90 sourcefile~common.f90 common.f90 sourcefile~spectral_processing.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~spectral_processing.f90~~AfferentGraph sourcefile~spectral_processing.f90 spectral_processing.f90 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~spectral_processing.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_omp_spectral use m_common , only : dp implicit none contains subroutine process_spectral_000 ( & div_u , waves , nx_spec , ny_spec , nz_spec , x_sp_st , y_sp_st , z_sp_st , & nx , ny , nz , ax , bx , ay , by , az , bz & ) !! Post-process div U* in spectral space for all periodic BCs. !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none !> Divergence of velocity in spectral space complex ( dp ), intent ( inout ), dimension (:, :, :) :: div_u !> Spectral equivalence constants complex ( dp ), intent ( in ), dimension (:, :, :) :: waves real ( dp ), intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz !> Grid size in spectral space integer , intent ( in ) :: nx_spec , ny_spec , nz_spec !> Offsets in the permuted pencils in spectral space integer , intent ( in ) :: x_sp_st , y_sp_st , z_sp_st !> Global cell size integer , intent ( in ) :: nx , ny , nz integer :: i , j , k , ix , iy , iz real ( dp ) :: tmp_r , tmp_c , div_r , div_c !$omp parallel do private(div_r, div_c, ix, iy, iz, tmp_r, tmp_c) collapse(3) do k = 1 , nz_spec do j = 1 , ny_spec do i = 1 , nx_spec ! normalisation div_r = real ( div_u ( i , j , k ), kind = dp ) / nx / ny / nz div_c = aimag ( div_u ( i , j , k )) / nx / ny / nz ix = i + x_sp_st iy = j + y_sp_st iz = k + z_sp_st ! post-process forward ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) + tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in y tmp_r = div_r tmp_c = div_c div_r = tmp_r * by ( iy ) + tmp_c * ay ( iy ) div_c = tmp_c * by ( iy ) - tmp_r * ay ( iy ) if ( iy > ny / 2 + 1 ) div_r = - div_r if ( iy > ny / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) - tmp_r * ax ( ix ) ! Solve Poisson tmp_r = real ( waves ( i , j , k ), kind = dp ) tmp_c = aimag ( waves ( i , j , k )) if (( tmp_r < 1.e-16_dp ) . or . ( tmp_c < 1.e-16_dp )) then div_r = 0._dp ; div_c = 0._dp else div_r = - div_r / tmp_r div_c = - div_c / tmp_c end if ! post-process backward ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) - tmp_c * az ( iz ) div_c = - tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in y tmp_r = div_r tmp_c = div_c div_r = tmp_r * by ( iy ) + tmp_c * ay ( iy ) div_c = tmp_c * by ( iy ) - tmp_r * ay ( iy ) if ( iy > ny / 2 + 1 ) div_r = - div_r if ( iy > ny / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = - tmp_c * bx ( ix ) + tmp_r * ax ( ix ) ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end do end do !$omp end parallel do end subroutine process_spectral_000 subroutine process_spectral_010 ( & div_u , waves , nx_spec , ny_spec , nz_spec , x_sp_st , y_sp_st , z_sp_st , & nx , ny , nz , ax , bx , ay , by , az , bz & ) !! Post-process div U* in spectral space, for non-periodic BC in y-dir. !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none !> Divergence of velocity in spectral space complex ( dp ), intent ( inout ), dimension (:, :, :) :: div_u !> Spectral equivalence constants complex ( dp ), intent ( in ), dimension (:, :, :) :: waves real ( dp ), intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz !> Grid size in spectral space integer , intent ( in ) :: nx_spec , ny_spec , nz_spec !> Offsets in the permuted pencils in spectral space integer , intent ( in ) :: x_sp_st , y_sp_st , z_sp_st !> Global cell size integer , intent ( in ) :: nx , ny , nz integer :: i , j , k , ix , iy , iz , iy_r real ( dp ) :: tmp_r , tmp_c , div_r , div_c , l_r , l_c , r_r , r_c !$omp parallel do private(div_r, div_c, ix, iz, tmp_r, tmp_c) collapse(3) do k = 1 , nz_spec do j = 1 , ny_spec do i = 1 , nx_spec ix = i + x_sp_st iz = k + z_sp_st ! normalisation div_r = real ( div_u ( i , j , k ), kind = dp ) / nx / ny / nz div_c = aimag ( div_u ( i , j , k )) / nx / ny / nz ! postprocess in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) + tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! postprocess in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) - tmp_r * ax ( ix ) if ( ix > nx / 2 + 1 ) div_r = - div_r if ( ix > nx / 2 + 1 ) div_c = - div_c ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end do end do !$omp end parallel do !$omp parallel do private(div_r, div_c, iy, iy_r, l_r, l_c, r_r, r_c) collapse(3) do k = 1 , nz_spec do j = 2 , ny_spec / 2 + 1 do i = 1 , nx_spec iy = j + y_sp_st iy_r = ny_spec - j + 2 + y_sp_st l_r = real ( div_u ( i , j , k ), kind = dp ) l_c = aimag ( div_u ( i , j , k )) r_r = real ( div_u ( i , ny_spec - j + 2 , k ), kind = dp ) r_c = aimag ( div_u ( i , ny_spec - j + 2 , k )) ! update the entry div_u ( i , j , k ) = 0.5_dp * cmplx ( & !& l_r * by ( iy ) + l_c * ay ( iy ) + r_r * by ( iy ) - r_c * ay ( iy ), & - l_r * ay ( iy ) + l_c * by ( iy ) + r_r * ay ( iy ) + r_c * by ( iy ), kind = dp & ) div_u ( i , ny_spec - j + 2 , k ) = 0.5_dp * cmplx ( & !& r_r * by ( iy_r ) + r_c * ay ( iy_r ) + l_r * by ( iy_r ) - l_c * ay ( iy_r ), & - r_r * ay ( iy_r ) + r_c * by ( iy_r ) + l_r * ay ( iy_r ) + l_c * by ( iy_r ), & kind = dp & ) end do end do end do !$omp end parallel do ! Solve Poisson !$omp parallel do private(div_r, div_c, tmp_r, tmp_c) collapse(3) do k = 1 , nz_spec do j = 1 , ny_spec do i = 1 , nx_spec div_r = real ( div_u ( i , j , k ), kind = dp ) div_c = aimag ( div_u ( i , j , k )) tmp_r = real ( waves ( i , j , k ), kind = dp ) tmp_c = aimag ( waves ( i , j , k )) if ( abs ( tmp_r ) < 1.e-16_dp ) then div_r = 0._dp else div_r = - div_r / tmp_r end if if ( abs ( tmp_c ) < 1.e-16_dp ) then div_c = 0._dp else div_c = - div_c / tmp_c end if ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) if ( i == nx / 2 + 1 . and . k == nz / 2 + 1 ) div_u ( i , j , k ) = 0._dp end do end do end do !$omp end parallel do ! post-process backward !$omp parallel do private(div_r, div_c, iy, iy_r, l_r, l_c, r_r, r_c) collapse(3) do k = 1 , nz_spec do j = 2 , ny_spec / 2 + 1 do i = 1 , nx_spec iy = j + y_sp_st iy_r = ny_spec - j + 2 + y_sp_st l_r = real ( div_u ( i , j , k ), kind = dp ) l_c = aimag ( div_u ( i , j , k )) r_r = real ( div_u ( i , ny_spec - j + 2 , k ), kind = dp ) r_c = aimag ( div_u ( i , ny_spec - j + 2 , k )) ! update the entry div_u ( i , j , k ) = cmplx ( & !& l_r * by ( iy ) - l_c * ay ( iy ) + r_r * ay ( iy ) + r_c * by ( iy ), & l_r * ay ( iy ) + l_c * by ( iy ) - r_r * by ( iy ) + r_c * ay ( iy ), kind = dp & ) div_u ( i , ny_spec - j + 2 , k ) = cmplx ( & !& r_r * by ( iy_r ) - r_c * ay ( iy_r ) + l_r * ay ( iy_r ) + l_c * by ( iy_r ), & r_r * ay ( iy_r ) + r_c * by ( iy_r ) - l_r * by ( iy_r ) + l_c * ay ( iy_r ), & kind = dp & ) end do end do end do !$omp end parallel do !$omp parallel do private(div_r, div_c, ix, iz, tmp_r, tmp_c) collapse(3) do k = 1 , nz_spec do j = 1 , ny_spec do i = 1 , nx_spec ix = i + x_sp_st iz = k + z_sp_st div_r = real ( div_u ( i , j , k ), kind = dp ) div_c = aimag ( div_u ( i , j , k )) ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) - tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) + tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) - tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) + tmp_r * ax ( ix ) if ( ix > nx / 2 + 1 ) div_r = - div_r if ( ix > nx / 2 + 1 ) div_c = - div_c ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end do end do !$omp end parallel do end subroutine process_spectral_010 end module m_omp_spectral","tags":"","url":"sourcefile/spectral_processing.f90.html"},{"title":"sendrecv.f90 – x3d2","text":"This file depends on sourcefile~~sendrecv.f90~~EfferentGraph sourcefile~sendrecv.f90 sendrecv.f90 sourcefile~common.f90 common.f90 sourcefile~sendrecv.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~sendrecv.f90~~AfferentGraph sourcefile~sendrecv.f90 sendrecv.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~sendrecv.f90 sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~backend.f90->sourcefile~exec_dist.f90~2 sourcefile~exec_dist.f90~2->sourcefile~sendrecv.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_omp_sendrecv use mpi use m_common , only : dp , MPI_X3D2_DP implicit none contains subroutine sendrecv_fields ( f_recv_s , f_recv_e , f_send_s , f_send_e , & n_data , nproc , prev , next ) implicit none real ( dp ), dimension (:, :, :), intent ( out ) :: f_recv_s , f_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: f_send_s , f_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 4 ), err ( 4 ), ierr , tag = 1234 if ( nproc == 1 ) then f_recv_s = f_send_e f_recv_e = f_send_s else call MPI_Isend ( f_send_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f_recv_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f_send_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f_recv_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Waitall ( 4 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_fields end module m_omp_sendrecv","tags":"","url":"sourcefile/sendrecv.f90.html"},{"title":"backend.f90 – x3d2","text":"This file depends on sourcefile~~backend.f90~~EfferentGraph sourcefile~backend.f90 backend.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~backend.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~common.f90 common.f90 sourcefile~backend.f90->sourcefile~common.f90 sourcefile~common.f90~2 common.f90 sourcefile~backend.f90->sourcefile~common.f90~2 sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~backend.f90->sourcefile~exec_dist.f90~2 sourcefile~field.f90 field.f90 sourcefile~backend.f90->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~backend.f90->sourcefile~mesh.f90 sourcefile~ordering.f90 ordering.f90 sourcefile~backend.f90->sourcefile~ordering.f90 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~sendrecv.f90 sendrecv.f90 sourcefile~backend.f90->sourcefile~sendrecv.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90->sourcefile~tdsops.f90~2 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~exec_dist.f90~2->sourcefile~common.f90 sourcefile~exec_dist.f90~2->sourcefile~common.f90~2 sourcefile~exec_dist.f90~2->sourcefile~sendrecv.f90 sourcefile~exec_dist.f90~2->sourcefile~tdsops.f90~2 sourcefile~distributed.f90 distributed.f90 sourcefile~exec_dist.f90~2->sourcefile~distributed.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~ordering.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90~3->sourcefile~common.f90 sourcefile~poisson_fft.f90~3->sourcefile~field.f90 sourcefile~poisson_fft.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~3->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~spectral_processing.f90 spectral_processing.f90 sourcefile~poisson_fft.f90~3->sourcefile~spectral_processing.f90 sourcefile~sendrecv.f90->sourcefile~common.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~distributed.f90->sourcefile~common.f90 sourcefile~distributed.f90->sourcefile~common.f90~2 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~spectral_processing.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~backend.f90~~AfferentGraph sourcefile~backend.f90 backend.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_omp_backend use mpi use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_common , only : dp , MPI_X3D2_DP , get_dirs_from_rdr , move_data_loc , & DIR_X , DIR_Y , DIR_Z , DIR_C , NULL_LOC , & X_FACE , Y_FACE , Z_FACE , VERT use m_field , only : field_t use m_mesh , only : mesh_t use m_ordering , only : get_index_reordering use m_tdsops , only : dirps_t , tdsops_t use m_omp_common , only : SZ use m_omp_exec_dist , only : exec_dist_tds_compact , exec_dist_transeq_compact use m_omp_sendrecv , only : sendrecv_fields implicit none private :: transeq_halo_exchange , transeq_dist_component type , extends ( base_backend_t ) :: omp_backend_t !character(len=*), parameter :: name = 'omp' real ( dp ), allocatable , dimension (:, :, :) :: & u_recv_s , u_recv_e , u_send_s , u_send_e , & v_recv_s , v_recv_e , v_send_s , v_send_e , & w_recv_s , w_recv_e , w_send_s , w_send_e , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e contains procedure :: alloc_tdsops => alloc_omp_tdsops procedure :: transeq_x => transeq_x_omp procedure :: transeq_y => transeq_y_omp procedure :: transeq_z => transeq_z_omp procedure :: transeq_species => transeq_species_omp procedure :: tds_solve => tds_solve_omp procedure :: reorder => reorder_omp procedure :: sum_yintox => sum_yintox_omp procedure :: sum_zintox => sum_zintox_omp procedure :: veccopy => veccopy_omp procedure :: vecadd => vecadd_omp procedure :: vecmult => vecmult_omp procedure :: scalar_product => scalar_product_omp procedure :: field_max_mean => field_max_mean_omp procedure :: field_scale => field_scale_omp procedure :: field_shift => field_shift_omp procedure :: field_set_face => field_set_face_omp procedure :: field_volume_integral => field_volume_integral_omp procedure :: copy_data_to_f => copy_data_to_f_omp procedure :: copy_f_to_data => copy_f_to_data_omp procedure :: init_poisson_fft => init_omp_poisson_fft procedure :: transeq_omp_dist end type omp_backend_t interface omp_backend_t module procedure init end interface omp_backend_t contains function init ( mesh , allocator ) result ( backend ) implicit none type ( mesh_t ), target , intent ( inout ) :: mesh class ( allocator_t ), target , intent ( inout ) :: allocator type ( omp_backend_t ) :: backend integer :: n_groups call backend % base_init () select type ( allocator ) type is ( allocator_t ) ! class level access to the allocator backend % allocator => allocator end select backend % mesh => mesh n_groups = maxval ([ backend % allocator % get_n_groups ( DIR_X ), & backend % allocator % get_n_groups ( DIR_Y ), & backend % allocator % get_n_groups ( DIR_Z )]) allocate ( backend % u_send_s ( SZ , backend % n_halo , n_groups )) allocate ( backend % u_send_e ( SZ , backend % n_halo , n_groups )) allocate ( backend % u_recv_s ( SZ , backend % n_halo , n_groups )) allocate ( backend % u_recv_e ( SZ , backend % n_halo , n_groups )) allocate ( backend % v_send_s ( SZ , backend % n_halo , n_groups )) allocate ( backend % v_send_e ( SZ , backend % n_halo , n_groups )) allocate ( backend % v_recv_s ( SZ , backend % n_halo , n_groups )) allocate ( backend % v_recv_e ( SZ , backend % n_halo , n_groups )) allocate ( backend % w_send_s ( SZ , backend % n_halo , n_groups )) allocate ( backend % w_send_e ( SZ , backend % n_halo , n_groups )) allocate ( backend % w_recv_s ( SZ , backend % n_halo , n_groups )) allocate ( backend % w_recv_e ( SZ , backend % n_halo , n_groups )) allocate ( backend % du_send_s ( SZ , 1 , n_groups )) allocate ( backend % du_send_e ( SZ , 1 , n_groups )) allocate ( backend % du_recv_s ( SZ , 1 , n_groups )) allocate ( backend % du_recv_e ( SZ , 1 , n_groups )) allocate ( backend % dud_send_s ( SZ , 1 , n_groups )) allocate ( backend % dud_send_e ( SZ , 1 , n_groups )) allocate ( backend % dud_recv_s ( SZ , 1 , n_groups )) allocate ( backend % dud_recv_e ( SZ , 1 , n_groups )) allocate ( backend % d2u_send_s ( SZ , 1 , n_groups )) allocate ( backend % d2u_send_e ( SZ , 1 , n_groups )) allocate ( backend % d2u_recv_s ( SZ , 1 , n_groups )) allocate ( backend % d2u_recv_e ( SZ , 1 , n_groups )) end function init subroutine alloc_omp_tdsops ( & self , tdsops , n_tds , delta , operation , scheme , bc_start , bc_end , & stretch , stretch_correct , n_halo , from_to , sym , c_nu , nu0_nu & ) implicit none class ( omp_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: n_tds real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: operation , scheme integer , intent ( in ) :: bc_start , bc_end real ( dp ), optional , intent ( in ) :: stretch (:), stretch_correct (:) integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu allocate ( tdsops_t :: tdsops ) select type ( tdsops ) type is ( tdsops_t ) tdsops = tdsops_t ( n_tds , delta , operation , scheme , bc_start , bc_end , & stretch , stretch_correct , n_halo , from_to , sym , & c_nu , nu0_nu ) end select end subroutine alloc_omp_tdsops subroutine transeq_x_omp ( self , du , dv , dw , u , v , w , nu , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps call self % transeq_omp_dist ( du , dv , dw , u , v , w , nu , dirps ) end subroutine transeq_x_omp subroutine transeq_y_omp ( self , du , dv , dw , u , v , w , nu , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass v, u, w call self % transeq_omp_dist ( dv , du , dw , v , u , w , nu , dirps ) end subroutine transeq_y_omp subroutine transeq_z_omp ( self , du , dv , dw , u , v , w , nu , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass w, u, v call self % transeq_omp_dist ( dw , du , dv , w , u , v , nu , dirps ) end subroutine transeq_z_omp subroutine transeq_species_omp ( self , dspec , uvw , spec , nu , dirps , sync ) !! Compute the convection and diffusion for the given field !! in the given direction. !! Halo exchange for the given field is necessary !! When sync is true, halo exchange of momentum is necessary implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: dspec class ( field_t ), intent ( in ) :: uvw , spec real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps logical , intent ( in ) :: sync integer :: n_groups n_groups = self % allocator % get_n_groups ( dirps % dir ) ! Halo exchange for momentum if needed if ( sync ) then call copy_into_buffers ( self % u_send_s , self % u_send_e , uvw % data , & dirps % der1st % n_tds , n_groups ) call sendrecv_fields ( self % u_recv_s , self % u_recv_e , & self % u_send_s , self % u_send_e , & SZ * self % n_halo * n_groups , & self % mesh % par % nproc_dir ( dirps % dir ), & self % mesh % par % pprev ( dirps % dir ), & self % mesh % par % pnext ( dirps % dir )) end if ! Halo exchange for the given field call copy_into_buffers ( self % v_send_s , self % v_send_e , spec % data , & dirps % der1st % n_tds , n_groups ) call sendrecv_fields ( self % v_recv_s , self % v_recv_e , & self % v_send_s , self % v_send_e , & SZ * self % n_halo * n_groups , & self % mesh % par % nproc_dir ( dirps % dir ), & self % mesh % par % pprev ( dirps % dir ), & self % mesh % par % pnext ( dirps % dir )) ! combine convection and diffusion call transeq_dist_component ( self , dspec , spec , uvw , nu , & self % v_recv_s , self % v_recv_e , & self % u_recv_s , self % u_recv_e , & dirps % der1st , dirps % der1st_sym , & dirps % der2nd , dirps % dir ) end subroutine transeq_species_omp subroutine transeq_omp_dist ( self , du , dv , dw , u , v , w , nu , dirps ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps call transeq_halo_exchange ( self , u , v , w , dirps % dir ) call transeq_dist_component ( self , du , u , u , nu , & self % u_recv_s , self % u_recv_e , & self % u_recv_s , self % u_recv_e , & dirps % der1st , dirps % der1st_sym , & dirps % der2nd , dirps % dir ) call transeq_dist_component ( self , dv , v , u , nu , & self % v_recv_s , self % v_recv_e , & self % u_recv_s , self % u_recv_e , & dirps % der1st_sym , dirps % der1st , & dirps % der2nd_sym , dirps % dir ) call transeq_dist_component ( self , dw , w , u , nu , & self % w_recv_s , self % w_recv_e , & self % u_recv_s , self % u_recv_e , & dirps % der1st_sym , dirps % der1st , & dirps % der2nd_sym , dirps % dir ) end subroutine transeq_omp_dist subroutine transeq_halo_exchange ( self , u , v , w , dir ) class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: u , v , w integer , intent ( in ) :: dir integer :: n , nproc_dir , pprev , pnext integer :: n_groups n_groups = self % allocator % get_n_groups ( dir ) n = self % mesh % get_n ( u ) nproc_dir = self % mesh % par % nproc_dir ( dir ) pprev = self % mesh % par % pprev ( dir ) pnext = self % mesh % par % pnext ( dir ) call copy_into_buffers ( self % u_send_s , self % u_send_e , u % data , & n , n_groups ) call copy_into_buffers ( self % v_send_s , self % v_send_e , v % data , & n , n_groups ) call copy_into_buffers ( self % w_send_s , self % w_send_e , w % data , & n , n_groups ) call sendrecv_fields ( self % u_recv_s , self % u_recv_e , & self % u_send_s , self % u_send_e , & SZ * self % n_halo * n_groups , & nproc_dir , pprev , pnext ) call sendrecv_fields ( self % v_recv_s , self % v_recv_e , & self % v_send_s , self % v_send_e , & SZ * self % n_halo * n_groups , & nproc_dir , pprev , pnext ) call sendrecv_fields ( self % w_recv_s , self % w_recv_e , & self % w_send_s , self % w_send_e , & SZ * self % n_halo * n_groups , & nproc_dir , pprev , pnext ) end subroutine transeq_halo_exchange subroutine transeq_dist_component ( self , rhs_du , u , conv , nu , & u_recv_s , u_recv_e , & conv_recv_s , conv_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , dir ) !! Computes RHS_x&#94;u following: !! !! rhs_x&#94;u = -0.5*(conv*du/dx + d(u*conv)/dx) + nu*d2u/dx2 class ( omp_backend_t ) :: self !> The result field, it is also used as temporary storage class ( field_t ), intent ( inout ) :: rhs_du class ( field_t ), intent ( in ) :: u , conv real ( dp ), intent ( in ) :: nu real ( dp ), dimension (:, :, :), intent ( in ) :: u_recv_s , u_recv_e , & conv_recv_s , conv_recv_e class ( tdsops_t ), intent ( in ) :: tdsops_du class ( tdsops_t ), intent ( in ) :: tdsops_dud class ( tdsops_t ), intent ( in ) :: tdsops_d2u integer , intent ( in ) :: dir class ( field_t ), pointer :: d2u , dud dud => self % allocator % get_block ( dir ) d2u => self % allocator % get_block ( dir ) call exec_dist_transeq_compact ( & rhs_du % data , dud % data , d2u % data , & self % du_send_s , self % du_send_e , self % du_recv_s , self % du_recv_e , & self % dud_send_s , self % dud_send_e , self % dud_recv_s , self % dud_recv_e , & self % d2u_send_s , self % d2u_send_e , self % d2u_recv_s , self % d2u_recv_e , & u % data , u_recv_s , u_recv_e , & conv % data , conv_recv_s , conv_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , nu , & self % mesh % par % nproc_dir ( dir ), self % mesh % par % pprev ( dir ), & self % mesh % par % pnext ( dir ), self % allocator % get_n_groups ( dir )) call rhs_du % set_data_loc ( u % data_loc ) call self % allocator % release_block ( dud ) call self % allocator % release_block ( d2u ) end subroutine transeq_dist_component subroutine tds_solve_omp ( self , du , u , tdsops ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u class ( tdsops_t ), intent ( in ) :: tdsops ! Check if direction matches for both in/out fields if ( u % dir /= du % dir ) then error stop 'DIR mismatch between fields in tds_solve.' end if if ( u % data_loc /= NULL_LOC ) then call du % set_data_loc ( move_data_loc ( u % data_loc , u % dir , tdsops % move )) end if call tds_solve_dist ( self , du , u , tdsops ) end subroutine tds_solve_omp subroutine tds_solve_dist ( self , du , u , tdsops ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u class ( tdsops_t ), intent ( in ) :: tdsops integer :: n_groups , dir dir = u % dir n_groups = self % allocator % get_n_groups ( dir ) call copy_into_buffers ( self % u_send_s , self % u_send_e , u % data , & tdsops % n_tds , n_groups ) ! halo exchange call sendrecv_fields ( self % u_recv_s , self % u_recv_e , & self % u_send_s , self % u_send_e , & SZ * self % n_halo * n_groups , & self % mesh % par % nproc_dir ( dir ), & self % mesh % par % pprev ( dir ), & self % mesh % par % pnext ( dir )) call exec_dist_tds_compact ( & du % data , u % data , self % u_recv_s , self % u_recv_e , & self % du_send_s , self % du_send_e , self % du_recv_s , self % du_recv_e , & tdsops , self % mesh % par % nproc_dir ( dir ), & self % mesh % par % pprev ( dir ), self % mesh % par % pnext ( dir ), & n_groups ) end subroutine tds_solve_dist subroutine reorder_omp ( self , u_ , u , direction ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_ class ( field_t ), intent ( in ) :: u integer , intent ( in ) :: direction integer , dimension ( 3 ) :: dims , cart_padded integer :: i , j , k integer :: out_i , out_j , out_k integer :: dir_from , dir_to dims = self % allocator % get_padded_dims ( u % dir ) cart_padded = self % allocator % get_padded_dims ( DIR_C ) call get_dirs_from_rdr ( dir_from , dir_to , direction ) !$omp parallel do private(out_i, out_j, out_k) collapse(2) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) do i = 1 , dims ( 1 ) call get_index_reordering ( out_i , out_j , out_k , i , j , k , & dir_from , dir_to , SZ , cart_padded ) u_ % data ( out_i , out_j , out_k ) = u % data ( i , j , k ) end do end do end do !$omp end parallel do ! reorder keeps the data_loc the same call u_ % set_data_loc ( u % data_loc ) end subroutine reorder_omp subroutine sum_yintox_omp ( self , u , u_ ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ call sum_intox_omp ( self , u , u_ , DIR_Y ) end subroutine sum_yintox_omp subroutine sum_zintox_omp ( self , u , u_ ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ call sum_intox_omp ( self , u , u_ , DIR_Z ) end subroutine sum_zintox_omp subroutine sum_intox_omp ( self , u , u_ , dir_to ) class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ integer , intent ( in ) :: dir_to integer :: dir_from integer , dimension ( 3 ) :: dims , cart_padded integer :: i , j , k ! Working indices integer :: ii , jj , kk ! Transpose indices dir_from = DIR_X dims = self % allocator % get_padded_dims ( u % dir ) cart_padded = self % allocator % get_padded_dims ( DIR_C ) !$omp parallel do private(i, ii, jj, kk) collapse(2) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) do i = 1 , dims ( 1 ) call get_index_reordering ( ii , jj , kk , i , j , k , & dir_from , dir_to , SZ , cart_padded ) u % data ( i , j , k ) = u % data ( i , j , k ) + u_ % data ( ii , jj , kk ) end do end do end do !$omp end parallel do end subroutine sum_intox_omp subroutine veccopy_omp ( self , dst , src ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: dst class ( field_t ), intent ( in ) :: src integer :: i , j , k if ( src % dir /= dst % dir ) then error stop \"Called vector copy with incompatible fields\" end if if ( dst % dir == DIR_C ) error stop 'veccopy does not support DIR_C fields' !$omp parallel do do k = 1 , size ( dst % data , 3 ) do j = 1 , size ( dst % data , 2 ) !$omp simd do i = 1 , SZ dst % data ( i , j , k ) = src % data ( i , j , k ) end do !$omp end simd end do end do !$omp end parallel do end subroutine veccopy_omp subroutine vecadd_omp ( self , a , x , b , y ) implicit none class ( omp_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y integer :: i , j , k if ( x % dir /= y % dir ) then error stop \"Called vector add with incompatible fields\" end if if ( y % dir == DIR_C ) error stop 'vecadd does not support DIR_C fields' !$omp parallel do do k = 1 , size ( y % data , 3 ) do j = 1 , size ( y % data , 2 ) !$omp simd do i = 1 , SZ y % data ( i , j , k ) = a * x % data ( i , j , k ) + b * y % data ( i , j , k ) end do !$omp end simd end do end do !$omp end parallel do end subroutine vecadd_omp subroutine vecmult_omp ( self , y , x ) !! [[m_base_backend(module):vecmult(interface)]] implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: y class ( field_t ), intent ( in ) :: x integer :: i , j , k if ( x % dir /= y % dir ) then error stop \"Called vector multiply with incompatible fields\" end if if ( y % dir == DIR_C ) error stop 'vecmult does not support DIR_C fields' !$omp parallel do do k = 1 , size ( y % data , 3 ) do j = 1 , size ( y % data , 2 ) !$omp simd do i = 1 , SZ y % data ( i , j , k ) = y % data ( i , j , k ) * x % data ( i , j , k ) end do !$omp end simd end do end do !$omp end parallel do end subroutine vecmult_omp real ( dp ) function scalar_product_omp ( self , x , y ) result ( s ) !! [[m_base_backend(module):scalar_product(interface)]] implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y class ( field_t ), pointer :: x_ , y_ integer , dimension ( 3 ) :: dims integer :: i , j , k , ii integer :: nvec , remstart integer :: ierr if (( x % data_loc == NULL_LOC ) . or . ( y % data_loc == NULL_LOC )) then error stop \"You must set the data_loc before calling scalar product\" end if if ( x % data_loc /= y % data_loc ) then error stop \"Called scalar product with incompatible fields\" end if ! Reorient data into temporary DIR_C storage x_ => self % allocator % get_block ( DIR_C , x % data_loc ) call self % get_field_data ( x_ % data , x ) y_ => self % allocator % get_block ( DIR_C , y % data_loc ) call self % get_field_data ( y_ % data , y ) dims = self % mesh % get_dims ( x_ % data_loc ) nvec = dims ( 1 ) / SZ remstart = nvec * SZ + 1 s = 0.0_dp !$omp parallel do reduction(+:s) private(i, ii) collapse(2) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) ! Execute inner vectorised loops do ii = 1 , nvec !$omp simd reduction(+:s) do i = 1 , SZ s = s + x_ % data ( i + ( ii - 1 ) * SZ , j , k ) * & y_ % data ( i + ( ii - 1 ) * SZ , j , k ) end do !$omp end simd end do ! Remainder loop do i = remstart , dims ( 1 ) s = s + x_ % data ( i , j , k ) * y_ % data ( i , j , k ) end do end do end do !$omp end parallel do ! Release temporary storage call self % allocator % release_block ( x_ ) call self % allocator % release_block ( y_ ) ! Reduce the result call MPI_Allreduce ( MPI_IN_PLACE , s , 1 , MPI_X3D2_DP , & MPI_SUM , MPI_COMM_WORLD , & ierr ) end function scalar_product_omp subroutine copy_into_buffers ( u_send_s , u_send_e , u , n , n_groups ) implicit none real ( dp ), dimension (:, :, :), intent ( out ) :: u_send_s , u_send_e real ( dp ), dimension (:, :, :), intent ( in ) :: u integer , intent ( in ) :: n integer , intent ( in ) :: n_groups integer :: i , j , k integer :: n_halo = 4 !$omp parallel do do k = 1 , n_groups do j = 1 , n_halo !$omp simd do i = 1 , SZ u_send_s ( i , j , k ) = u ( i , j , k ) u_send_e ( i , j , k ) = u ( i , n - n_halo + j , k ) end do !$omp end simd end do end do !$omp end parallel do end subroutine copy_into_buffers subroutine field_max_mean_omp ( self , max_val , mean_val , f , enforced_data_loc ) !! [[m_base_backend(module):field_max_mean(interface)]] implicit none class ( omp_backend_t ) :: self real ( dp ), intent ( out ) :: max_val , mean_val class ( field_t ), intent ( in ) :: f integer , optional , intent ( in ) :: enforced_data_loc real ( dp ) :: val , max_p , sum_p , max_pncl , sum_pncl integer :: data_loc , dims ( 3 ), dims_padded ( 3 ), n , n_i , n_i_pad , n_j integer :: i , j , k , k_i , k_j , ierr if ( f % data_loc == NULL_LOC . and . (. not . present ( enforced_data_loc ))) then error stop 'The input field to omp::field_max_mean does not have a & &valid f%data_loc. You may enforce a data_loc of your & &choice as last argument to carry on at your own risk!' end if if ( present ( enforced_data_loc )) then data_loc = enforced_data_loc else data_loc = f % data_loc end if dims = self % mesh % get_dims ( data_loc ) dims_padded = self % allocator % get_padded_dims ( DIR_C ) if ( f % dir == DIR_X ) then n = dims ( 1 ); n_j = dims ( 2 ); n_i = dims ( 3 ); n_i_pad = dims_padded ( 3 ) else if ( f % dir == DIR_Y ) then n = dims ( 2 ); n_j = dims ( 1 ); n_i = dims ( 3 ); n_i_pad = dims_padded ( 3 ) else if ( f % dir == DIR_Z ) then n = dims ( 3 ); n_j = dims ( 1 ); n_i = dims ( 2 ); n_i_pad = dims_padded ( 2 ) else error stop 'field_max_mean does not support DIR_C fields!' end if sum_p = 0._dp max_p = 0._dp !$omp parallel do collapse(2) reduction(+:sum_p) reduction(max:max_p) & !$omp private(k, val, sum_pncl, max_pncl) do k_j = 1 , ( n_j - 1 ) / SZ + 1 ! loop over stacked groups do k_i = 1 , n_i k = k_j + ( k_i - 1 ) * (( n_j - 1 ) / SZ + 1 ) sum_pncl = 0._dp max_pncl = 0._dp do j = 1 , n ! loop over only non-padded entries in the present group do i = 1 , min ( SZ , n_j - ( k_j - 1 ) * SZ ) val = abs ( f % data ( i , j , k )) sum_pncl = sum_pncl + val max_pncl = max ( max_pncl , val ) end do end do sum_p = sum_p + sum_pncl max_p = max ( max_p , max_pncl ) end do end do !$omp end parallel do ! rank-local values max_val = max_p mean_val = sum_p / product ( self % mesh % get_global_dims ( data_loc )) ! make sure all ranks have final values call MPI_Allreduce ( MPI_IN_PLACE , max_val , 1 , MPI_X3D2_DP , & MPI_MAX , MPI_COMM_WORLD , ierr ) call MPI_Allreduce ( MPI_IN_PLACE , mean_val , 1 , MPI_X3D2_DP , & MPI_SUM , MPI_COMM_WORLD , ierr ) end subroutine field_max_mean_omp subroutine field_scale_omp ( self , f , a ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: a f % data = a * f % data end subroutine field_scale_omp subroutine field_shift_omp ( self , f , a ) implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: a f % data = f % data + a end subroutine field_shift_omp subroutine field_set_face_omp ( self , f , c_start , c_end , face ) !! [[m_base_backend(module):field_set_face(subroutine)]] implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), intent ( in ) :: c_start , c_end integer , intent ( in ) :: face integer :: dims ( 3 ), k , j , i_mod , k_end if ( f % dir /= DIR_X ) then error stop 'Setting a field face is only supported for DIR_X fields.' end if if ( f % data_loc == NULL_LOC ) then error stop 'field_set_face require a valid data_loc.' end if dims = self % mesh % get_dims ( f % data_loc ) select case ( face ) case ( X_FACE ) error stop 'Setting X_FACE is not yet supported.' case ( Y_FACE ) i_mod = mod ( dims ( 2 ) - 1 , SZ ) + 1 !$omp parallel do private(k_end) do k = 1 , dims ( 3 ) k_end = k + ( dims ( 2 ) - 1 ) / SZ * dims ( 3 ) do j = 1 , dims ( 1 ) f % data ( 1 , j , k ) = c_start f % data ( i_mod , j , k_end ) = c_end end do end do !$omp end parallel do case ( Z_FACE ) error stop 'Setting Z_FACE is not yet supported.' case default error stop 'face is undefined.' end select end subroutine field_set_face_omp real ( dp ) function field_volume_integral_omp ( self , f ) result ( s ) !! volume integral of a field implicit none class ( omp_backend_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ) :: sum_p , sum_pncl integer :: dims ( 3 ), stacked , i , j , k , k_i , k_j , ierr if ( f % data_loc == NULL_LOC ) then error stop 'You must set the data_loc before calling volume integral.' end if if ( f % dir /= DIR_X ) then error stop 'Volume integral can only be called on DIR_X fields.' end if dims = self % mesh % get_dims ( f % data_loc ) stacked = ( dims ( 2 ) - 1 ) / SZ + 1 sum_p = 0._dp !$omp parallel do collapse(2) reduction(+:sum_p) private(k, sum_pncl) do k_j = 1 , stacked ! loop over stacked groups do k_i = 1 , dims ( 3 ) k = k_j + ( k_i - 1 ) * stacked sum_pncl = 0._dp do j = 1 , dims ( 1 ) ! loop over only non-padded entries in the present group do i = 1 , min ( SZ , dims ( 2 ) - ( k_j - 1 ) * SZ ) sum_pncl = sum_pncl + f % data ( i , j , k ) end do end do sum_p = sum_p + sum_pncl end do end do !$omp end parallel do ! rank-local values s = sum_p call MPI_Allreduce ( MPI_IN_PLACE , s , 1 , MPI_X3D2_DP , MPI_SUM , & MPI_COMM_WORLD , ierr ) end function field_volume_integral_omp subroutine copy_data_to_f_omp ( self , f , data ) class ( omp_backend_t ), intent ( inout ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( in ) :: data f % data = data end subroutine copy_data_to_f_omp subroutine copy_f_to_data_omp ( self , data , f ) class ( omp_backend_t ), intent ( inout ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: data class ( field_t ), intent ( in ) :: f data = f % data end subroutine copy_f_to_data_omp subroutine init_omp_poisson_fft ( self , mesh , xdirps , ydirps , zdirps , lowmem ) #ifdef WITH_2DECOMPFFT use m_omp_poisson_fft , only : omp_poisson_fft_t #endif implicit none class ( omp_backend_t ) :: self type ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps logical , optional , intent ( in ) :: lowmem #ifdef WITH_2DECOMPFFT allocate ( omp_poisson_fft_t :: self % poisson_fft ) select type ( poisson_fft => self % poisson_fft ) type is ( omp_poisson_fft_t ) poisson_fft = omp_poisson_fft_t ( mesh , xdirps , ydirps , zdirps , lowmem ) end select #else error stop 'This build does not support FFT based Poisson solver & &on the OpenMP backend!' #endif end subroutine init_omp_poisson_fft end module m_omp_backend","tags":"","url":"sourcefile/backend.f90.html"},{"title":"io.f90 – x3d2","text":"This file depends on sourcefile~~io.f90~~EfferentGraph sourcefile~io.f90 io.f90 sourcefile~common.f90 common.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~io.f90~~AfferentGraph sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~solver.f90 solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_io_backend !! @brief Provides a dummy, non-functional I/O backend for when an I/O backend !! is not available !! !! @details This module provides a fallback implementation of the I/O backend !! interface. It is used when no real I/O backend (e.g. ADIOS2) is enabled at !! compile time. !! !! The primary purpose of this dummy backend is to allow the full program to !! compile and link against the session interface (`m_io_session`) without !! requiring a functional I/O library. !! !! @warning This is a non-functional stub. Calling any of its I/O procedures !! will immediately terminate the program with an error message. !! !! @note If you require file I/O, you must recompile the code with a functional !! backend use iso_fortran_env , only : stderr => error_unit use m_io_base , only : io_reader_t , io_writer_t , io_file_t , io_mode_read , & io_mode_write use m_common , only : dp , i8 implicit none private public :: allocate_io_reader , allocate_io_writer public :: get_default_backend , IO_BACKEND_DUMMY , IO_BACKEND_ADIOS2 logical , save :: write_warning_shown = . false . integer , parameter :: IO_BACKEND_DUMMY = 0 integer , parameter :: IO_BACKEND_ADIOS2 = 1 type , extends ( io_file_t ) :: io_dummy_file_t logical :: is_open = . false . contains procedure :: close => file_close_dummy procedure :: begin_step => file_begin_step_dummy procedure :: end_step => file_end_step_dummy procedure :: is_file_functional => is_file_functional_dummy end type io_dummy_file_t type , extends ( io_reader_t ) :: io_dummy_reader_t logical :: initialised = . false . contains procedure :: init => reader_init_dummy procedure :: open => reader_open_dummy procedure :: finalise => reader_finalise_dummy procedure :: read_data_i8 => read_data_i8_dummy procedure :: read_data_integer => read_data_integer_dummy procedure :: read_data_real => read_data_real_dummy procedure :: read_data_array_3d => read_data_array_3d_dummy end type io_dummy_reader_t type , extends ( io_writer_t ) :: io_dummy_writer_t logical :: initialised = . false . contains procedure :: init => writer_init_dummy procedure :: open => writer_open_dummy procedure :: finalise => writer_finalise_dummy procedure :: write_data_i8 => write_data_i8_dummy procedure :: write_data_integer => write_data_integer_dummy procedure :: write_data_real => write_data_real_dummy procedure :: write_data_array_3d => write_data_array_3d_dummy procedure :: write_attribute_string => write_attribute_string_dummy procedure :: write_attribute_array_1d_real => & write_attribute_array_1d_real_dummy end type io_dummy_writer_t contains subroutine allocate_io_reader ( reader ) class ( io_reader_t ), allocatable , intent ( out ) :: reader allocate ( io_dummy_reader_t :: reader ) end subroutine allocate_io_reader subroutine allocate_io_writer ( writer ) class ( io_writer_t ), allocatable , intent ( out ) :: writer allocate ( io_dummy_writer_t :: writer ) end subroutine allocate_io_writer function get_default_backend () result ( backend ) integer :: backend backend = IO_BACKEND_DUMMY end function get_default_backend subroutine report_read_error ( variable_name ) character ( len =* ), intent ( in ) :: variable_name error stop \"ERROR: Cannot read '\" // trim ( variable_name ) // & \"' - recompile with -DWITH_ADIOS2=ON\" end subroutine report_read_error subroutine file_close_dummy ( self ) class ( io_dummy_file_t ), intent ( inout ) :: self ! silently ignore file close operations self % is_open = . false . end subroutine file_close_dummy subroutine file_begin_step_dummy ( self ) class ( io_dummy_file_t ), intent ( inout ) :: self ! silently ignore begin_step operations end subroutine file_begin_step_dummy subroutine file_end_step_dummy ( self ) class ( io_dummy_file_t ), intent ( inout ) :: self ! silently ignore end_step operations end subroutine file_end_step_dummy subroutine reader_init_dummy ( self , comm , name ) class ( io_dummy_reader_t ), intent ( inout ) :: self integer , intent ( in ) :: comm character ( len =* ), intent ( in ) :: name self % initialised = . true . end subroutine reader_init_dummy function reader_open_dummy ( self , filename , mode , comm ) result ( file_handle ) class ( io_dummy_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: mode integer , intent ( in ) :: comm class ( io_file_t ), allocatable :: file_handle write ( stderr , '(A)' ) \"ERROR: Cannot open file '\" // trim ( filename ) // & \"' for reading - ADIOS2 not available\" write ( stderr , '(A)' ) \"File reading requires ADIOS2 support\" write ( stderr , '(A)' ) \"Please recompile with -DWITH_ADIOS2=ON\" allocate ( io_dummy_file_t :: file_handle ) select type ( file_handle ) type is ( io_dummy_file_t ) file_handle % is_open = . false . end select end function reader_open_dummy function is_file_functional_dummy ( self ) result ( is_functional ) class ( io_dummy_file_t ), intent ( in ) :: self logical :: is_functional is_functional = self % is_open end function is_file_functional_dummy subroutine read_data_i8_dummy ( self , variable_name , value , file_handle ) class ( io_dummy_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer ( i8 ), intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle value = 0_i8 call report_read_error ( variable_name ) end subroutine read_data_i8_dummy subroutine read_data_integer_dummy ( self , variable_name , value , file_handle ) class ( io_dummy_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer , intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle value = 0 call report_read_error ( variable_name ) end subroutine read_data_integer_dummy subroutine read_data_real_dummy ( self , variable_name , value , file_handle ) class ( io_dummy_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle value = 0.0_dp call report_read_error ( variable_name ) end subroutine read_data_real_dummy subroutine read_data_array_3d_dummy ( & self , variable_name , array , file_handle , & shape_dims , start_dims , count_dims & ) class ( io_dummy_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( inout ) :: array (:, :, :) class ( io_file_t ), intent ( inout ) :: file_handle integer ( i8 ), intent ( in ), optional :: shape_dims ( 3 ) integer ( i8 ), intent ( in ), optional :: start_dims ( 3 ) integer ( i8 ), intent ( in ), optional :: count_dims ( 3 ) array = 0.0_dp call report_read_error ( variable_name ) end subroutine read_data_array_3d_dummy subroutine reader_finalise_dummy ( self ) class ( io_dummy_reader_t ), intent ( inout ) :: self ! silently finalise self % initialised = . false . end subroutine reader_finalise_dummy subroutine writer_init_dummy ( self , comm , name ) class ( io_dummy_writer_t ), intent ( inout ) :: self integer , intent ( in ) :: comm character ( len =* ), intent ( in ) :: name self % initialised = . true . end subroutine writer_init_dummy function writer_open_dummy ( self , filename , mode , comm ) result ( file_handle ) class ( io_dummy_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: mode integer , intent ( in ) :: comm class ( io_file_t ), allocatable :: file_handle ! Show warning for write operations (once) if (. not . write_warning_shown ) then write ( stderr , '(A)' ) \"WARNING: Cannot save file '\" // trim ( filename ) // & \"' - ADIOS2 not available\" write ( stderr , '(A)' ) \"Checkpoints and snapshots will not be written\" write_warning_shown = . true . end if ! Silently create dummy file handle allocate ( io_dummy_file_t :: file_handle ) select type ( file_handle ) type is ( io_dummy_file_t ) file_handle % is_open = . false . end select end function writer_open_dummy subroutine write_data_i8_dummy ( self , variable_name , value , file_handle ) class ( io_dummy_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer ( i8 ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle ! silently ignore write operations end subroutine write_data_i8_dummy subroutine write_data_integer_dummy ( self , variable_name , value , file_handle ) class ( io_dummy_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer , intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle ! silently ignore write operations end subroutine write_data_integer_dummy subroutine write_data_real_dummy ( self , variable_name , value , file_handle , & use_sp ) class ( io_dummy_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle logical , intent ( in ), optional :: use_sp ! silently ignore write operations end subroutine write_data_real_dummy subroutine write_data_array_3d_dummy ( & self , variable_name , array , file_handle , & shape_dims , start_dims , count_dims , use_sp & ) class ( io_dummy_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( in ) :: array (:, :, :) class ( io_file_t ), intent ( inout ) :: file_handle integer ( i8 ), intent ( in ) :: shape_dims ( 3 ) integer ( i8 ), intent ( in ) :: start_dims ( 3 ) integer ( i8 ), intent ( in ) :: count_dims ( 3 ) logical , intent ( in ), optional :: use_sp ! silently ignore write operations end subroutine write_data_array_3d_dummy subroutine writer_finalise_dummy ( self ) class ( io_dummy_writer_t ), intent ( inout ) :: self ! silently finalise self % initialised = . false . end subroutine writer_finalise_dummy subroutine write_attribute_string_dummy ( & self , attribute_name , value , file_handle & ) class ( io_dummy_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: attribute_name character ( len =* ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle ! silently ignore attribute writes end subroutine write_attribute_string_dummy subroutine write_attribute_array_1d_real_dummy ( & self , attribute_name , values , file_handle & ) class ( io_dummy_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: attribute_name real ( dp ), intent ( in ) :: values (:) class ( io_file_t ), intent ( inout ) :: file_handle ! silently ignore attribute writes end subroutine write_attribute_array_1d_real_dummy end module m_io_backend","tags":"","url":"sourcefile/io.f90.html"},{"title":"allocator.f90 – x3d2","text":"This file depends on sourcefile~~allocator.f90~~EfferentGraph sourcefile~allocator.f90 allocator.f90 sourcefile~common.f90 common.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~field.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~allocator.f90~~AfferentGraph sourcefile~allocator.f90 allocator.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~allocator.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~allocator.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~allocator.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~allocator.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~allocator.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_allocator use iso_fortran_env , only : stderr => error_unit use m_common , only : dp , DIR_X , DIR_Y , DIR_Z , DIR_C , NULL_LOC use m_field , only : field_t implicit none type :: allocator_t !! An instance of type allocator_t is responsible for the !! maintenance of a linked list of instances of equal size !! [[m_allocator(module):field_t(type)]] objects: !! !! ``` !!       ---- ---- ----     ---- ---- ---- !! ...-->|id=1|data|next|-->|id=0|data|next|-->null() !!       ---- ---- ----     ---- ---- ---- !! ``` !! !! the last block's `next` pointer being non associated. !! !! User code can request access to a memory block by using the !! type bound procedure !! [[m_allocator(module):get_block(function)]].  If the list is !! not empty, a pointer to the first block on the list is !! returned and the block is detached from the list.  If the list !! is empty (i.e. all initially allocated blocks are currently !! referenced to) then a new block is allocated before a pointer !! to it is returned. !! !! In order to reuse memory it is important that user code !! release blocks when they are not needed anymore.  This is done !! by calling the type bound procedure !! [[m_allocator(module):release_block(subroutine)]].  The !! released block is then pushed in front of the block list. integer :: ngrid , sz !> The id for the next allocated block.  This counter is !> incremented each time a new block is allocated. integer :: next_id = 0 !> padded dimensions and n_groups in all 'dir's integer , private :: dims_padded_dir ( 3 , 4 ) integer , private :: n_groups_dir ( 3 ) !> The pointer to the first block on the list.  Non associated if !> the list is empty ! TODO: Rename first to head class ( field_t ), pointer :: first => null () contains procedure :: get_block procedure :: release_block procedure :: create_block procedure :: get_block_ids procedure :: destroy procedure :: get_padded_dims procedure :: get_n_groups end type allocator_t interface allocator_t module procedure allocator_init end interface allocator_t contains function allocator_init ( dims , sz ) result ( allocator ) integer , intent ( in ) :: dims ( 3 ), sz type ( allocator_t ) :: allocator integer :: nx , ny , nz , nx_padded , ny_padded , nz_padded nx = dims ( 1 ); ny = dims ( 2 ); nz = dims ( 3 ) ! Apply padding based on sz nx_padded = nx - 1 + mod ( - ( nx - 1 ), sz ) + sz ny_padded = ny - 1 + mod ( - ( ny - 1 ), sz ) + sz ! Current reorder functions do not require a padding in z-direction. nz_padded = nz allocator % ngrid = nx_padded * ny_padded * nz_padded allocator % sz = sz allocator % n_groups_dir ( 1 : 3 ) = [ ny_padded * nz_padded / sz , & nx_padded * nz_padded / sz , & nx_padded * ny_padded / sz ] allocator % dims_padded_dir (:, 1 ) = [ sz , nx_padded , & allocator % n_groups_dir ( 1 )] allocator % dims_padded_dir (:, 2 ) = [ sz , ny_padded , & allocator % n_groups_dir ( 2 )] allocator % dims_padded_dir (:, 3 ) = [ sz , nz_padded , & allocator % n_groups_dir ( 3 )] allocator % dims_padded_dir (:, 4 ) = [ nx_padded , ny_padded , nz_padded ] end function allocator_init function create_block ( self , next ) result ( ptr ) !! Allocate memory for a new block and return a pointer to a new !! [[m_allocator(module):field_t(type)]] object. class ( allocator_t ), intent ( inout ) :: self class ( field_t ), pointer , intent ( in ) :: next type ( field_t ), pointer :: newblock class ( field_t ), pointer :: ptr self % next_id = self % next_id + 1 allocate ( newblock ) select type ( next ) type is ( field_t ) newblock = field_t ( self % ngrid , next , id = self % next_id ) class default error stop \"Incorrect overloading for create_block\" end select ptr => newblock end function create_block function get_block ( self , dir , data_loc ) result ( handle ) !! Return a pointer to the first available memory block, i.e. the !! current head of the block list.  If the list is empty, allocate !! a new block with [[m_allocator(module):create_block(function)]] !! first. !! !! Example !! ``` !! f%data => get_block() !! ``` class ( allocator_t ), intent ( inout ) :: self class ( field_t ), pointer :: handle integer , intent ( in ) :: dir integer , intent ( in ), optional :: data_loc integer :: dims ( 3 ) ! If the list is empty, allocate a new block before returning a ! pointer to it. if (. not . associated ( self % first )) then ! Construct a field_t. This effectively allocates ! storage space. self % first => self % create_block ( next = self % first ) end if handle => self % first self % first => self % first % next ! 2nd block becomes head block handle % next => null () ! Detach ex-head block from the block list ! Store direction info in the field type. handle % dir = dir if ( present ( data_loc )) then handle % data_loc = data_loc else handle % data_loc = NULL_LOC end if ! Set dims based on direction dims = self % dims_padded_dir ( 1 : 3 , dir ) ! Apply bounds remapping based on requested direction call handle % set_shape ( dims ) end function get_block subroutine release_block ( self , handle ) !! Release memory block pointed to by HANDLE to the block list. !! It is pushed to the front of the block list, in other words it !! is made the head block. class ( allocator_t ), intent ( inout ) :: self class ( field_t ), pointer :: handle handle % next => self % first self % first => handle end subroutine release_block subroutine destroy ( self ) !! Go through the block list from head to tail, deallocating each !! memory block in turn.  Deallocation of a !! [[m_allocator(module):field_t(type)]] object automatically !! deallocates its internal allocatable !! [[field_t(type):data(variable)]] array. class ( allocator_t ), intent ( inout ) :: self type ( field_t ), pointer :: current do if (. not . associated ( self % first )) exit current => self % first self % first => self % first % next deallocate ( current ) self % next_id = self % next_id - 1 end do end subroutine destroy function get_block_ids ( self ) !! Utility function that returns a array made of the `id` of the !! block currently in the block list.  Return the array [0] if !! block list is empty. ! TODO: Block indices should start at 1 or return [-1] in case of ! empty block list. class ( allocator_t ), intent ( inout ) :: self integer , allocatable :: get_block_ids (:) class ( field_t ), pointer :: current integer :: i current => self % first if (. not . associated ( current )) then get_block_ids = [ 0 ] else i = current % id get_block_ids = [ current % id ] do if (. not . associated ( current % next )) exit i = current % next % id get_block_ids = [ get_block_ids , current % next % id ] current => current % next end do end if end function get_block_ids function get_padded_dims ( self , dir ) result ( dims ) implicit none class ( allocator_t ), intent ( inout ) :: self integer , intent ( in ) :: dir integer :: dims ( 3 ) dims = self % dims_padded_dir ( 1 : 3 , dir ) end function get_padded_dims function get_n_groups ( self , dir ) result ( n_groups ) implicit none class ( allocator_t ), intent ( inout ) :: self integer , intent ( in ) :: dir integer :: n_groups n_groups = self % n_groups_dir ( dir ) end function get_n_groups end module m_allocator","tags":"","url":"sourcefile/allocator.f90.html"},{"title":"vector_calculus.f90 – x3d2","text":"This file depends on sourcefile~~vector_calculus.f90~~EfferentGraph sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~common.f90 common.f90 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~mesh.f90 mesh.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~vector_calculus.f90~~AfferentGraph sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_vector_calculus use iso_fortran_env , only : stderr => error_unit use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_common , only : dp , DIR_X , DIR_Y , DIR_Z , & RDR_X2Y , RDR_X2Z , RDR_Y2X , RDR_Y2Z , RDR_Z2X , RDR_Z2Y use m_field , only : field_t use m_tdsops , only : tdsops_t implicit none type :: vector_calculus_t !! Defines vector calculus operators class ( base_backend_t ), pointer :: backend contains procedure :: curl procedure :: divergence_v2c procedure :: gradient_c2v procedure :: laplacian end type vector_calculus_t interface vector_calculus_t module procedure init end interface vector_calculus_t contains function init ( backend ) result ( vector_calculus ) implicit none class ( base_backend_t ), target , intent ( inout ) :: backend type ( vector_calculus_t ) :: vector_calculus vector_calculus % backend => backend end function init subroutine curl ( self , o_i_hat , o_j_hat , o_k_hat , u , v , w , & x_der1st , y_der1st , z_der1st ) !! Curl of a vector field (u, v, w). !! !! Evaluated at the data_loc defined by u, v, w fields. !! !! All the input and output fields are in DIR_X layout. implicit none class ( vector_calculus_t ) :: self !> Vector components of the output vector field Omega class ( field_t ), intent ( inout ) :: o_i_hat , o_j_hat , o_k_hat class ( field_t ), intent ( in ) :: u , v , w class ( tdsops_t ), intent ( in ) :: x_der1st , y_der1st , z_der1st class ( field_t ), pointer :: u_y , u_z , v_z , w_y , dwdy_y , dvdz_z , dvdz_x , & dudz_z , dudz_x , dudy_y , dudy_x if ( o_i_hat % dir /= DIR_X . or . o_j_hat % dir /= DIR_X & . or . o_k_hat % dir /= DIR_X . or . u % dir /= DIR_X . or . v % dir /= DIR_X & . or . w % dir /= DIR_X ) then error stop 'Error in curl input/output field %dirs: & &outputs and inputs must be in DIR_X layout.' end if ! omega_i_hat = dw/dy - dv/dz ! omega_j_hat = du/dz - dw/dx ! omega_k_hat = dv/dx - du/dy ! omega_i_hat ! dw/dy w_y => self % backend % allocator % get_block ( DIR_Y ) dwdy_y => self % backend % allocator % get_block ( DIR_Y ) call self % backend % reorder ( w_y , w , RDR_X2Y ) call self % backend % tds_solve ( dwdy_y , w_y , y_der1st ) call self % backend % reorder ( o_i_hat , dwdy_y , RDR_Y2X ) call self % backend % allocator % release_block ( w_y ) call self % backend % allocator % release_block ( dwdy_y ) ! dv/dz v_z => self % backend % allocator % get_block ( DIR_Z ) dvdz_z => self % backend % allocator % get_block ( DIR_Z ) call self % backend % reorder ( v_z , v , RDR_X2Z ) call self % backend % tds_solve ( dvdz_z , v_z , z_der1st ) dvdz_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( dvdz_x , dvdz_z , RDR_Z2X ) call self % backend % allocator % release_block ( v_z ) call self % backend % allocator % release_block ( dvdz_z ) ! omega_i_hat = dw/dy - dv/dz call self % backend % vecadd ( - 1._dp , dvdz_x , 1._dp , o_i_hat ) call self % backend % allocator % release_block ( dvdz_x ) ! omega_j_hat ! du/dz u_z => self % backend % allocator % get_block ( DIR_Z ) dudz_z => self % backend % allocator % get_block ( DIR_Z ) call self % backend % reorder ( u_z , u , RDR_X2Z ) call self % backend % tds_solve ( dudz_z , u_z , z_der1st ) dudz_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( dudz_x , dudz_z , RDR_Z2X ) call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( dudz_z ) ! dw/dx call self % backend % tds_solve ( o_j_hat , w , x_der1st ) ! omega_j_hat = du/dz - dw/dx call self % backend % vecadd ( 1._dp , dudz_x , - 1._dp , o_j_hat ) call self % backend % allocator % release_block ( dudz_x ) ! omega_k_hat ! dv/dx call self % backend % tds_solve ( o_k_hat , v , x_der1st ) ! du/dy u_y => self % backend % allocator % get_block ( DIR_Y ) dudy_y => self % backend % allocator % get_block ( DIR_Y ) call self % backend % reorder ( u_y , u , RDR_X2Y ) call self % backend % tds_solve ( dudy_y , u_y , y_der1st ) dudy_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( dudy_x , dudy_y , RDR_Y2X ) call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( dudy_y ) ! omega_k_hat = dv/dx - du/dy call self % backend % vecadd ( - 1._dp , dudy_x , 1._dp , o_k_hat ) call self % backend % allocator % release_block ( dudy_x ) end subroutine curl subroutine divergence_v2c ( self , div_u , u , v , w , & x_stagder_v2c , x_interpl_v2c , & y_stagder_v2c , y_interpl_v2c , & z_stagder_v2c , z_interpl_v2c ) !! Divergence of a vector field (u, v, w). !! !! Evaluated at the cell centers (data_loc=CELL) !! Input fields are at vertices (data_loc=VERT) !! !! Input fields are in DIR_X data layout. !! Output field is in DIR_Z data layout. implicit none class ( vector_calculus_t ) :: self class ( field_t ), intent ( inout ) :: div_u class ( field_t ), intent ( in ) :: u , v , w class ( tdsops_t ), intent ( in ) :: x_stagder_v2c , x_interpl_v2c , & y_stagder_v2c , y_interpl_v2c , & z_stagder_v2c , z_interpl_v2c class ( field_t ), pointer :: du_x , dv_x , dw_x , & u_y , v_y , w_y , du_y , dv_y , dw_y , & u_z , w_z , dw_z if ( div_u % dir /= DIR_Z . or . u % dir /= DIR_X . or . v % dir /= DIR_X & . or . w % dir /= DIR_X ) then error stop 'Error in divergence_v2c input/output field dirs: & &output must be in DIR_Z, inputs must be in DIR_X layout.' end if du_x => self % backend % allocator % get_block ( DIR_X ) dv_x => self % backend % allocator % get_block ( DIR_X ) dw_x => self % backend % allocator % get_block ( DIR_X ) ! Staggared der for u field in x ! Interpolation for v field in x ! Interpolation for w field in x call self % backend % tds_solve ( du_x , u , x_stagder_v2c ) call self % backend % tds_solve ( dv_x , v , x_interpl_v2c ) call self % backend % tds_solve ( dw_x , w , x_interpl_v2c ) ! request fields from the allocator u_y => self % backend % allocator % get_block ( DIR_Y ) v_y => self % backend % allocator % get_block ( DIR_Y ) w_y => self % backend % allocator % get_block ( DIR_Y ) ! reorder data from x orientation to y orientation call self % backend % reorder ( u_y , du_x , RDR_X2Y ) call self % backend % reorder ( v_y , dv_x , RDR_X2Y ) call self % backend % reorder ( w_y , dw_x , RDR_X2Y ) call self % backend % allocator % release_block ( du_x ) call self % backend % allocator % release_block ( dv_x ) call self % backend % allocator % release_block ( dw_x ) du_y => self % backend % allocator % get_block ( DIR_Y ) dv_y => self % backend % allocator % get_block ( DIR_Y ) dw_y => self % backend % allocator % get_block ( DIR_Y ) ! similar to the x direction, obtain derivatives in y. call self % backend % tds_solve ( du_y , u_y , y_interpl_v2c ) call self % backend % tds_solve ( dv_y , v_y , y_stagder_v2c ) call self % backend % tds_solve ( dw_y , w_y , y_interpl_v2c ) ! we don't need the velocities in y orientation any more, so release ! them to open up space. ! It is important that this doesn't actually deallocate any memory, ! it just makes the corresponding memory space available for use. call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( v_y ) call self % backend % allocator % release_block ( w_y ) ! just like in y direction, get some fields for the z derivatives. u_z => self % backend % allocator % get_block ( DIR_Z ) w_z => self % backend % allocator % get_block ( DIR_Z ) ! du_y = dv_y + du_y call self % backend % vecadd ( 1._dp , dv_y , 1._dp , du_y ) ! reorder from y to z call self % backend % reorder ( u_z , du_y , RDR_Y2Z ) call self % backend % reorder ( w_z , dw_y , RDR_Y2Z ) ! release all the unnecessary blocks. call self % backend % allocator % release_block ( du_y ) call self % backend % allocator % release_block ( dv_y ) call self % backend % allocator % release_block ( dw_y ) dw_z => self % backend % allocator % get_block ( DIR_Z ) ! get the derivatives in z call self % backend % tds_solve ( div_u , u_z , z_interpl_v2c ) call self % backend % tds_solve ( dw_z , w_z , z_stagder_v2c ) ! div_u = div_u + dw_z call self % backend % vecadd ( 1._dp , dw_z , 1._dp , div_u ) ! div_u array is in z orientation ! there is no need to keep velocities in z orientation around, so release call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( w_z ) call self % backend % allocator % release_block ( dw_z ) end subroutine divergence_v2c subroutine gradient_c2v ( self , dpdx , dpdy , dpdz , p , & x_stagder_c2v , x_interpl_c2v , & y_stagder_c2v , y_interpl_c2v , & z_stagder_c2v , z_interpl_c2v ) !! Gradient of a scalar field 'p'. !! !! Evaluated at the vertices (data_loc=VERT) !! Input field is at cell centers (data_loc=CELL) !! !! Input field is in DIR_Z data layout. !! Output fields (dpdx, dpdy, dpdz) are in DIR_X data layout. implicit none class ( vector_calculus_t ) :: self class ( field_t ), intent ( inout ) :: dpdx , dpdy , dpdz class ( field_t ), intent ( in ) :: p class ( tdsops_t ), intent ( in ) :: x_stagder_c2v , x_interpl_c2v , & y_stagder_c2v , y_interpl_c2v , & z_stagder_c2v , z_interpl_c2v class ( field_t ), pointer :: p_sxy_z , dpdz_sxy_z , & p_sxy_y , dpdz_sxy_y , & p_sx_y , dpdy_sx_y , dpdz_sx_y , & p_sx_x , dpdy_sx_x , dpdz_sx_x if ( dpdx % dir /= DIR_X . or . dpdy % dir /= DIR_X . or . dpdz % dir /= DIR_X & . or . p % dir /= DIR_Z ) then error stop 'Error in gradient_c2v input/output field dirs: & &outputs must be in DIR_X, input must be in DIR_Z layout.' end if p_sxy_z => self % backend % allocator % get_block ( DIR_Z ) dpdz_sxy_z => self % backend % allocator % get_block ( DIR_Z ) ! Staggared der for p field in z ! Interpolation for p field in z call self % backend % tds_solve ( p_sxy_z , p , z_interpl_c2v ) call self % backend % tds_solve ( dpdz_sxy_z , p , z_stagder_c2v ) ! request fields from the allocator p_sxy_y => self % backend % allocator % get_block ( DIR_Y ) dpdz_sxy_y => self % backend % allocator % get_block ( DIR_Y ) ! reorder data from z orientation to y orientation call self % backend % reorder ( p_sxy_y , p_sxy_z , RDR_Z2Y ) call self % backend % reorder ( dpdz_sxy_y , dpdz_sxy_z , RDR_Z2Y ) call self % backend % allocator % release_block ( p_sxy_z ) call self % backend % allocator % release_block ( dpdz_sxy_z ) ! derivatives in y, with careful memory management p_sx_y => self % backend % allocator % get_block ( DIR_Y ) dpdy_sx_y => self % backend % allocator % get_block ( DIR_Y ) call self % backend % tds_solve ( p_sx_y , p_sxy_y , y_interpl_c2v ) call self % backend % tds_solve ( dpdy_sx_y , p_sxy_y , y_stagder_c2v ) call self % backend % allocator % release_block ( p_sxy_y ) dpdz_sx_y => self % backend % allocator % get_block ( DIR_Y ) call self % backend % tds_solve ( dpdz_sx_y , dpdz_sxy_y , y_interpl_c2v ) call self % backend % allocator % release_block ( dpdz_sxy_y ) ! reorder from y to x, and release memory one by one p_sx_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( p_sx_x , p_sx_y , RDR_Y2X ) call self % backend % allocator % release_block ( p_sx_y ) dpdy_sx_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( dpdy_sx_x , dpdy_sx_y , RDR_Y2X ) call self % backend % allocator % release_block ( dpdy_sx_y ) dpdz_sx_x => self % backend % allocator % get_block ( DIR_X ) call self % backend % reorder ( dpdz_sx_x , dpdz_sx_y , RDR_Y2X ) call self % backend % allocator % release_block ( dpdz_sx_y ) ! get the derivatives in x call self % backend % tds_solve ( dpdx , p_sx_x , x_stagder_c2v ) call self % backend % tds_solve ( dpdy , dpdy_sx_x , x_interpl_c2v ) call self % backend % tds_solve ( dpdz , dpdz_sx_x , x_interpl_c2v ) ! release temporary x fields call self % backend % allocator % release_block ( p_sx_x ) call self % backend % allocator % release_block ( dpdy_sx_x ) call self % backend % allocator % release_block ( dpdz_sx_x ) end subroutine gradient_c2v subroutine laplacian ( self , lapl_u , u , x_der2nd , y_der2nd , z_der2nd ) !! Laplacian of a scalar field 'u'. !! !! Evaluated at the data_loc defined by the input u field !! !! Input and output fields are in DIR_X layout. implicit none class ( vector_calculus_t ) :: self class ( field_t ), intent ( inout ) :: lapl_u class ( field_t ), intent ( in ) :: u class ( tdsops_t ), intent ( in ) :: x_der2nd , y_der2nd , z_der2nd class ( field_t ), pointer :: u_y , d2u_y , u_z , d2u_z if ( u % dir /= DIR_X . or . lapl_u % dir /= DIR_X ) then error stop 'Error in laplacian input/output field %dirs: & &outputs and inputs must be in DIR_X layout.' end if ! d2u/dx2 call self % backend % tds_solve ( lapl_u , u , x_der2nd ) ! y directional temporary fields u_y => self % backend % allocator % get_block ( DIR_Y ) d2u_y => self % backend % allocator % get_block ( DIR_Y ) call self % backend % reorder ( u_y , u , RDR_X2Y ) ! d2u/dy2 call self % backend % tds_solve ( d2u_y , u_y , y_der2nd ) ! add the y derivative component into the result field call self % backend % sum_yintox ( lapl_u , d2u_y ) ! release y directional fields call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( d2u_y ) ! z directional temporary fields u_z => self % backend % allocator % get_block ( DIR_Z ) d2u_z => self % backend % allocator % get_block ( DIR_Z ) call self % backend % reorder ( u_z , u , RDR_X2Z ) ! d2u/dz2 call self % backend % tds_solve ( d2u_z , u_z , z_der2nd ) ! add the z derivative component into the result field call self % backend % sum_zintox ( lapl_u , d2u_z ) ! release z directional fields call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( d2u_z ) end subroutine laplacian end module m_vector_calculus","tags":"","url":"sourcefile/vector_calculus.f90.html"},{"title":"io_field_utils.f90 – x3d2","text":"This file depends on sourcefile~~io_field_utils.f90~~EfferentGraph sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~common.f90 common.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 sourcefile~solver.f90 solver.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~config.f90 config.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~io.f90 io.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~io_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~io_field_utils.f90~~AfferentGraph sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_io_field_utils !! @brief Provides common utilities and helper routines for field I/O !! operations !! !! @details This module contains a collection of procedures and derived !! types that handle the low-level tasks required for writing field data !! Its primary functionalities include: !! - Data sub-sampling (striding) - applying a stride to data to reduce the !! size of the output files !! - Parallel I/O calculations - determining correct global shapes, !! local starts, and counts for data distributed across multiple MPI ranks !! - Data management - handling the setup, cleanup, and buffering of field !! data in preparation for asynchronous I/O operations use m_common , only : dp , i8 , DIR_C use m_field , only : field_t use m_solver , only : solver_t use m_io_base , only : io_file_t , io_writer_t implicit none private public :: field_buffer_map_t , field_ptr_t public :: stride_data , stride_data_to_buffer , get_output_dimensions public :: generate_coordinates public :: setup_field_arrays , cleanup_field_arrays public :: prepare_field_buffers , write_single_field_to_buffer , & cleanup_field_buffers type :: field_buffer_map_t ! Race-free field buffer mapping for async I/O operations. ! Each field gets its own dedicated buffer to prevent data races ! when multiple async write operations are in flight. character ( len = 32 ) :: field_name real ( dp ), dimension (:, :, :), allocatable :: buffer end type field_buffer_map_t type :: field_ptr_t class ( field_t ), pointer :: ptr => null () end type field_ptr_t contains function stride_data ( & input_data , dims , stride , output_dims_out ) & result ( output_data ) real ( dp ), dimension (:, :, :), intent ( in ) :: input_data integer , dimension ( 3 ), intent ( in ) :: dims integer , dimension ( 3 ), intent ( in ) :: stride integer , dimension ( 3 ), intent ( out ) :: output_dims_out real ( dp ), dimension (:, :, :), allocatable :: output_data integer :: i_stride , j_stride , k_stride integer :: i_max , j_max , k_max if ( all ( stride == 1 )) then allocate ( output_data ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) output_data = input_data output_dims_out = dims return end if i_stride = stride ( 1 ); j_stride = stride ( 2 ); k_stride = stride ( 3 ) i_max = ( dims ( 1 ) - 1 ) / i_stride + 1 j_max = ( dims ( 2 ) - 1 ) / j_stride + 1 k_max = ( dims ( 3 ) - 1 ) / k_stride + 1 output_dims_out = [ i_max , j_max , k_max ] allocate ( output_data ( i_max , j_max , k_max )) output_data = input_data ( 1 : dims ( 1 ): i_stride , & 1 : dims ( 2 ): j_stride , 1 : dims ( 3 ): k_stride ) end function stride_data subroutine stride_data_to_buffer ( & input_data , dims , stride , out_buffer , output_dims_out & ) real ( dp ), dimension (:, :, :), intent ( in ) :: input_data integer , dimension ( 3 ), intent ( in ) :: dims integer , dimension ( 3 ), intent ( in ) :: stride real ( dp ), dimension (:, :, :), allocatable , intent ( inout ) :: out_buffer integer , dimension ( 3 ), intent ( out ) :: output_dims_out integer :: i_stride , j_stride , k_stride integer :: i_max , j_max , k_max if ( all ( stride == 1 )) then if ( allocated ( out_buffer )) then if ( size ( out_buffer , 1 ) /= dims ( 1 ) & . or . size ( out_buffer , 2 ) /= dims ( 2 ) . or . & size ( out_buffer , 3 ) /= dims ( 3 )) then deallocate ( out_buffer ) allocate ( out_buffer ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) end if else allocate ( out_buffer ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) end if out_buffer = input_data output_dims_out = dims return end if i_stride = stride ( 1 ); j_stride = stride ( 2 ); k_stride = stride ( 3 ) i_max = ( dims ( 1 ) + i_stride - 1 ) / i_stride j_max = ( dims ( 2 ) + j_stride - 1 ) / j_stride k_max = ( dims ( 3 ) + k_stride - 1 ) / k_stride output_dims_out = [ i_max , j_max , k_max ] if ( allocated ( out_buffer )) then if ( size ( out_buffer , 1 ) /= i_max & . or . size ( out_buffer , 2 ) /= j_max . or . & size ( out_buffer , 3 ) /= k_max ) then deallocate ( out_buffer ) allocate ( out_buffer ( i_max , j_max , k_max )) end if else allocate ( out_buffer ( i_max , j_max , k_max )) end if out_buffer = input_data ( 1 : dims ( 1 ): i_stride , & 1 : dims ( 2 ): j_stride , 1 : dims ( 3 ): k_stride ) end subroutine stride_data_to_buffer subroutine get_output_dimensions ( & shape_dims , start_dims , count_dims , stride_factors , & output_shape , output_start , output_count , output_dims_local , & last_shape_dims , last_stride_factors , last_output_shape ) integer ( i8 ), dimension ( 3 ), intent ( in ) :: shape_dims , start_dims , count_dims integer , dimension ( 3 ), intent ( in ) :: stride_factors integer ( i8 ), dimension ( 3 ), intent ( out ) :: output_shape , output_start integer ( i8 ), dimension ( 3 ), intent ( out ) :: output_count integer , dimension ( 3 ), intent ( out ) :: output_dims_local integer ( i8 ), dimension ( 3 ), intent ( inout ), optional :: last_shape_dims integer , dimension ( 3 ), intent ( inout ), optional :: last_stride_factors integer ( i8 ), dimension ( 3 ), intent ( inout ), optional :: last_output_shape if ( all ( stride_factors == 1 )) then output_shape = shape_dims output_start = start_dims output_count = count_dims output_dims_local = int ( count_dims ) return end if if ( present ( last_shape_dims ) . and . present ( last_stride_factors ) . and . & present ( last_output_shape )) then if ( all ( shape_dims == last_shape_dims ) . and . & all ( stride_factors == last_stride_factors ) . and . & all ( last_output_shape > 0 )) then output_shape = last_output_shape else output_shape = [( shape_dims ( 1 ) + stride_factors ( 1 ) - 1_i8 ) & / int ( stride_factors ( 1 ), i8 ), & ( shape_dims ( 2 ) + stride_factors ( 2 ) - 1_i8 ) & / int ( stride_factors ( 2 ), i8 ), & ( shape_dims ( 3 ) + stride_factors ( 3 ) - 1_i8 ) & / int ( stride_factors ( 3 ), i8 )] last_shape_dims = shape_dims last_stride_factors = stride_factors last_output_shape = output_shape end if else output_shape = [( shape_dims ( 1 ) + stride_factors ( 1 ) - 1_i8 ) & / int ( stride_factors ( 1 ), i8 ), & ( shape_dims ( 2 ) + stride_factors ( 2 ) - 1_i8 ) & / int ( stride_factors ( 2 ), i8 ), & ( shape_dims ( 3 ) + stride_factors ( 3 ) - 1_i8 ) & / int ( stride_factors ( 3 ), i8 )] end if output_start = [ start_dims ( 1 ) / int ( stride_factors ( 1 ), i8 ), & start_dims ( 2 ) / int ( stride_factors ( 2 ), i8 ), & start_dims ( 3 ) / int ( stride_factors ( 3 ), i8 )] output_dims_local = [( int ( count_dims ( 1 )) + stride_factors ( 1 ) - 1 ) & / stride_factors ( 1 ), & ( int ( count_dims ( 2 )) + stride_factors ( 2 ) - 1 ) & / stride_factors ( 2 ), & ( int ( count_dims ( 3 )) + stride_factors ( 3 ) - 1 ) & / stride_factors ( 3 )] output_count = [ int ( output_dims_local ( 1 ), i8 ), & int ( output_dims_local ( 2 ), i8 ), & int ( output_dims_local ( 3 ), i8 )] end subroutine get_output_dimensions subroutine generate_coordinates ( & solver , writer , file , shape_dims , start_dims , count_dims , data_loc , & coords_x , coords_y , coords_z & ) class ( solver_t ), intent ( in ) :: solver class ( io_writer_t ), intent ( inout ) :: writer class ( io_file_t ), intent ( inout ) :: file integer ( i8 ), dimension ( 3 ), intent ( in ) :: shape_dims , start_dims , count_dims integer , intent ( in ) :: data_loc real ( dp ), dimension (:, :, :), allocatable , intent ( inout ) :: & coords_x , coords_y , coords_z integer :: i , nx , ny , nz real ( dp ), dimension ( 3 ) :: coords integer ( i8 ), dimension ( 3 ) :: x_shape , y_shape , z_shape integer ( i8 ), dimension ( 3 ) :: x_start , y_start , z_start integer ( i8 ), dimension ( 3 ) :: x_count , y_count , z_count nx = int ( count_dims ( 1 )) ny = int ( count_dims ( 2 )) nz = int ( count_dims ( 3 )) ! coordinates are structured as 3D arrays for ParaView ADIOS2 reader compatibility if (. not . allocated ( coords_x ) . or . size ( coords_x ) /= nx ) then if ( allocated ( coords_x )) deallocate ( coords_x ) allocate ( coords_x ( nx , 1 , 1 )) end if if (. not . allocated ( coords_y ) . or . size ( coords_y ) /= ny ) then if ( allocated ( coords_y )) deallocate ( coords_y ) allocate ( coords_y ( 1 , ny , 1 )) end if if (. not . allocated ( coords_z ) . or . size ( coords_z ) /= nz ) then if ( allocated ( coords_z )) deallocate ( coords_z ) allocate ( coords_z ( 1 , 1 , nz )) end if do i = 1 , nx coords = solver % mesh % get_coordinates ( i , 1 , 1 , data_loc ) coords_x ( i , 1 , 1 ) = coords ( 1 ) end do do i = 1 , ny coords = solver % mesh % get_coordinates ( 1 , i , 1 , data_loc ) coords_y ( 1 , i , 1 ) = coords ( 2 ) end do do i = 1 , nz coords = solver % mesh % get_coordinates ( 1 , 1 , i , data_loc ) coords_z ( 1 , 1 , i ) = coords ( 3 ) end do x_shape = [ 1_i8 , 1_i8 , shape_dims ( 1 )] x_start = [ 0_i8 , 0_i8 , start_dims ( 1 )] x_count = [ 1_i8 , 1_i8 , count_dims ( 1 )] y_shape = [ 1_i8 , shape_dims ( 2 ), 1_i8 ] y_start = [ 0_i8 , start_dims ( 2 ), 0_i8 ] y_count = [ 1_i8 , count_dims ( 2 ), 1_i8 ] z_shape = [ shape_dims ( 3 ), 1_i8 , 1_i8 ] z_start = [ start_dims ( 3 ), 0_i8 , 0_i8 ] z_count = [ count_dims ( 3 ), 1_i8 , 1_i8 ] call writer % write_data ( & \"coordinates/x\" , coords_x , file , x_shape , x_start , x_count & ) call writer % write_data ( & \"coordinates/y\" , coords_y , file , y_shape , y_start , y_count & ) call writer % write_data ( & \"coordinates/z\" , coords_z , file , z_shape , z_start , z_count & ) end subroutine generate_coordinates subroutine setup_field_arrays ( & solver , field_names , field_ptrs , host_fields & ) class ( solver_t ), intent ( in ) :: solver character ( len =* ), dimension (:), intent ( in ) :: field_names type ( field_ptr_t ), allocatable , intent ( out ) :: field_ptrs (:) type ( field_ptr_t ), allocatable , intent ( out ) :: host_fields (:) integer :: i , num_fields num_fields = size ( field_names ) allocate ( field_ptrs ( num_fields )) allocate ( host_fields ( num_fields )) do i = 1 , num_fields select case ( trim ( field_names ( i ))) case ( \"u\" ) field_ptrs ( i )% ptr => solver % u case ( \"v\" ) field_ptrs ( i )% ptr => solver % v case ( \"w\" ) field_ptrs ( i )% ptr => solver % w case default if ( solver % mesh % par % is_root ()) then print * , 'ERROR: Unknown field name: ' , trim ( field_names ( i )) end if error stop 1 end select end do do i = 1 , num_fields host_fields ( i )% ptr => solver % host_allocator % get_block ( & DIR_C , field_ptrs ( i )% ptr % data_loc ) call solver % backend % get_field_data ( & host_fields ( i )% ptr % data , field_ptrs ( i )% ptr ) end do end subroutine setup_field_arrays subroutine cleanup_field_arrays ( & solver , field_ptrs , host_fields & ) class ( solver_t ), intent ( in ) :: solver type ( field_ptr_t ), allocatable , intent ( inout ) :: field_ptrs (:) type ( field_ptr_t ), allocatable , intent ( inout ) :: host_fields (:) integer :: i if ( allocated ( host_fields )) then do i = 1 , size ( host_fields ) call solver % host_allocator % release_block ( host_fields ( i )% ptr ) end do deallocate ( host_fields ) end if if ( allocated ( field_ptrs )) then deallocate ( field_ptrs ) end if end subroutine cleanup_field_arrays subroutine prepare_field_buffers ( & solver , stride_factors , field_names , data_loc , & field_buffers , last_shape_dims , last_stride_factors , last_output_shape & ) class ( solver_t ), intent ( in ) :: solver integer , dimension ( 3 ), intent ( in ) :: stride_factors character ( len =* ), dimension (:), intent ( in ) :: field_names integer , intent ( in ) :: data_loc type ( field_buffer_map_t ), allocatable , intent ( inout ) :: field_buffers (:) integer ( i8 ), dimension ( 3 ), intent ( inout ) :: last_shape_dims integer , dimension ( 3 ), intent ( inout ) :: last_stride_factors integer ( i8 ), dimension ( 3 ), intent ( inout ) :: last_output_shape integer :: dims ( 3 ), output_dims_local ( 3 ), i integer ( i8 ), dimension ( 3 ) :: shape_dims , start_dims , count_dims integer ( i8 ), dimension ( 3 ) :: output_shape , output_start , output_count dims = solver % mesh % get_dims ( data_loc ) shape_dims = int ( solver % mesh % get_global_dims ( data_loc ), i8 ) start_dims = int ( solver % mesh % par % n_offset , i8 ) count_dims = int ( dims , i8 ) call get_output_dimensions ( & shape_dims , start_dims , count_dims , stride_factors , & output_shape , output_start , output_count , & output_dims_local , & last_shape_dims , last_stride_factors , & last_output_shape & ) if ( allocated ( field_buffers )) deallocate ( field_buffers ) allocate ( field_buffers ( size ( field_names ))) do i = 1 , size ( field_names ) field_buffers ( i )% field_name = trim ( field_names ( i )) allocate ( & field_buffers ( i )% buffer ( & output_dims_local ( 1 ), & output_dims_local ( 2 ), & output_dims_local ( 3 ))) end do end subroutine prepare_field_buffers subroutine write_single_field_to_buffer ( & field_name , host_field , solver , stride_factors , data_loc , & field_buffers , last_shape_dims , last_stride_factors , last_output_shape & ) character ( len =* ), intent ( in ) :: field_name class ( field_t ), pointer :: host_field class ( solver_t ), intent ( in ) :: solver integer , dimension ( 3 ), intent ( in ) :: stride_factors integer , intent ( in ) :: data_loc type ( field_buffer_map_t ), intent ( inout ) :: field_buffers (:) integer ( i8 ), dimension ( 3 ), intent ( inout ) :: last_shape_dims integer , dimension ( 3 ), intent ( inout ) :: last_stride_factors integer ( i8 ), dimension ( 3 ), intent ( inout ) :: last_output_shape integer , dimension ( 3 ) :: output_dims_local integer ( i8 ), dimension ( 3 ) :: shape_dims , start_dims , count_dims integer ( i8 ), dimension ( 3 ) :: output_shape , output_start , output_count integer :: dims ( 3 ), buffer_idx logical :: buffer_found dims = solver % mesh % get_dims ( data_loc ) shape_dims = int ( solver % mesh % get_global_dims ( data_loc ), i8 ) start_dims = int ( solver % mesh % par % n_offset , i8 ) count_dims = int ( dims , i8 ) call get_output_dimensions ( & shape_dims , start_dims , count_dims , stride_factors , & output_shape , output_start , output_count , & output_dims_local , & last_shape_dims , last_stride_factors , & last_output_shape & ) buffer_found = . false . do buffer_idx = 1 , size ( field_buffers ) if ( trim ( field_buffers ( buffer_idx )% field_name ) == trim ( field_name )) then buffer_found = . true . exit end if end do if ( buffer_found ) then call stride_data_to_buffer ( & host_field % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 )), dims , & stride_factors , field_buffers ( buffer_idx )% buffer , & output_dims_local & ) else print * , 'INTERNAL ERROR: No buffer found for field: ' , trim ( field_name ) error stop 'Missing field buffer' end if end subroutine write_single_field_to_buffer subroutine cleanup_field_buffers ( field_buffers ) type ( field_buffer_map_t ), allocatable , intent ( inout ) :: field_buffers (:) integer :: i if ( allocated ( field_buffers )) then do i = 1 , size ( field_buffers ) if ( allocated ( field_buffers ( i )% buffer )) then deallocate ( field_buffers ( i )% buffer ) end if end do deallocate ( field_buffers ) end if end subroutine cleanup_field_buffers end module m_io_field_utils","tags":"","url":"sourcefile/io_field_utils.f90.html"},{"title":"xcompact.f90 – x3d2","text":"This file depends on sourcefile~~xcompact.f90~~EfferentGraph sourcefile~xcompact.f90 xcompact.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90~2 sourcefile~backend.f90 backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~backend.f90~3 backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~base_case.f90 base_case.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~channel.f90 channel.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~common.f90 common.f90 sourcefile~xcompact.f90->sourcefile~common.f90 sourcefile~common.f90~2 common.f90 sourcefile~xcompact.f90->sourcefile~common.f90~2 sourcefile~common.f90~3 common.f90 sourcefile~xcompact.f90->sourcefile~common.f90~3 sourcefile~config.f90 config.f90 sourcefile~xcompact.f90->sourcefile~config.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~generic.f90 generic.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~xcompact.f90->sourcefile~mesh.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~allocator.f90~2->sourcefile~allocator.f90 sourcefile~allocator.f90~2->sourcefile~common.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~allocator.f90~2->sourcefile~field.f90 sourcefile~backend.f90->sourcefile~allocator.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~backend.f90->sourcefile~common.f90 sourcefile~backend.f90->sourcefile~common.f90~2 sourcefile~backend.f90->sourcefile~mesh.f90 sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~backend.f90->sourcefile~exec_dist.f90~2 sourcefile~backend.f90->sourcefile~field.f90 sourcefile~ordering.f90 ordering.f90 sourcefile~backend.f90->sourcefile~ordering.f90 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~sendrecv.f90 sendrecv.f90 sourcefile~backend.f90->sourcefile~sendrecv.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90->sourcefile~tdsops.f90~2 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~backend.f90~3->sourcefile~allocator.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~backend.f90~3->sourcefile~common.f90 sourcefile~backend.f90~3->sourcefile~common.f90~3 sourcefile~backend.f90~3->sourcefile~mesh.f90 sourcefile~distributed.f90~2 distributed.f90 sourcefile~backend.f90~3->sourcefile~distributed.f90~2 sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~backend.f90~3->sourcefile~field.f90 sourcefile~fieldops.f90 fieldops.f90 sourcefile~backend.f90~3->sourcefile~fieldops.f90 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~reorder.f90 reorder.f90 sourcefile~backend.f90~3->sourcefile~reorder.f90 sourcefile~sendrecv.f90~2 sendrecv.f90 sourcefile~backend.f90~3->sourcefile~sendrecv.f90~2 sourcefile~tdsops.f90 tdsops.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90~2 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90->sourcefile~common.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~base_case.f90->sourcefile~field.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~channel.f90->sourcefile~allocator.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~common.f90 sourcefile~channel.f90->sourcefile~config.f90 sourcefile~channel.f90->sourcefile~mesh.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~cylinder.f90->sourcefile~allocator.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~common.f90 sourcefile~cylinder.f90->sourcefile~config.f90 sourcefile~cylinder.f90->sourcefile~mesh.f90 sourcefile~cylinder.f90->sourcefile~field.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~allocator.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~common.f90 sourcefile~generic.f90->sourcefile~mesh.f90 sourcefile~generic.f90->sourcefile~field.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~tgv.f90->sourcefile~allocator.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~common.f90 sourcefile~tgv.f90->sourcefile~mesh.f90 sourcefile~tgv.f90->sourcefile~field.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~distributed.f90~2->sourcefile~common.f90 sourcefile~exec_dist.f90->sourcefile~common.f90 sourcefile~exec_dist.f90->sourcefile~common.f90~3 sourcefile~exec_dist.f90->sourcefile~distributed.f90~2 sourcefile~exec_dist.f90->sourcefile~sendrecv.f90~2 sourcefile~exec_dist.f90->sourcefile~tdsops.f90 sourcefile~exec_dist.f90~2->sourcefile~common.f90 sourcefile~exec_dist.f90~2->sourcefile~common.f90~2 sourcefile~exec_dist.f90~2->sourcefile~sendrecv.f90 sourcefile~exec_dist.f90~2->sourcefile~tdsops.f90~2 sourcefile~distributed.f90 distributed.f90 sourcefile~exec_dist.f90~2->sourcefile~distributed.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~fieldops.f90->sourcefile~common.f90 sourcefile~fieldops.f90->sourcefile~common.f90~3 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~ordering.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~common.f90 sourcefile~poisson_fft.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~field.f90 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~2->sourcefile~tdsops.f90~2 sourcefile~spectral_processing.f90~2 spectral_processing.f90 sourcefile~poisson_fft.f90~2->sourcefile~spectral_processing.f90~2 sourcefile~poisson_fft.f90~3->sourcefile~common.f90 sourcefile~poisson_fft.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~3->sourcefile~field.f90 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~tdsops.f90~2 sourcefile~spectral_processing.f90 spectral_processing.f90 sourcefile~poisson_fft.f90~3->sourcefile~spectral_processing.f90 sourcefile~reorder.f90->sourcefile~common.f90 sourcefile~reorder.f90->sourcefile~common.f90~3 sourcefile~sendrecv.f90->sourcefile~common.f90 sourcefile~sendrecv.f90~2->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~tdsops.f90->sourcefile~common.f90 sourcefile~tdsops.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~distributed.f90->sourcefile~common.f90 sourcefile~distributed.f90->sourcefile~common.f90~2 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~spectral_processing.f90->sourcefile~common.f90 sourcefile~spectral_processing.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program xcompact use mpi use m_allocator use m_base_backend use m_base_case , only : base_case_t use m_common , only : pi , get_argument , VERT use m_config , only : domain_config_t , solver_config_t use m_mesh use m_case_channel , only : case_channel_t use m_case_cylinder , only : case_cylinder_t use m_case_generic , only : case_generic_t use m_case_tgv , only : case_tgv_t #ifdef CUDA use m_cuda_allocator use m_cuda_backend use m_cuda_common , only : SZ #else use m_omp_backend use m_omp_common , only : SZ #endif implicit none class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator type ( allocator_t ), pointer :: host_allocator type ( mesh_t ), target :: mesh class ( base_case_t ), allocatable :: flow_case #ifdef CUDA type ( cuda_backend_t ), target :: cuda_backend type ( cuda_allocator_t ), target :: cuda_allocator integer :: ndevs , devnum #else type ( omp_backend_t ), target :: omp_backend #endif type ( allocator_t ), target :: omp_allocator real ( dp ) :: t_start , t_end type ( domain_config_t ) :: domain_cfg type ( solver_config_t ) :: solver_cfg character ( 32 ) :: backend_name integer :: dims ( 3 ), nrank , nproc , ierr logical :: use_2decomp call MPI_Init ( ierr ) call MPI_Comm_rank ( MPI_COMM_WORLD , nrank , ierr ) call MPI_Comm_size ( MPI_COMM_WORLD , nproc , ierr ) if ( nrank == 0 ) then print * , 'Parallel run with' , nproc , 'ranks' print * , 'Data precision is' , dp end if #ifdef CUDA ierr = cudaGetDeviceCount ( ndevs ) ierr = cudaSetDevice ( mod ( nrank , ndevs )) ! round-robin ierr = cudaGetDevice ( devnum ) backend_name = \"CUDA\" #else backend_name = \"OMP\" #endif call domain_cfg % read ( nml_file = get_argument ( 1 )) call solver_cfg % read ( nml_file = get_argument ( 1 )) if ( product ( domain_cfg % nproc_dir ) /= nproc ) then if ( nrank == 0 ) print * , 'nproc_dir specified in the input file does & &not match the total number of ranks, falling & &back to a 1D decomposition along Z-dir instead.' domain_cfg % nproc_dir = [ 1 , 1 , nproc ] end if ! Decide whether 2decomp is used or not use_2decomp = solver_cfg % poisson_solver_type == 'FFT' & . and . trim ( backend_name ) == 'OMP' mesh = mesh_t ( domain_cfg % dims_global , domain_cfg % nproc_dir , & domain_cfg % L_global , domain_cfg % BC_x , domain_cfg % BC_y , & domain_cfg % BC_z , domain_cfg % stretching , domain_cfg % beta , & use_2decomp = use_2decomp ) ! get local vertex dimensions dims = mesh % get_dims ( VERT ) #ifdef CUDA cuda_allocator = cuda_allocator_t ( dims , SZ ) allocator => cuda_allocator if ( nrank == 0 ) print * , 'CUDA allocator instantiated' omp_allocator = allocator_t ( dims , SZ ) host_allocator => omp_allocator cuda_backend = cuda_backend_t ( mesh , allocator ) backend => cuda_backend if ( nrank == 0 ) print * , 'CUDA backend instantiated' #else omp_allocator = allocator_t ( dims , SZ ) allocator => omp_allocator host_allocator => omp_allocator if ( nrank == 0 ) print * , 'OpenMP allocator instantiated' omp_backend = omp_backend_t ( mesh , allocator ) backend => omp_backend if ( nrank == 0 ) print * , 'OpenMP backend instantiated' #endif if ( nrank == 0 ) print * , 'Flow case: ' , domain_cfg % flow_case_name select case ( trim ( domain_cfg % flow_case_name )) case ( 'channel' ) allocate ( case_channel_t :: flow_case ) flow_case = case_channel_t ( backend , mesh , host_allocator ) case ( 'cylinder' ) allocate ( case_cylinder_t :: flow_case ) flow_case = case_cylinder_t ( backend , mesh , host_allocator ) case ( 'generic' ) allocate ( case_generic_t :: flow_case ) flow_case = case_generic_t ( backend , mesh , host_allocator ) case ( 'tgv' ) allocate ( case_tgv_t :: flow_case ) flow_case = case_tgv_t ( backend , mesh , host_allocator ) case default error stop 'Undefined flow_case.' end select if ( nrank == 0 ) print * , 'solver instantiated' call cpu_time ( t_start ) call flow_case % run () call cpu_time ( t_end ) if ( nrank == 0 ) print * , 'Time: ' , t_end - t_start call MPI_Finalize ( ierr ) end program xcompact","tags":"","url":"sourcefile/xcompact.f90.html"},{"title":"decomp_2decompfft.f90 – x3d2","text":"This file depends on sourcefile~~decomp_2decompfft.f90~~EfferentGraph sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~common.f90 common.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~decomp_2decompfft.f90~~AfferentGraph sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~mesh.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~mesh.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~mesh.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~mesh.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~mesh.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~mesh.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~mesh.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_decomp !! Parallel decomposition provided by 2decomp&FFT use mpi implicit none contains function is_avail_2decomp () result ( avail ) logical :: avail avail = . true . end function subroutine decomposition_2decomp ( grid , par ) !! Performs 2D mesh decomposition using 2decomp&fft use m_mesh_content , only : par_t , grid_t use decomp_2d , only : decomp_2d_init , DECOMP_2D_COMM_CART_X , xsize , xstart use decomp_2d_mpi , only : nrank , nproc class ( grid_t ), intent ( inout ) :: grid class ( par_t ), intent ( inout ) :: par integer :: p_col , p_row integer , allocatable , dimension (:, :, :) :: global_ranks integer , allocatable , dimension (:) :: global_ranks_lin logical , dimension ( 3 ) :: periodic_bc integer :: nx , ny , nz integer :: ierr integer :: cart_rank integer , dimension ( 2 ) :: coords if ( par % is_root ()) then print * , \"Domain decomposition by 2decomp&fft\" end if nrank = par % nrank nproc = par % nproc nx = grid % global_vert_dims ( 1 ) ny = grid % global_vert_dims ( 2 ) nz = grid % global_vert_dims ( 3 ) p_row = par % nproc_dir ( 2 ) p_col = par % nproc_dir ( 3 ) if ( p_row * p_col /= par % nproc ) then error stop \"Decomposition in X not supported by 2decomp&fft backend\" end if periodic_bc (:) = grid % periodic_BC (:) call decomp_2d_init ( nx , ny , nz , p_row , p_col , periodic_bc ) ! Get global_ranks allocate ( global_ranks ( 1 , p_row , p_col )) allocate ( global_ranks_lin ( p_row * p_col )) global_ranks_lin (:) = 0 call MPI_Comm_rank ( DECOMP_2D_COMM_CART_X , cart_rank , ierr ) call MPI_Cart_coords ( DECOMP_2D_COMM_CART_X , cart_rank , 2 , coords , ierr ) global_ranks_lin ( coords ( 1 ) + 1 + p_row * ( coords ( 2 ))) = par % nrank call MPI_Allreduce ( MPI_IN_PLACE , global_ranks_lin , p_row * p_col , & MPI_INTEGER , MPI_SUM , MPI_COMM_WORLD , ierr ) global_ranks = reshape ( global_ranks_lin , shape = [ 1 , p_row , p_col ]) ! Get local domain size and offset from 2decomp grid % vert_dims (:) = xsize (:) par % n_offset (:) = xstart (:) - 1 call par % compute_rank_pos_from_global ( global_ranks ) call grid % copy_vert2cell_dims ( par ) end subroutine decomposition_2decomp end module","tags":"","url":"sourcefile/decomp_2decompfft.f90.html"},{"title":"sendrecv.f90 – x3d2","text":"This file depends on sourcefile~~sendrecv.f90~2~~EfferentGraph sourcefile~sendrecv.f90~2 sendrecv.f90 sourcefile~common.f90 common.f90 sourcefile~sendrecv.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~sendrecv.f90~2~~AfferentGraph sourcefile~sendrecv.f90~2 sendrecv.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~sendrecv.f90~2 sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~exec_dist.f90->sourcefile~sendrecv.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_sendrecv use cudafor use mpi use m_common , only : dp , MPI_X3D2_DP implicit none contains subroutine sendrecv_fields ( f_recv_s , f_recv_e , f_send_s , f_send_e , & n_data , nproc , prev , next ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: f_recv_s , f_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: f_send_s , f_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 4 ), err ( 4 ), ierr , tag = 1234 if ( nproc == 1 ) then f_recv_s = f_send_e f_recv_e = f_send_s else call MPI_Isend ( f_send_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f_recv_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f_send_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f_recv_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Waitall ( 4 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_fields subroutine sendrecv_3fields ( & f1_recv_s , f1_recv_e , f2_recv_s , f2_recv_e , f3_recv_s , f3_recv_e , & f1_send_s , f1_send_e , f2_send_s , f2_send_e , f3_send_s , f3_send_e , & n_data , nproc , prev , next & ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: & f1_recv_s , f1_recv_e , f2_recv_s , f2_recv_e , f3_recv_s , f3_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: & f1_send_s , f1_send_e , f2_send_s , f2_send_e , f3_send_s , f3_send_e integer , intent ( in ) :: n_data , nproc , prev , next integer :: req ( 12 ), err ( 12 ), ierr , tag = 1234 if ( nproc == 1 ) then f1_recv_s = f1_send_e f1_recv_e = f1_send_s f2_recv_s = f2_send_e f2_recv_e = f2_send_s f3_recv_s = f3_send_e f3_recv_e = f3_send_s else call MPI_Isend ( f1_send_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 1 ), err ( 1 )) call MPI_Irecv ( f1_recv_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 2 ), err ( 2 )) call MPI_Isend ( f1_send_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 3 ), err ( 3 )) call MPI_Irecv ( f1_recv_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 4 ), err ( 4 )) call MPI_Isend ( f2_send_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 5 ), err ( 5 )) call MPI_Irecv ( f2_recv_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 6 ), err ( 6 )) call MPI_Isend ( f2_send_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 7 ), err ( 7 )) call MPI_Irecv ( f2_recv_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 8 ), err ( 8 )) call MPI_Isend ( f3_send_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 9 ), err ( 9 )) call MPI_Irecv ( f3_recv_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 10 ), err ( 10 )) call MPI_Isend ( f3_send_e , n_data , MPI_X3D2_DP , & next , tag , MPI_COMM_WORLD , req ( 11 ), err ( 11 )) call MPI_Irecv ( f3_recv_s , n_data , MPI_X3D2_DP , & prev , tag , MPI_COMM_WORLD , req ( 12 ), err ( 12 )) call MPI_Waitall ( 12 , req , MPI_STATUSES_IGNORE , ierr ) end if end subroutine sendrecv_3fields end module m_cuda_sendrecv","tags":"","url":"sourcefile/sendrecv.f90~2.html"},{"title":"fieldops.f90 – x3d2","text":"This file depends on sourcefile~~fieldops.f90~~EfferentGraph sourcefile~fieldops.f90 fieldops.f90 sourcefile~common.f90 common.f90 sourcefile~fieldops.f90->sourcefile~common.f90 sourcefile~common.f90~3 common.f90 sourcefile~fieldops.f90->sourcefile~common.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~fieldops.f90~~AfferentGraph sourcefile~fieldops.f90 fieldops.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~fieldops.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_kernels_fieldops use cudafor use m_common , only : dp use m_cuda_common , only : SZ contains attributes ( global ) subroutine copy ( n , dst , src ) implicit none integer , value , intent ( in ) :: n real ( dp ), device , intent ( out ), dimension (:, :, :) :: dst real ( dp ), device , intent ( in ), dimension (:, :, :) :: src integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n dst ( i , j , b ) = src ( i , j , b ) end do end subroutine copy attributes ( global ) subroutine axpby ( n , alpha , x , beta , y ) implicit none integer , value , intent ( in ) :: n real ( dp ), value , intent ( in ) :: alpha , beta real ( dp ), device , intent ( in ), dimension (:, :, :) :: x real ( dp ), device , intent ( inout ), dimension (:, :, :) :: y integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n y ( i , j , b ) = alpha * x ( i , j , b ) + beta * y ( i , j , b ) end do end subroutine axpby attributes ( global ) subroutine pwmul ( y , x , n ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: y real ( dp ), device , intent ( in ), dimension (:, :, :) :: x integer , value , intent ( in ) :: n integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n y ( i , j , b ) = y ( i , j , b ) * x ( i , j , b ) end do end subroutine pwmul attributes ( global ) subroutine buffer_copy ( u_send_s , u_send_e , u , n , n_halo ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_send_s , u_send_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u integer , value , intent ( in ) :: n , n_halo integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n_halo u_send_s ( i , j , b ) = u ( i , j , b ) u_send_e ( i , j , b ) = u ( i , n - n_halo + j , b ) end do end subroutine buffer_copy attributes ( global ) subroutine field_scale ( f , alpha , n ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: f real ( dp ), value , intent ( in ) :: alpha integer , value , intent ( in ) :: n integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n f ( i , j , b ) = alpha * f ( i , j , b ) end do end subroutine field_scale attributes ( global ) subroutine field_shift ( f , const , n ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: f real ( dp ), value , intent ( in ) :: const integer , value , intent ( in ) :: n integer :: i , j , b i = threadIdx % x b = blockIdx % x do j = 1 , n f ( i , j , b ) = f ( i , j , b ) + const end do end subroutine field_shift attributes ( global ) subroutine scalar_product ( s , x , y , n , n_i_pad , n_j ) implicit none real ( dp ), device , intent ( inout ) :: s real ( dp ), device , intent ( in ), dimension (:, :, :) :: x , y integer , value , intent ( in ) :: n , n_i_pad , n_j real ( dp ) :: s_pncl !! pencil sum integer :: i , j , b , b_i , b_j , ierr i = threadIdx % x b_i = blockIdx % x b_j = blockIdx % y b = b_i + ( b_j - 1 ) * n_i_pad s_pncl = 0._dp if ( i + ( b_j - 1 ) * blockDim % x <= n_j ) then do j = 1 , n s_pncl = s_pncl + x ( i , j , b ) * y ( i , j , b ) end do end if ierr = atomicadd ( s , s_pncl ) end subroutine scalar_product attributes ( global ) subroutine field_max_sum ( max_f , sum_f , f , n , n_i_pad , n_j ) implicit none real ( dp ), device , intent ( inout ) :: max_f , sum_f real ( dp ), device , intent ( in ), dimension (:, :, :) :: f integer , value , intent ( in ) :: n , n_i_pad , n_j real ( dp ) :: max_pncl , sum_pncl , val integer :: i , j , b , b_i , b_j , ierr i = threadIdx % x b_i = blockIdx % x b_j = blockIdx % y b = b_i + ( b_j - 1 ) * n_i_pad max_pncl = 0._dp sum_pncl = 0._dp if ( i + ( b_j - 1 ) * blockDim % x <= n_j ) then do j = 1 , n val = abs ( f ( i , j , b )) sum_pncl = sum_pncl + val max_pncl = max ( max_pncl , val ) end do end if ierr = atomicadd ( sum_f , sum_pncl ) ierr = atomicmax ( max_f , max_pncl ) end subroutine field_max_sum attributes ( global ) subroutine field_set_y_face ( f , c_start , c_end , nx , ny , nz ) !! Set domain Y_FACE to a constant !! c_start at the bottom and c_end at the top implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: f real ( dp ), value , intent ( in ) :: c_start , c_end integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , b , n_mod , b_end j = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x ! from 1 to nx b = blockIdx % y ! from 1 to nz n_mod = mod ( ny - 1 , SZ ) + 1 b_end = b + ( ny - 1 ) / SZ * nz if ( j <= nx ) then f ( 1 , j , b ) = c_start f ( n_mod , j , b_end ) = c_end end if end subroutine field_set_y_face attributes ( global ) subroutine volume_integral ( s , f , n , n_i_pad , n_j ) implicit none real ( dp ), device , intent ( inout ) :: s real ( dp ), device , intent ( in ), dimension (:, :, :) :: f integer , value , intent ( in ) :: n , n_i_pad , n_j real ( dp ) :: s_pncl !! pencil sum integer :: i , j , b , b_i , b_j , ierr i = threadIdx % x b_i = blockIdx % x b_j = blockIdx % y b = b_i + ( b_j - 1 ) * n_i_pad s_pncl = 0._dp if ( i + ( b_j - 1 ) * blockDim % x <= n_j ) then do j = 1 , n s_pncl = s_pncl + f ( i , j , b ) end do end if ierr = atomicadd ( s , s_pncl ) end subroutine volume_integral end module m_cuda_kernels_fieldops","tags":"","url":"sourcefile/fieldops.f90.html"},{"title":"poisson_fft.f90 – x3d2","text":"This file depends on sourcefile~~poisson_fft.f90~~EfferentGraph sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~common.f90 common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~poisson_fft.f90~~AfferentGraph sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_poisson_fft use m_common , only : dp , pi , CELL use m_field , only : field_t use m_mesh , only : mesh_t , geo_t use m_tdsops , only : dirps_t implicit none type , abstract :: poisson_fft_t !! FFT based Poisson solver type ( mesh_t ), pointer :: mesh => null () !> Global dimensions integer :: nx_glob , ny_glob , nz_glob !> Local dimensions integer :: nx_loc , ny_loc , nz_loc !> Local dimensions in the permuted slabs integer :: nx_perm , ny_perm , nz_perm !> Local dimensions in the permuted slabs in spectral space integer :: nx_spec , ny_spec , nz_spec !> Offset in y and z directions in the permuted slabs in spectral space integer :: x_sp_st , y_sp_st , z_sp_st !> Local domain sized array storing the spectral equivalence constants complex ( dp ), allocatable , dimension (:, :, :) :: waves !> Wave numbers in x, y, and z real ( dp ), allocatable , dimension (:) :: ax , bx , ay , by , az , bz !> Wave numbers in x, y, and z complex ( dp ), allocatable , dimension (:) :: kx , ky , kz , exs , eys , ezs , & k2x , k2y , k2z !> Staggared grid transformation real ( dp ), allocatable , dimension (:) :: trans_x_re , trans_x_im , & trans_y_re , trans_y_im , & trans_z_re , trans_z_im !> Periodicity in x, y, and z logical :: periodic_x , periodic_y , periodic_z , & stretched_y = . false ., stretched_y_sym !> Stretching operator matrices real ( dp ), allocatable , dimension (:, :, :, :) :: a_odd_re , a_odd_im , & a_even_re , a_even_im , & a_re , a_im !> lowmem option, only used in CUDA backend logical :: lowmem = . false . !> Procedure pointer to BC specific poisson solvers procedure ( poisson_xxx ), pointer :: poisson => null () contains procedure ( fft_forward ), deferred :: fft_forward_010 procedure ( fft_forward ), deferred :: fft_forward_100 procedure ( fft_forward ), deferred :: fft_forward_110 procedure ( fft_forward ), deferred :: fft_forward procedure ( fft_backward ), deferred :: fft_backward_010 procedure ( fft_backward ), deferred :: fft_backward_100 procedure ( fft_backward ), deferred :: fft_backward_110 procedure ( fft_backward ), deferred :: fft_backward procedure ( fft_postprocess ), deferred :: fft_postprocess_000 procedure ( fft_postprocess ), deferred :: fft_postprocess_010 procedure ( fft_postprocess ), deferred :: fft_postprocess_100 procedure ( fft_postprocess ), deferred :: fft_postprocess_110 procedure ( field_process ), deferred :: enforce_periodicity_x procedure ( field_process ), deferred :: undo_periodicity_x procedure ( field_process ), deferred :: enforce_periodicity_y procedure ( field_process ), deferred :: undo_periodicity_y procedure :: base_init procedure :: solve_poisson procedure :: stretching_matrix procedure :: waves_set procedure :: get_km procedure :: get_km_re procedure :: get_km_im end type poisson_fft_t abstract interface subroutine fft_forward ( self , f_in ) import :: poisson_fft_t import :: field_t implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in end subroutine fft_forward subroutine fft_backward ( self , f_out ) import :: poisson_fft_t import :: field_t implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out end subroutine fft_backward subroutine fft_postprocess ( self ) import :: poisson_fft_t implicit none class ( poisson_fft_t ) :: self end subroutine fft_postprocess end interface abstract interface subroutine poisson_xxx ( self , f , temp ) import :: poisson_fft_t import :: field_t class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f , temp end subroutine poisson_xxx subroutine field_process ( self , f_out , f_in ) import :: poisson_fft_t import :: field_t class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in end subroutine field_process end interface contains subroutine base_init ( self , mesh , xdirps , ydirps , zdirps , n_spec , n_sp_st ) implicit none class ( poisson_fft_t ) :: self type ( mesh_t ), intent ( in ), target :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps integer , dimension ( 3 ), intent ( in ) :: n_spec ! Size of the spectral pencil integer , dimension ( 3 ), intent ( in ) :: n_sp_st ! Offset of the spectral pencil integer :: dims ( 3 ) self % mesh => mesh ! Decomposition is in y- and z-directions if ( mesh % par % nproc_dir ( 1 ) /= 1 ) print * , 'nproc_dir in x-dir must be 1' dims = mesh % get_global_dims ( CELL ) self % nx_glob = dims ( 1 ); self % ny_glob = dims ( 2 ); self % nz_glob = dims ( 3 ) dims = mesh % get_dims ( CELL ) self % nx_loc = dims ( 1 ); self % ny_loc = dims ( 2 ); self % nz_loc = dims ( 3 ) self % nx_spec = n_spec ( 1 ) self % ny_spec = n_spec ( 2 ) self % nz_spec = n_spec ( 3 ) self % periodic_x = mesh % grid % periodic_BC ( 1 ) self % periodic_y = mesh % grid % periodic_BC ( 2 ) self % periodic_z = mesh % grid % periodic_BC ( 3 ) self % x_sp_st = n_sp_st ( 1 ) self % y_sp_st = n_sp_st ( 2 ) self % z_sp_st = n_sp_st ( 3 ) allocate ( self % ax ( self % nx_glob ), self % bx ( self % nx_glob )) allocate ( self % ay ( self % ny_glob ), self % by ( self % ny_glob )) allocate ( self % az ( self % nz_glob ), self % bz ( self % nz_glob )) allocate ( self % kx ( self % nx_glob ), self % k2x ( self % nx_glob )) allocate ( self % ky ( self % ny_glob ), self % k2y ( self % ny_glob )) allocate ( self % kz ( self % nz_glob ), self % k2z ( self % nz_glob )) allocate ( self % exs ( self % nx_glob )) allocate ( self % eys ( self % ny_glob )) allocate ( self % ezs ( self % nz_glob )) allocate ( self % trans_x_re ( self % nx_spec ), self % trans_x_im ( self % nx_spec )) allocate ( self % trans_y_re ( self % ny_spec ), self % trans_y_im ( self % ny_spec )) allocate ( self % trans_z_re ( self % nz_spec ), self % trans_z_im ( self % nz_spec )) allocate ( self % waves ( self % nx_spec , self % ny_spec , self % nz_spec )) ! waves_set requires some of the preprocessed tdsops variables. call self % waves_set ( mesh % geo , xdirps , ydirps , zdirps ) if ( mesh % geo % stretched ( 1 ) . or . mesh % geo % stretched ( 3 )) then error stop 'FFT based Poisson solver does not support stretching in x-& & or z-directions!' end if ! use correct procedure based on BCs if ( self % periodic_x . and . self % periodic_y . and . self % periodic_z ) then self % poisson => poisson_000 else if ( self % periodic_x . and . (. not . self % periodic_y ) & . and . ( self % periodic_z )) then if ( mesh % par % nproc > 1 ) then error stop 'Multiple ranks are not yet supported for non-periodic BCs!' end if self % poisson => poisson_010 ! stretching requires some coefficients matrices if ( mesh % geo % stretched ( 2 )) then self % stretched_y = . true . call self % stretching_matrix ( mesh % geo , xdirps , ydirps , zdirps ) end if else if ((. not . self % periodic_x ) . and . ( self % periodic_y ) & . and . ( self % periodic_z )) then if ( mesh % par % nproc > 1 ) then error stop 'Multiple ranks are not yet supported for non-periodic BCs!' end if self % poisson => poisson_100 else if ((. not . self % periodic_x ) . and . (. not . self % periodic_y ) & . and . ( self % periodic_z )) then if ( mesh % par % nproc > 1 ) then error stop 'Multiple ranks are not yet supported for non-periodic BCs!' end if self % poisson => poisson_110 else error stop 'Requested BCs are not supported in FFT-based Poisson solver!' end if end subroutine base_init subroutine solve_poisson ( self , f , temp ) implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f , temp call self % poisson ( f , temp ) end subroutine solve_poisson subroutine poisson_000 ( self , f , temp ) implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f , temp call self % fft_forward ( f ) call self % fft_postprocess_000 call self % fft_backward ( f ) end subroutine poisson_000 subroutine poisson_010 ( self , f , temp ) implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f , temp call self % enforce_periodicity_y ( temp , f ) call self % fft_forward_010 ( temp ) call self % fft_postprocess_010 call self % fft_backward_010 ( temp ) call self % undo_periodicity_y ( f , temp ) end subroutine poisson_010 subroutine poisson_100 ( self , f , temp ) implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f , temp call self % enforce_periodicity_x ( temp , f ) call self % fft_forward_100 ( temp ) call self % fft_postprocess_100 call self % fft_backward_100 ( temp ) call self % undo_periodicity_x ( f , temp ) end subroutine poisson_100 subroutine poisson_110 ( self , f , temp ) implicit none class ( poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f , temp ! Apply periodicity enforcement for both X and Y call self % enforce_periodicity_x ( temp , f ) call self % enforce_periodicity_y ( f , temp ) call self % fft_forward_110 ( f ) call self % fft_postprocess_110 call self % fft_backward_110 ( f ) ! Undo periodicity for both X and Y call self % undo_periodicity_y ( temp , f ) call self % undo_periodicity_x ( f , temp ) end subroutine poisson_110 subroutine stretching_matrix ( self , geo , xdirps , ydirps , zdirps ) !! Stretching necessitates a special operation in spectral space. !! The coefficients for the operation are stored in matrix form. !! !! Ref. JCP 228 (2009), 5989–6015, Sec 5 implicit none class ( poisson_fft_t ) :: self type ( geo_t ), intent ( in ) :: geo type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps real ( dp ) :: temp , a0 , a1 , c1_od , c2_od , c1_ev , c2_ev complex ( dp ) :: km_a1 , km_a1_od , km_a1_ev integer :: i , j , k , ix , iy , iz , iy_od , iy_ev do i = 1 , self % nx_spec temp = real ( self % exs ( i ), kind = dp ) * geo % d ( 1 ) self % trans_x_re ( i ) = 2 * ( xdirps % interpl_v2p % a * cos ( temp * 0.5_dp ) & + xdirps % interpl_v2p % b * cos ( temp * 1.5_dp ) & + xdirps % interpl_v2p % c * cos ( temp * 2.5_dp ) & + xdirps % interpl_v2p % d * cos ( temp * 3.5_dp )) & / ( 1._dp + 2 * xdirps % interpl_v2p % alpha * cos ( temp )) self % trans_x_im ( i ) = self % trans_x_re ( i ) end do do j = 1 , self % ny_spec temp = real ( self % eys ( j ), kind = dp ) * geo % d ( 2 ) self % trans_y_re ( j ) = 2 * ( ydirps % interpl_v2p % a * cos ( temp * 0.5_dp ) & + ydirps % interpl_v2p % b * cos ( temp * 1.5_dp ) & + ydirps % interpl_v2p % c * cos ( temp * 2.5_dp ) & + ydirps % interpl_v2p % d * cos ( temp * 3.5_dp )) & / ( 1._dp + 2 * ydirps % interpl_v2p % alpha * cos ( temp )) self % trans_y_im ( j ) = self % trans_y_re ( j ) end do do k = 1 , self % nz_spec temp = real ( self % ezs ( k ), kind = dp ) * geo % d ( 3 ) self % trans_z_re ( k ) = 2 * ( zdirps % interpl_v2p % a * cos ( temp * 0.5_dp ) & + zdirps % interpl_v2p % b * cos ( temp * 1.5_dp ) & + zdirps % interpl_v2p % c * cos ( temp * 2.5_dp ) & + zdirps % interpl_v2p % d * cos ( temp * 3.5_dp )) & / ( 1._dp + 2 * zdirps % interpl_v2p % alpha * cos ( temp )) self % trans_z_im ( k ) = self % trans_z_re ( k ) end do if ( trim ( geo % stretching ( 2 )) == 'bottom' ) then self % stretched_y_sym = . false . allocate ( self % a_re ( self % nx_spec , self % ny_spec , self % nz_spec , 5 )) allocate ( self % a_im ( self % nx_spec , self % ny_spec , self % nz_spec , 5 )) a0 = ( geo % alpha ( 2 ) / pi + 1._dp / ( 2 * pi * geo % beta ( 2 ))) * geo % L ( 2 ) a1 = - 1._dp / ( 4 * pi * geo % beta ( 2 )) * geo % L ( 2 ) ! diagonal do k = 1 , self % nz_spec do j = 1 , self % ny_spec do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st if ( iy == 1 ) then km_a1 = self % get_km ( ix , 2 , iz ) else if ( iy == self % ny_spec ) then km_a1 = self % get_km ( ix , self % ny_spec - 1 , iz ) else km_a1 = self % get_km ( ix , iy - 1 , iz ) + self % get_km ( ix , iy + 1 , iz ) end if self % a_re ( i , j , k , 3 ) = & - ( get_real ( self % kx ( ix )) & * self % trans_y_re ( iy ) * self % trans_z_re ( iz )) ** 2 & - ( get_real ( self % kz ( iz )) & * self % trans_y_re ( iy ) * self % trans_x_re ( ix )) ** 2 & - a0 ** 2 * self % get_km_re ( ix , iy , iz ) ** 2 & - a1 ** 2 * self % get_km_re ( ix , iy , iz ) * get_real ( km_a1 ) self % a_im ( i , j , k , 3 ) = & - ( get_imag ( self % kx ( ix )) & * self % trans_y_im ( iy ) * self % trans_z_im ( iz )) ** 2 & - ( get_imag ( self % kz ( iz )) & * self % trans_y_im ( iy ) * self % trans_x_im ( ix )) ** 2 & - a0 ** 2 * self % get_km_im ( ix , iy , iz ) ** 2 & - a1 ** 2 * self % get_km_im ( ix , iy , iz ) * get_imag ( km_a1 ) end do end do end do ! diagonal + 1 do k = 1 , self % nz_spec do j = 1 , self % ny_spec do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st self % a_re ( i , j , k , 4 ) = & a0 * a1 * self % get_km_re ( ix , iy + 1 , iz ) & * ( self % get_km_re ( ix , iy , iz ) + self % get_km_re ( ix , iy + 1 , iz )) self % a_im ( i , j , k , 4 ) = & a0 * a1 * self % get_km_im ( ix , iy + 1 , iz ) & * ( self % get_km_im ( ix , iy , iz ) + self % get_km_im ( ix , iy + 1 , iz )) end do end do end do ! diagonal + 2 do k = 1 , self % nz_spec do j = 1 , self % ny_spec - 2 do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st self % a_re ( i , j , k , 5 ) = - a1 * a1 * self % get_km_re ( ix , iy + 1 , iz ) & * self % get_km_re ( ix , iy + 2 , iz ) self % a_im ( i , j , k , 5 ) = - a1 * a1 * self % get_km_im ( ix , iy + 1 , iz ) & * self % get_km_im ( ix , iy + 2 , iz ) end do end do end do ! diagonal - 1 do k = 1 , self % nz_spec do j = 2 , self % ny_spec do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st self % a_re ( i , j , k , 2 ) = a0 * a1 * self % get_km_re ( ix , iy - 1 , iz ) & * ( self % get_km_re ( ix , iy , iz ) & + self % get_km_re ( ix , iy - 1 , iz )) self % a_im ( i , j , k , 2 ) = a0 * a1 * self % get_km_im ( ix , iy - 1 , iz ) & * ( self % get_km_im ( ix , iy , iz ) & + self % get_km_im ( ix , iy - 1 , iz )) end do end do end do ! diagonal - 2 do k = 1 , self % nz_spec do j = 3 , self % ny_spec do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st self % a_re ( i , j , k , 1 ) = - a1 * a1 * self % get_km_re ( ix , iy - 1 , iz ) & * self % get_km_re ( ix , iy - 2 , iz ) self % a_im ( i , j , k , 1 ) = - a1 * a1 * self % get_km_im ( ix , iy - 1 , iz ) & * self % get_km_im ( ix , iy - 2 , iz ) end do end do end do ! tweak the matrix to make it not singular self % a_re ( 1 , 1 , 1 , 3 ) = 1._dp ; self % a_im ( 1 , 1 , 1 , 3 ) = 1._dp self % a_re ( 1 , 1 , 1 , 4 ) = 0 ; self % a_im ( 1 , 1 , 1 , 4 ) = 0 self % a_re ( 1 , 1 , 1 , 5 ) = 0 ; self % a_im ( 1 , 1 , 1 , 5 ) = 0 else self % stretched_y_sym = . true . allocate ( self % a_odd_re ( self % nx_spec , self % ny_spec / 2 , self % nz_spec , 5 )) allocate ( self % a_odd_im ( self % nx_spec , self % ny_spec / 2 , self % nz_spec , 5 )) allocate ( self % a_even_re ( self % nx_spec , self % ny_spec / 2 , self % nz_spec , 5 )) allocate ( self % a_even_im ( self % nx_spec , self % ny_spec / 2 , self % nz_spec , 5 )) self % a_odd_re = 0._dp self % a_odd_im = 0._dp self % a_even_re = 0._dp self % a_even_im = 0._dp a0 = ( geo % alpha ( 2 ) / pi + 1._dp / ( 2 * pi * geo % beta ( 2 ))) * geo % L ( 2 ) select case ( trim ( geo % stretching ( 2 ))) case ( 'centred' ) a1 = 1._dp / ( 4 * pi * geo % beta ( 2 )) * geo % L ( 2 ) case ( 'top-bottom' ) a1 = - 1._dp / ( 4 * pi * geo % beta ( 2 )) * geo % L ( 2 ) case default a1 = 0._dp end select ! diagonal do k = 1 , self % nz_spec do j = 1 , self % ny_spec / 2 do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st iy_od = 2 * iy - 1 iy_ev = 2 * iy c1_od = a0 * a0 c2_od = a1 * a1 c1_ev = a0 * a0 c2_ev = a1 * a1 if ( iy == 1 ) then c1_ev = a0 * a0 - a1 * a1 km_a1_od = self % get_km ( ix , 3 , iz ) km_a1_ev = self % get_km ( ix , 4 , iz ) else if ( iy == self % ny_spec / 2 ) then c1_ev = ( a0 + a1 ) * ( a0 + a1 ) km_a1_od = self % get_km ( ix , iy_od - 2 , iz ) km_a1_ev = self % get_km ( ix , iy_ev - 2 , iz ) else km_a1_od = self % get_km ( ix , iy_od - 2 , iz ) & + self % get_km ( ix , iy_od + 2 , iz ) km_a1_ev = self % get_km ( ix , iy_ev - 2 , iz ) & + self % get_km ( ix , iy_ev + 2 , iz ) end if self % a_odd_re ( i , j , k , 3 ) = & - ( get_real ( self % kx ( ix )) & * self % trans_y_re ( iy_od ) * self % trans_z_re ( iz )) ** 2 & - ( get_real ( self % kz ( iz )) & * self % trans_y_re ( iy_od ) * self % trans_x_re ( ix )) ** 2 & - c1_od * self % get_km_re ( ix , iy_od , iz ) ** 2 & - c2_od * self % get_km_re ( ix , iy_od , iz ) * get_real ( km_a1_od ) self % a_odd_im ( i , j , k , 3 ) = & - ( get_imag ( self % kx ( ix )) & * self % trans_y_im ( iy_od ) * self % trans_z_im ( iz )) ** 2 & - ( get_imag ( self % kz ( iz )) & * self % trans_y_im ( iy_od ) * self % trans_x_im ( ix )) ** 2 & - c1_od * self % get_km_im ( ix , iy_od , iz ) ** 2 & - c2_od * self % get_km_im ( ix , iy_od , iz ) * get_imag ( km_a1_od ) self % a_even_re ( i , j , k , 3 ) = & - ( get_real ( self % kx ( ix )) & * self % trans_y_re ( iy_ev ) * self % trans_z_re ( iz )) ** 2 & - ( get_real ( self % kz ( iz )) & * self % trans_y_re ( iy_ev ) * self % trans_x_re ( ix )) ** 2 & - c1_ev * self % get_km_re ( ix , iy_ev , iz ) ** 2 & - c2_ev * self % get_km_re ( ix , iy_ev , iz ) * get_real ( km_a1_ev ) self % a_even_im ( i , j , k , 3 ) = & - ( get_imag ( self % kx ( ix )) & * self % trans_y_im ( iy_ev ) * self % trans_z_im ( iz )) ** 2 & - ( get_imag ( self % kz ( iz )) & * self % trans_y_im ( iy_ev ) * self % trans_x_im ( ix )) ** 2 & - c1_ev * self % get_km_im ( ix , iy_ev , iz ) ** 2 & - c2_ev * self % get_km_im ( ix , iy_ev , iz ) * get_imag ( km_a1_ev ) end do end do end do ! diagonal + 1 do k = 1 , self % nz_spec do j = 1 , self % ny_spec / 2 do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st iy_od = 2 * iy - 1 iy_ev = 2 * iy c1_od = a0 * a1 c2_od = a0 * a1 c1_ev = a0 * a1 c2_ev = a0 * a1 if ( iy == 1 ) then c1_od = 2 * a0 * a1 c2_od = 2 * a0 * a1 c1_ev = a0 * a1 - a1 * a1 c2_ev = a0 * a1 else if ( iy == self % ny_spec / 2 - 1 ) then c1_ev = a0 * a1 c2_ev = ( a0 + a1 ) * a1 else if ( iy == self % ny_spec / 2 ) then c1_ev = 0 ; c2_ev = 0 end if self % a_odd_re ( i , j , k , 4 ) = & c1_od * ( self % get_km_re ( ix , iy_od , iz ) & * self % get_km_re ( ix , iy_od + 2 , iz )) & + c2_od * self % get_km_re ( ix , iy_od + 2 , iz ) ** 2 self % a_odd_im ( i , j , k , 4 ) = & c1_od * ( self % get_km_im ( ix , iy_od , iz ) & * self % get_km_im ( ix , iy_od + 2 , iz )) & + c2_od * self % get_km_im ( ix , iy_od + 2 , iz ) ** 2 self % a_even_re ( i , j , k , 4 ) = & c1_ev * ( self % get_km_re ( ix , iy_ev , iz ) & * self % get_km_re ( ix , iy_ev + 2 , iz )) & + c2_ev * self % get_km_re ( ix , iy_ev + 2 , iz ) ** 2 self % a_even_im ( i , j , k , 4 ) = & c1_ev * ( self % get_km_im ( ix , iy_ev , iz ) & * self % get_km_im ( ix , iy_ev + 2 , iz )) & + c2_ev * self % get_km_im ( ix , iy_ev + 2 , iz ) ** 2 end do end do end do ! diagonal + 2 do k = 1 , self % nz_spec do j = 1 , self % ny_spec / 2 - 2 do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st iy_od = 2 * iy - 1 iy_ev = 2 * iy c1_od = a1 * a1 c1_ev = a1 * a1 if ( iy == 1 ) then c1_od = 2 * a1 * a1 end if self % a_odd_re ( i , j , k , 5 ) = & - ( c1_od * self % get_km_re ( ix , iy_od + 2 , iz ) & * self % get_km_re ( ix , iy_od + 4 , iz )) self % a_odd_im ( i , j , k , 5 ) = & - ( c1_od * self % get_km_im ( ix , iy_od + 2 , iz ) & * self % get_km_im ( ix , iy_od + 4 , iz )) self % a_even_re ( i , j , k , 5 ) = & - ( c1_ev * self % get_km_re ( ix , iy_ev + 2 , iz ) & * self % get_km_re ( ix , iy_ev + 4 , iz )) self % a_even_im ( i , j , k , 5 ) = & - ( c1_ev * self % get_km_im ( ix , iy_ev + 2 , iz ) & * self % get_km_im ( ix , iy_ev + 4 , iz )) end do end do end do ! diagonal - 1 do k = 1 , self % nz_spec do j = 2 , self % ny_spec / 2 do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st iy_od = 2 * iy - 1 iy_ev = 2 * iy c1_od = a0 * a1 c2_od = a0 * a1 c1_ev = a0 * a1 c2_ev = a0 * a1 if ( iy == 1 ) then c1_od = 0 ; c2_od = 0 ; c1_ev = 0 ; c2_ev = 0 else if ( iy == 2 ) then c1_ev = a0 * a1 c2_ev = ( a0 + a1 ) * a1 else if ( iy == self % ny_spec / 2 ) then c1_ev = ( a0 + a1 ) * a1 c2_ev = a0 * a1 end if self % a_odd_re ( i , j , k , 2 ) = & c1_od * ( self % get_km_re ( ix , iy_od , iz ) & * self % get_km_re ( ix , iy_od - 2 , iz )) & + c2_od * self % get_km_re ( ix , iy_od - 2 , iz ) ** 2 self % a_odd_im ( i , j , k , 2 ) = & c1_od * ( self % get_km_im ( ix , iy_od , iz ) & * self % get_km_im ( ix , iy_od - 2 , iz )) & + c2_od * self % get_km_im ( ix , iy_od - 2 , iz ) ** 2 self % a_even_re ( i , j , k , 2 ) = & c1_ev * ( self % get_km_re ( ix , iy_ev , iz ) & * self % get_km_re ( ix , iy_ev - 2 , iz )) & + c2_ev * self % get_km_re ( ix , iy_ev - 2 , iz ) ** 2 self % a_even_im ( i , j , k , 2 ) = & c1_ev * ( self % get_km_im ( ix , iy_ev , iz ) & * self % get_km_im ( ix , iy_ev - 2 , iz )) & + c2_ev * self % get_km_im ( ix , iy_ev - 2 , iz ) ** 2 end do end do end do ! diagonal - 2 do k = 1 , self % nz_spec do j = 3 , self % ny_spec / 2 do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iy = j + self % y_sp_st ; iz = k + self % z_sp_st iy_od = 2 * iy - 1 iy_ev = 2 * iy self % a_odd_re ( i , j , k , 1 ) = & - ( a1 * a1 * self % get_km_re ( ix , iy_od - 2 , iz ) & * self % get_km_re ( ix , iy_od - 4 , iz )) self % a_odd_im ( i , j , k , 1 ) = & - ( a1 * a1 * self % get_km_im ( ix , iy_od - 2 , iz ) & * self % get_km_im ( ix , iy_od - 4 , iz )) self % a_even_re ( i , j , k , 1 ) = & - ( a1 * a1 * self % get_km_re ( ix , iy_ev - 2 , iz ) & * self % get_km_re ( ix , iy_ev - 4 , iz )) self % a_even_im ( i , j , k , 1 ) = & - ( a1 * a1 * self % get_km_im ( ix , iy_ev - 2 , iz ) & * self % get_km_im ( ix , iy_ev - 4 , iz )) end do end do end do do k = 1 , self % nz_spec do i = 1 , self % nx_spec ix = i + self % x_sp_st ; iz = k + self % z_sp_st if ( get_real ( self % k2x ( ix )) < 1e-15 & . and . get_real ( self % k2z ( iz )) < 1e-15 ) then self % a_odd_re ( i , 1 , k , 3 ) = 1._dp self % a_odd_im ( i , 1 , k , 3 ) = 1._dp self % a_odd_re ( i , 1 , k , 4 ) = 0 self % a_odd_im ( i , 1 , k , 4 ) = 0 self % a_odd_re ( i , 1 , k , 5 ) = 0 self % a_odd_im ( i , 1 , k , 5 ) = 0 end if end do end do end if end subroutine stretching_matrix subroutine waves_set ( self , geo , xdirps , ydirps , zdirps ) !! Spectral equivalence constants !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none class ( poisson_fft_t ) :: self type ( geo_t ), intent ( in ) :: geo type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps integer :: i , j , k , ix , iy , iz real ( dp ) :: rlexs , rleys , rlezs , xtt , ytt , ztt , xt1 , yt1 , zt1 complex ( dp ) :: xt2 , yt2 , zt2 , xyzk call wave_numbers ( & self % ax , self % bx , self % kx , self % exs , self % k2x , & self % nx_glob , geo % L ( 1 ), geo % d ( 1 ), self % periodic_x , & xdirps % stagder_v2p % a , xdirps % stagder_v2p % b , xdirps % stagder_v2p % alpha & ) call wave_numbers ( & self % ay , self % by , self % ky , self % eys , self % k2y , & self % ny_glob , geo % L ( 2 ), geo % d ( 2 ), self % periodic_y , & ydirps % stagder_v2p % a , ydirps % stagder_v2p % b , ydirps % stagder_v2p % alpha & ) call wave_numbers ( & self % az , self % bz , self % kz , self % ezs , self % k2z , & self % nz_glob , geo % L ( 3 ), geo % d ( 3 ), self % periodic_z , & zdirps % stagder_v2p % a , zdirps % stagder_v2p % b , zdirps % stagder_v2p % alpha & ) ! Determine which case we're in and compute waves accordingly if ((. not . self % periodic_x ) . and . self % periodic_y . and . & self % periodic_z ) then ! ========================================================================= ! 100 case: Non-periodic X, Periodic Y, Periodic Z ! Uses TRANSPOSED indexing because data is transposed before FFT ! ========================================================================= do k = 1 , self % nz_spec do j = 1 , self % ny_spec ! This iterates over X (Dirichlet) after transpose do i = 1 , self % nx_spec ! This iterates over Y (periodic, R2C) after transpose ! After transpose: array is (ny, nx, nz), R2C gives (ny/2+1, nx, nz) ! So i indexes into Y direction, j indexes into X direction iy = i + self % y_sp_st ! Use for ky (first dim after transpose) ix = j + self % x_sp_st ! Use for kx (second dim after transpose) iz = k + self % z_sp_st rlexs = real ( self % exs ( ix ), kind = dp ) * geo % d ( 1 ) rleys = real ( self % eys ( iy ), kind = dp ) * geo % d ( 2 ) rlezs = real ( self % ezs ( iz ), kind = dp ) * geo % d ( 3 ) xtt = 2 * ( xdirps % interpl_v2p % a * cos ( rlexs * 0.5_dp ) & + xdirps % interpl_v2p % b * cos ( rlexs * 1.5_dp ) & + xdirps % interpl_v2p % c * cos ( rlexs * 2.5_dp ) & + xdirps % interpl_v2p % d * cos ( rlexs * 3.5_dp )) ytt = 2 * ( ydirps % interpl_v2p % a * cos ( rleys * 0.5_dp ) & + ydirps % interpl_v2p % b * cos ( rleys * 1.5_dp ) & + ydirps % interpl_v2p % c * cos ( rleys * 2.5_dp ) & + ydirps % interpl_v2p % d * cos ( rleys * 3.5_dp )) ztt = 2 * ( zdirps % interpl_v2p % a * cos ( rlezs * 0.5_dp ) & + zdirps % interpl_v2p % b * cos ( rlezs * 1.5_dp ) & + zdirps % interpl_v2p % c * cos ( rlezs * 2.5_dp ) & + zdirps % interpl_v2p % d * cos ( rlezs * 3.5_dp )) xt1 = 1._dp + 2 * xdirps % interpl_v2p % alpha * cos ( rlexs ) yt1 = 1._dp + 2 * ydirps % interpl_v2p % alpha * cos ( rleys ) zt1 = 1._dp + 2 * zdirps % interpl_v2p % alpha * cos ( rlezs ) xt2 = self % k2x ( ix ) * (( ytt / yt1 ) * ( ztt / zt1 )) ** 2 yt2 = self % k2y ( iy ) * (( xtt / xt1 ) * ( ztt / zt1 )) ** 2 zt2 = self % k2z ( iz ) * (( xtt / xt1 ) * ( ytt / yt1 )) ** 2 xyzk = xt2 + yt2 + zt2 self % waves ( i , j , k ) = xyzk end do end do end do else if ( self % periodic_z ) then ! ========================================================================= ! 000, 010, 110 cases: Periodic Z (standard indexing, no transpose) ! 000: Periodic X, Periodic Y, Periodic Z ! 010: Periodic X, Non-Periodic Y, Periodic Z ! 110: Non-Periodic X, Non-Periodic Y, Periodic Z ! ========================================================================= do k = 1 , self % nz_spec do j = 1 , self % ny_spec do i = 1 , self % nx_spec ix = i + self % x_sp_st iy = j + self % y_sp_st iz = k + self % z_sp_st rlexs = real ( self % exs ( ix ), kind = dp ) * geo % d ( 1 ) rleys = real ( self % eys ( iy ), kind = dp ) * geo % d ( 2 ) rlezs = real ( self % ezs ( iz ), kind = dp ) * geo % d ( 3 ) xtt = 2 * ( xdirps % interpl_v2p % a * cos ( rlexs * 0.5_dp ) & + xdirps % interpl_v2p % b * cos ( rlexs * 1.5_dp ) & + xdirps % interpl_v2p % c * cos ( rlexs * 2.5_dp ) & + xdirps % interpl_v2p % d * cos ( rlexs * 3.5_dp )) ytt = 2 * ( ydirps % interpl_v2p % a * cos ( rleys * 0.5_dp ) & + ydirps % interpl_v2p % b * cos ( rleys * 1.5_dp ) & + ydirps % interpl_v2p % c * cos ( rleys * 2.5_dp ) & + ydirps % interpl_v2p % d * cos ( rleys * 3.5_dp )) ztt = 2 * ( zdirps % interpl_v2p % a * cos ( rlezs * 0.5_dp ) & + zdirps % interpl_v2p % b * cos ( rlezs * 1.5_dp ) & + zdirps % interpl_v2p % c * cos ( rlezs * 2.5_dp ) & + zdirps % interpl_v2p % d * cos ( rlezs * 3.5_dp )) xt1 = 1._dp + 2 * xdirps % interpl_v2p % alpha * cos ( rlexs ) yt1 = 1._dp + 2 * ydirps % interpl_v2p % alpha * cos ( rleys ) zt1 = 1._dp + 2 * zdirps % interpl_v2p % alpha * cos ( rlezs ) xt2 = self % k2x ( ix ) * (( ytt / yt1 ) * ( ztt / zt1 )) ** 2 yt2 = self % k2y ( iy ) * (( xtt / xt1 ) * ( ztt / zt1 )) ** 2 zt2 = self % k2z ( iz ) * (( xtt / xt1 ) * ( ytt / yt1 )) ** 2 xyzk = xt2 + yt2 + zt2 self % waves ( i , j , k ) = xyzk end do end do end do else if (. not . ( self % periodic_x . and . self % periodic_y & . and . self % periodic_z )) then ! poisson 111 error stop 'No support for all non-periodic BCs yet!' else ! poisson 001, 011, 101 error stop 'FFT Poisson solver does not support specified BCs!' end if end subroutine waves_set subroutine wave_numbers ( a , b , k , e , k2 , n , L , d , periodic , c_a , c_b , c_alpha ) implicit none real ( dp ), dimension (:), intent ( out ) :: a , b complex ( dp ), dimension (:), intent ( out ) :: k , e , k2 integer , intent ( in ) :: n real ( dp ), intent ( in ) :: c_a , c_b , c_alpha , L , d logical , intent ( in ) :: periodic real ( dp ) :: w , wp integer :: i do i = 1 , n if ( periodic ) then a ( i ) = sin (( i - 1 ) * pi / n ) b ( i ) = cos (( i - 1 ) * pi / n ) else a ( i ) = sin (( i - 1 ) * pi / 2 / n ) b ( i ) = cos (( i - 1 ) * pi / 2 / n ) end if end do if ( periodic ) then do i = 1 , n / 2 + 1 w = 2 * pi * ( i - 1 ) / n wp = c_a * 2 * d * sin ( 0.5_dp * w ) + c_b * 2 * d * sin ( 1.5_dp * w ) wp = wp / ( 1._dp + 2 * c_alpha * cos ( w )) k ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( n * wp / L ) e ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( n * w / L ) k2 ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( n * wp / L ) ** 2 end do do i = n / 2 + 2 , n k ( i ) = k ( n - i + 2 ) e ( i ) = e ( n - i + 2 ) k2 ( i ) = k2 ( n - i + 2 ) end do else do i = 1 , n w = pi * ( i - 1 ) / n wp = c_a * 2 * d * sin ( 0.5_dp * w ) + c_b * 2 * d * sin ( 1.5_dp * w ) wp = wp / ( 1._dp + 2 * c_alpha * cos ( w )) k ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( n * wp / L ) e ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( n * w / L ) k2 ( i ) = cmplx ( 1._dp , 1._dp , kind = dp ) * ( n * wp / L ) ** 2 end do end if end subroutine wave_numbers real ( dp ) function get_km_re ( self , i , j , k ) result ( re ) implicit none class ( poisson_fft_t ) :: self integer , intent ( in ) :: i , j , k re = get_real ( self % get_km ( i , j , k )) end function get_km_re real ( dp ) function get_km_im ( self , i , j , k ) result ( re ) implicit none class ( poisson_fft_t ) :: self integer , intent ( in ) :: i , j , k re = get_imag ( self % get_km ( i , j , k )) end function get_km_im complex ( dp ) function get_km ( self , i , j , k ) result ( km ) implicit none class ( poisson_fft_t ) :: self integer , intent ( in ) :: i , j , k km = cmplx ( self % trans_x_re ( i ) * get_real ( self % ky ( j )) * self % trans_z_re ( k ), & self % trans_x_im ( i ) * get_imag ( self % ky ( j )) * self % trans_z_im ( k ), & kind = dp ) end function get_km real ( dp ) function get_real ( complx ) result ( re ) implicit none complex ( dp ), intent ( in ) :: complx re = real ( complx , kind = dp ) end function get_real real ( dp ) function get_imag ( complx ) result ( im ) implicit none complex ( dp ), intent ( in ) :: complx im = aimag ( complx ) end function get_imag end module m_poisson_fft","tags":"","url":"sourcefile/poisson_fft.f90.html"},{"title":"thomas.f90 – x3d2","text":"This file depends on sourcefile~~thomas.f90~~EfferentGraph sourcefile~thomas.f90 thomas.f90 sourcefile~common.f90 common.f90 sourcefile~thomas.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~thomas.f90~~AfferentGraph sourcefile~thomas.f90 thomas.f90 sourcefile~exec_thom.f90 exec_thom.f90 sourcefile~exec_thom.f90->sourcefile~thomas.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_kernels_thom use cudafor use m_common , only : dp implicit none contains attributes ( global ) subroutine der_univ_thom ( & du , u , n_tds , n_rhs , coeffs_s , coeffs_e , coeffs , & thom_f , thom_s , thom_w , strch & ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: du real ( dp ), device , intent ( in ), dimension (:, :, :) :: u integer , value , intent ( in ) :: n_tds , n_rhs real ( dp ), device , intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e real ( dp ), device , intent ( in ), dimension (:) :: coeffs real ( dp ), device , intent ( in ), dimension (:) :: thom_f , thom_s , thom_w , strch integer :: i , j , b real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 , temp_du i = threadIdx % x b = blockIdx % x ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) du ( i , 1 , b ) = coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) du ( i , 1 , b ) = du ( i , 1 , b ) du ( i , 2 , b ) = coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) du ( i , 2 , b ) = du ( i , 2 , b ) - du ( i , 1 , b ) * thom_s ( 2 ) du ( i , 3 , b ) = coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) du ( i , 3 , b ) = du ( i , 3 , b ) - du ( i , 2 , b ) * thom_s ( 3 ) du ( i , 4 , b ) = coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) du ( i , 4 , b ) = du ( i , 4 , b ) - du ( i , 3 , b ) * thom_s ( 4 ) do j = 5 , n_rhs - 4 temp_du = c_m4 * u ( i , j - 4 , b ) + c_m3 * u ( i , j - 3 , b ) & + c_m2 * u ( i , j - 2 , b ) + c_m1 * u ( i , j - 1 , b ) & + c_j * u ( i , j , b ) & + c_p1 * u ( i , j + 1 , b ) + c_p2 * u ( i , j + 2 , b ) & + c_p3 * u ( i , j + 3 , b ) + c_p4 * u ( i , j + 4 , b ) du ( i , j , b ) = temp_du - du ( i , j - 1 , b ) * thom_s ( j ) end do j = n_rhs - 3 du ( i , j , b ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) du ( i , j , b ) = du ( i , j , b ) - du ( i , j - 1 , b ) * thom_s ( j ) j = n_rhs - 2 du ( i , j , b ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) du ( i , j , b ) = du ( i , j , b ) - du ( i , j - 1 , b ) * thom_s ( j ) j = n_rhs - 1 du ( i , j , b ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) du ( i , j , b ) = du ( i , j , b ) - du ( i , j - 1 , b ) * thom_s ( j ) j = n_rhs du ( i , j , b ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 4 ) * u ( i , j , b ) du ( i , j , b ) = du ( i , j , b ) - du ( i , j - 1 , b ) * thom_s ( j ) ! Backward pass of the Thomas algorithm du ( i , n_tds , b ) = du ( i , n_tds , b ) * thom_w ( n_tds ) * strch ( n_tds ) do j = n_tds - 1 , 1 , - 1 ! du(j) = (du(j) - f*du(j+1)/strch(j))*w*strch(j) du ( i , j , b ) = ( du ( i , j , b ) * strch ( j ) - thom_f ( j ) * du ( i , j + 1 , b )) & * thom_w ( j ) end do end subroutine der_univ_thom attributes ( global ) subroutine der_univ_thom_per ( & du , u , n , coeffs , alpha , thom_f , thom_s , thom_w , thom_p , strch & ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: du real ( dp ), device , intent ( in ), dimension (:, :, :) :: u integer , value , intent ( in ) :: n real ( dp ), device , intent ( in ), dimension (:) :: coeffs real ( dp ), value , intent ( in ) :: alpha real ( dp ), device , intent ( in ), dimension (:) :: thom_f , thom_s , thom_w , & thom_p , strch integer :: i , j , b integer :: jm4 , jm3 , jm2 , jm1 , jp1 , jp2 , jp3 , jp4 real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 real ( dp ) :: temp_du , ss i = threadIdx % x b = blockIdx % x ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) do j = 1 , n jm4 = modulo ( j - 5 , n ) + 1 jm3 = modulo ( j - 4 , n ) + 1 jm2 = modulo ( j - 3 , n ) + 1 jm1 = modulo ( j - 2 , n ) + 1 jp1 = modulo ( j - n , n ) + 1 jp2 = modulo ( j - n + 1 , n ) + 1 jp3 = modulo ( j - n + 2 , n ) + 1 jp4 = modulo ( j - n + 3 , n ) + 1 temp_du = c_m4 * u ( i , jm4 , b ) + c_m3 * u ( i , jm3 , b ) & + c_m2 * u ( i , jm2 , b ) + c_m1 * u ( i , jm1 , b ) & + c_j * u ( i , j , b ) & + c_p1 * u ( i , jp1 , b ) + c_p2 * u ( i , jp2 , b ) & + c_p3 * u ( i , jp3 , b ) + c_p4 * u ( i , jp4 , b ) du ( i , j , b ) = temp_du - du ( i , jm1 , b ) * thom_s ( j ) end do ! Backward pass of the Thomas algorithm du ( i , n , b ) = du ( i , n , b ) * thom_w ( n ) do j = n - 1 , 1 , - 1 du ( i , j , b ) = ( du ( i , j , b ) - thom_f ( j ) * du ( i , j + 1 , b )) * thom_w ( j ) end do ! Periodic final pass ss = ( du ( i , 1 , b ) - alpha * du ( i , n , b )) & / ( 1._dp + thom_p ( 1 ) - alpha * thom_p ( n )) do j = 1 , n du ( i , j , b ) = ( du ( i , j , b ) - ss * thom_p ( j )) * strch ( j ) end do end subroutine der_univ_thom_per end module m_cuda_kernels_thom","tags":"","url":"sourcefile/thomas.f90.html"},{"title":"common.f90 – x3d2","text":"Files dependent on this one sourcefile~~common.f90~~AfferentGraph sourcefile~common.f90 common.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~allocator.f90~2->sourcefile~common.f90 sourcefile~allocator.f90~2->sourcefile~allocator.f90 sourcefile~allocator.f90~2->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~common.f90 sourcefile~backend.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~backend.f90->sourcefile~exec_dist.f90~2 sourcefile~backend.f90->sourcefile~field.f90 sourcefile~backend.f90->sourcefile~mesh.f90 sourcefile~ordering.f90 ordering.f90 sourcefile~backend.f90->sourcefile~ordering.f90 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~sendrecv.f90 sendrecv.f90 sourcefile~backend.f90->sourcefile~sendrecv.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90->sourcefile~tdsops.f90~2 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~common.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~distributed.f90~2 distributed.f90 sourcefile~backend.f90~3->sourcefile~distributed.f90~2 sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~backend.f90~3->sourcefile~field.f90 sourcefile~fieldops.f90 fieldops.f90 sourcefile~backend.f90~3->sourcefile~fieldops.f90 sourcefile~backend.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~reorder.f90 reorder.f90 sourcefile~backend.f90~3->sourcefile~reorder.f90 sourcefile~sendrecv.f90~2 sendrecv.f90 sourcefile~backend.f90~3->sourcefile~sendrecv.f90~2 sourcefile~tdsops.f90 tdsops.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~common.f90 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90->sourcefile~field.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~common.f90 sourcefile~channel.f90->sourcefile~allocator.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~config.f90 config.f90 sourcefile~channel.f90->sourcefile~config.f90 sourcefile~channel.f90->sourcefile~mesh.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~common.f90 sourcefile~cylinder.f90->sourcefile~allocator.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~config.f90 sourcefile~cylinder.f90->sourcefile~field.f90 sourcefile~cylinder.f90->sourcefile~mesh.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~distributed.f90 distributed.f90 sourcefile~distributed.f90->sourcefile~common.f90 sourcefile~distributed.f90~2->sourcefile~common.f90 sourcefile~exec_dist.f90->sourcefile~common.f90 sourcefile~exec_dist.f90->sourcefile~distributed.f90~2 sourcefile~exec_dist.f90->sourcefile~sendrecv.f90~2 sourcefile~exec_dist.f90->sourcefile~tdsops.f90 sourcefile~exec_dist.f90~2->sourcefile~common.f90 sourcefile~exec_dist.f90~2->sourcefile~distributed.f90 sourcefile~exec_dist.f90~2->sourcefile~sendrecv.f90 sourcefile~exec_dist.f90~2->sourcefile~tdsops.f90~2 sourcefile~exec_thom.f90 exec_thom.f90 sourcefile~exec_thom.f90->sourcefile~common.f90 sourcefile~exec_thom.f90->sourcefile~tdsops.f90 sourcefile~thomas.f90 thomas.f90 sourcefile~exec_thom.f90->sourcefile~thomas.f90 sourcefile~exec_thom.f90~2 exec_thom.f90 sourcefile~exec_thom.f90~2->sourcefile~common.f90 sourcefile~exec_thom.f90~2->sourcefile~tdsops.f90~2 sourcefile~thomas.f90~2 thomas.f90 sourcefile~exec_thom.f90~2->sourcefile~thomas.f90~2 sourcefile~field.f90->sourcefile~common.f90 sourcefile~fieldops.f90->sourcefile~common.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~common.f90 sourcefile~generic.f90->sourcefile~allocator.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~field.f90 sourcefile~generic.f90->sourcefile~mesh.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io.f90~2 io.f90 sourcefile~io.f90~2->sourcefile~common.f90 sourcefile~io.f90~2->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~ordering.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~common.f90 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~field.f90 sourcefile~poisson_fft.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~spectral_processing.f90~2 spectral_processing.f90 sourcefile~poisson_fft.f90~2->sourcefile~spectral_processing.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90~3->sourcefile~common.f90 sourcefile~poisson_fft.f90~3->sourcefile~field.f90 sourcefile~poisson_fft.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~spectral_processing.f90 spectral_processing.f90 sourcefile~poisson_fft.f90~3->sourcefile~spectral_processing.f90 sourcefile~poisson_fft.f90~3->sourcefile~tdsops.f90~2 sourcefile~reorder.f90->sourcefile~common.f90 sourcefile~sendrecv.f90->sourcefile~common.f90 sourcefile~sendrecv.f90~2->sourcefile~common.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~spectral_processing.f90->sourcefile~common.f90 sourcefile~spectral_processing.f90~2->sourcefile~common.f90 sourcefile~tdsops.f90->sourcefile~common.f90 sourcefile~tdsops.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~common.f90 sourcefile~tgv.f90->sourcefile~allocator.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~field.f90 sourcefile~tgv.f90->sourcefile~mesh.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~thomas.f90->sourcefile~common.f90 sourcefile~thomas.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~common.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~config.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~mesh.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~decomp_dummy.f90 decomp_dummy.f90 sourcefile~decomp_dummy.f90->sourcefile~mesh_content.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_common use mpi implicit none #ifdef SINGLE_PREC integer , parameter :: dp = kind ( 0.0e0 ) integer , parameter :: nbytes = 4 integer , parameter :: MPI_X3D2_DP = MPI_REAL logical , parameter :: is_sp = . true . #else integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter :: nbytes = 8 integer , parameter :: MPI_X3D2_DP = MPI_DOUBLE_PRECISION logical , parameter :: is_sp = . false . #endif integer , parameter :: sp = kind ( 0.0e0 ) integer , parameter :: i8 = selected_int_kind ( 18 ) real ( dp ), parameter :: pi = 4 * atan ( 1.0_dp ) integer , parameter :: RDR_X2Y = 12 , RDR_X2Z = 13 , RDR_Y2X = 21 , & RDR_Y2Z = 23 , RDR_Z2X = 31 , RDR_Z2Y = 32 , & RDR_C2X = 41 , RDR_C2Y = 42 , RDR_C2Z = 43 , & RDR_X2C = 14 , RDR_Y2C = 24 , RDR_Z2C = 34 integer , parameter :: DIR_X = 1 , DIR_Y = 2 , DIR_Z = 3 , DIR_C = 4 integer , parameter :: POISSON_SOLVER_FFT = 0 , POISSON_SOLVER_CG = 1 integer , parameter :: VERT = 0000 , & ! Vertex centered data CELL = 1110 , & ! Cell centered data X_FACE = 1100 , & ! Data on faces normal to X Y_FACE = 1010 , & ! Data on faces normal to Y Z_FACE = 0110 , & ! Data on faces normal to Z X_EDGE = 0010 , & ! Data on edges along X Y_EDGE = 0100 , & ! Data on edges along Y Z_EDGE = 1000 , & ! Data on edges along Z NULL_LOC = - 0001 ! The location of data isn't specified integer , parameter :: BC_PERIODIC = 0 , BC_NEUMANN = 1 , BC_DIRICHLET = 2 , & BC_HALO = - 1 integer , protected :: & rdr_map ( 4 , 4 ) = reshape ([ 0 , RDR_Y2X , RDR_Z2X , RDR_C2X , & RDR_X2Y , 0 , RDR_Z2Y , RDR_C2Y , & RDR_X2Z , RDR_Y2Z , 0 , RDR_C2Z , & RDR_X2C , RDR_Y2C , RDR_Z2C , 0 ], shape = [ 4 , 4 ]) contains pure subroutine get_dirs_from_rdr ( dir_from , dir_to , rdr_dir ) integer , intent ( out ) :: dir_from , dir_to integer , intent ( in ) :: rdr_dir integer , dimension ( 2 ) :: dirs dirs = findloc ( rdr_map , rdr_dir ) dir_from = dirs ( 1 ) dir_to = dirs ( 2 ) end subroutine pure integer function get_rdr_from_dirs ( dir_from , dir_to ) result ( rdr_dir ) !! Returns RDR_?2? value based on two direction inputs integer , intent ( in ) :: dir_from , dir_to rdr_dir = rdr_map ( dir_from , dir_to ) end function get_rdr_from_dirs function get_argument ( pos ) result ( arg ) integer , intent ( in ) :: pos character (:), allocatable :: arg character ( len = 200 ) :: temp integer :: stat call get_command_argument ( pos , temp , status = stat ) if ( stat > 0 ) then error stop 'Argument retrieval failed!' else if ( stat == - 1 ) then error stop 'Argument is truncated!' end if arg = trim ( temp ) end function get_argument integer function move_data_loc ( in_data_loc , dir , move ) result ( out_data_loc ) integer , intent ( in ) :: in_data_loc , dir , move out_data_loc = in_data_loc + move * ( 10 ** dir ) end function move_data_loc end module m_common","tags":"","url":"sourcefile/common.f90.html"},{"title":"io.f90 – x3d2","text":"This file depends on sourcefile~~io.f90~2~~EfferentGraph sourcefile~io.f90~2 io.f90 sourcefile~common.f90 common.f90 sourcefile~io.f90~2->sourcefile~common.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90~2->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_io_backend !! @brief Provides ADIOS2-specific implementation of the I/O backend interface !! !! @details This module contains the concrete backend implementation for ADIOS2 !! (ADaptive Input Output System v2) library. It acts as a translation layer !! converting generic I/O calls from the session interface into specific calls !! to the ADIOS2 API. !! !! The `adios2_reader_t` and `adios2_writer_t` types defined here extend the !! abstract base types from `m_io_base` and implement required procedures !! !! This backend leverages several key features of the underlying ADIOS2 library !! - engine abstraction - the same API can be used for different transport !! methods (e.g. BP4, BP5, HDF5) !! - Asynchronous I/O - by default ADIOS2 uses a deferred transport mode !! which can improve performance by overlapping computation and I/O !! - MPI integration - it is designed for large-scale paralle I/O and !! integrates with MPI, though serial operation is also supported !! !! @note This is an internal backend module and should never be used directly. !! All user interaction must go through `m_io_session`. use adios2 , only : adios2_adios , adios2_io , adios2_engine , & adios2_variable , adios2_attribute , & adios2_mode_sync , adios2_mode_write , & adios2_mode_deferred , adios2_mode_read , & adios2_step_mode_append , adios2_step_mode_read , & adios2_init , adios2_finalize , & adios2_declare_io , adios2_set_engine , & adios2_open , adios2_close , & adios2_begin_step , adios2_end_step , & adios2_define_variable , adios2_inquire_variable , & adios2_define_attribute , & adios2_set_selection , adios2_put , & adios2_get , adios2_remove_all_variables , & adios2_found , adios2_constant_dims , & adios2_type_dp , adios2_type_integer4 , adios2_type_real use mpi , only : MPI_COMM_NULL , MPI_Initialized , MPI_Comm_rank use m_common , only : dp , i8 , sp , is_sp use m_io_base , only : io_reader_t , io_writer_t , io_file_t , & io_mode_read , io_mode_write implicit none private public :: allocate_io_reader , allocate_io_writer public :: get_default_backend , IO_BACKEND_DUMMY , IO_BACKEND_ADIOS2 integer , parameter :: IO_BACKEND_DUMMY = 0 integer , parameter :: IO_BACKEND_ADIOS2 = 1 type , extends ( io_reader_t ) :: io_adios2_reader_t private type ( adios2_adios ) :: adios !! ADIOS2 global handler type ( adios2_io ) :: io_handle !! ADIOS2 IO object for managing I/O logical :: is_step_active = . false . !! Flag to track if a step is active integer :: comm = MPI_COMM_NULL !! MPI communicator contains procedure :: init => reader_init_adios2 procedure :: open => reader_open_adios2 procedure :: read_data_i8 => read_data_i8_adios2 procedure :: read_data_integer => read_data_integer_adios2 procedure :: read_data_real => read_data_real_adios2 procedure :: read_data_array_3d => read_data_array_3d_adios2 procedure :: finalise => finalise_reader_adios2 procedure , private :: handle_error => handle_error_reader end type io_adios2_reader_t type , extends ( io_writer_t ) :: io_adios2_writer_t private type ( adios2_adios ) :: adios !! ADIOS2 global handler type ( adios2_io ) :: io_handle !! ADIOS2 IO object for managing I/O logical :: is_step_active = . false . !! Flag to track if a step is active integer :: comm = MPI_COMM_NULL !! MPI communicator contains procedure :: init => writer_init_adios2 procedure :: open => writer_open_adios2 procedure :: write_data_i8 => write_data_i8_adios2 procedure :: write_data_integer => write_data_integer_adios2 procedure :: write_data_real => write_data_real_adios2 procedure :: write_data_array_3d => write_data_array_3d_adios2 procedure :: write_attribute_string => write_attribute_string_adios2 procedure :: write_attribute_array_1d_real => & write_attribute_array_1d_real_adios2 procedure :: finalise => finalise_writer_adios2 procedure , private :: handle_error => handle_error_writer end type io_adios2_writer_t type , extends ( io_file_t ) :: io_adios2_file_t private type ( adios2_engine ) :: engine !! ADIOS2 engine for data reading/writing logical :: is_step_active = . false . !! Flag to track if a step is active logical :: is_writer = . false . !! Flag to track if this is for writing contains procedure :: close => file_close_adios2 procedure :: begin_step => file_begin_step_adios2 procedure :: end_step => file_end_step_adios2 procedure , private :: handle_error => handle_error_file end type io_adios2_file_t contains subroutine allocate_io_reader ( reader ) class ( io_reader_t ), allocatable , intent ( out ) :: reader allocate ( io_adios2_reader_t :: reader ) end subroutine allocate_io_reader subroutine allocate_io_writer ( writer ) class ( io_writer_t ), allocatable , intent ( out ) :: writer allocate ( io_adios2_writer_t :: writer ) end subroutine allocate_io_writer function get_default_backend () result ( backend ) integer :: backend backend = IO_BACKEND_ADIOS2 end function get_default_backend function get_adios2_vartype ( use_sp ) result ( vartype ) logical , intent ( in ) :: use_sp !! flag for single precision output integer :: vartype if ( use_sp ) then vartype = adios2_type_real else if ( is_sp ) then vartype = adios2_type_real else vartype = adios2_type_dp end if end function get_adios2_vartype subroutine reader_init_adios2 ( self , comm , name ) class ( io_adios2_reader_t ), intent ( inout ) :: self integer , intent ( in ) :: comm character ( len =* ), intent ( in ) :: name logical :: is_mpi_initialised integer :: ierr , comm_rank if ( comm == MPI_COMM_NULL ) & call self % handle_error ( 1 , \"Invalid MPI communicator\" ) call MPI_Initialized ( is_mpi_initialised , ierr ) if (. not . is_mpi_initialised ) & call self % handle_error ( 1 , \"MPI must be initialised & &before calling ADIOS2 init\" ) self % comm = comm call MPI_Comm_rank ( self % comm , comm_rank , ierr ) call self % handle_error ( ierr , \"Failed to get MPI rank\" ) ! create adios handler passing communicator call adios2_init ( self % adios , comm , ierr ) call self % handle_error ( ierr , \"Failed to initialise ADIOS2\" ) ! declare IO process configuration inside adios call adios2_declare_io ( self % io_handle , self % adios , name , ierr ) call self % handle_error ( ierr , \"Failed to declare ADIOS2 IO object\" ) ! hardcode engine type to BP5 call adios2_set_engine ( self % io_handle , \"BP5\" , ierr ) if (. not . self % io_handle % valid ) & call self % handle_error ( 1 , \"Failed to create ADIOS2 IO object\" ) end subroutine reader_init_adios2 function reader_open_adios2 ( self , filename , mode , comm ) result ( file_handle ) class ( io_adios2_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: mode integer , intent ( in ) :: comm class ( io_file_t ), allocatable :: file_handle type ( io_adios2_file_t ) :: temp_handle integer :: ierr , use_comm use_comm = comm if (. not . self % io_handle % valid ) & call self % handle_error ( 1 , \"ADIOS2 IO object is not valid\" ) call adios2_open ( & temp_handle % engine , self % io_handle , filename , & adios2_mode_read , use_comm , ierr ) call self % handle_error ( ierr , \"Failed to open ADIOS2 engine for reading\" ) temp_handle % is_writer = . false . file_handle = temp_handle end function reader_open_adios2 subroutine read_data_i8_adios2 ( self , variable_name , value , file_handle ) class ( io_adios2_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer ( i8 ), intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle type ( adios2_variable ) :: var integer :: ierr select type ( file_handle ) type is ( io_adios2_file_t ) call adios2_inquire_variable ( var , self % io_handle , variable_name , ierr ) if ( ierr == adios2_found ) then call adios2_get ( file_handle % engine , var , value , adios2_mode_sync , ierr ) call self % handle_error ( ierr , \"Failed to read variable \" // variable_name ) else call self % handle_error ( 1 , \"Variable \" & // trim ( variable_name ) // \" not found in file\" ) end if class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine read_data_i8_adios2 subroutine read_data_integer_adios2 ( self , variable_name , value , file_handle ) class ( io_adios2_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer , intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle type ( adios2_variable ) :: var integer :: ierr select type ( file_handle ) type is ( io_adios2_file_t ) call adios2_inquire_variable ( var , self % io_handle , variable_name , ierr ) if ( ierr == adios2_found ) then call adios2_get ( file_handle % engine , var , value , adios2_mode_sync , ierr ) call self % handle_error ( ierr , \"Failed to read variable \" // variable_name ) else call self % handle_error ( 1 , \"Variable \" & // trim ( variable_name ) // \" not found in file\" ) end if class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine read_data_integer_adios2 subroutine read_data_real_adios2 ( self , variable_name , value , file_handle ) class ( io_adios2_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle type ( adios2_variable ) :: var integer :: ierr select type ( file_handle ) type is ( io_adios2_file_t ) ! retrieve a variable handler within current io handler call adios2_inquire_variable ( var , self % io_handle , variable_name , ierr ) if ( ierr == adios2_found ) then call adios2_get ( file_handle % engine , var , value , adios2_mode_sync , ierr ) call self % handle_error ( ierr , \"Failed to read variable \" // variable_name ) else call self % handle_error ( 1 , \"Variable \" & // trim ( variable_name ) // \" not found in file\" ) end if class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine read_data_real_adios2 subroutine read_data_array_3d_adios2 ( & self , variable_name , array , file_handle , & shape_dims , start_dims , count_dims & ) class ( io_adios2_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( inout ) :: array (:, :, :) class ( io_file_t ), intent ( inout ) :: file_handle integer ( i8 ), intent ( in ), optional :: shape_dims ( 3 ) integer ( i8 ), intent ( in ), optional :: start_dims ( 3 ) integer ( i8 ), intent ( in ), optional :: count_dims ( 3 ) type ( adios2_variable ) :: var integer :: ierr integer ( i8 ) :: local_start ( 3 ), local_count ( 3 ) select type ( file_handle ) type is ( io_adios2_file_t ) call adios2_inquire_variable ( var , self % io_handle , variable_name , ierr ) if ( ierr == adios2_found ) then if ( present ( start_dims )) then local_start = start_dims else local_start = 0_i8 end if if ( present ( count_dims )) then local_count = count_dims else local_count = int ( shape ( array ), i8 ) end if ! apply selection only when explicitly requested (partial array reads) if ( present ( start_dims ) . or . present ( count_dims )) then call adios2_set_selection ( var , 3 , local_start , local_count , ierr ) call self % handle_error ( ierr , & \"Failed to set selection for variable \" & // trim ( variable_name )) end if call adios2_get ( file_handle % engine , var , array , adios2_mode_sync , ierr ) call self % handle_error ( ierr , & \"Failed to read variable \" // trim ( variable_name )) else call self % handle_error ( 1 , \"Variable \" & // trim ( variable_name ) // \" not found in file\" ) end if class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine read_data_array_3d_adios2 subroutine finalise_reader_adios2 ( self ) class ( io_adios2_reader_t ), intent ( inout ) :: self integer :: ierr if ( self % adios % valid ) then call adios2_finalize ( self % adios , ierr ) call self % handle_error ( ierr , \"Failed to finalise ADIOS2\" ) end if end subroutine finalise_reader_adios2 subroutine writer_init_adios2 ( self , comm , name ) class ( io_adios2_writer_t ), intent ( inout ) :: self integer , intent ( in ) :: comm character ( len =* ), intent ( in ) :: name logical :: is_mpi_initialised integer :: ierr , comm_rank if ( comm == MPI_COMM_NULL ) & call self % handle_error ( 1 , \"Invalid MPI communicator\" ) call MPI_Initialized ( is_mpi_initialised , ierr ) if (. not . is_mpi_initialised ) & call self % handle_error ( 1 , \"MPI must be initialised & &before calling ADIOS2 init\" ) self % comm = comm call MPI_Comm_rank ( self % comm , comm_rank , ierr ) call self % handle_error ( ierr , \"Failed to get MPI rank\" ) ! create adios handler passing communicator call adios2_init ( self % adios , comm , ierr ) call self % handle_error ( ierr , \"Failed to initialise ADIOS2\" ) ! declare IO process configuration inside adios call adios2_declare_io ( self % io_handle , self % adios , name , ierr ) call self % handle_error ( ierr , \"Failed to declare ADIOS2 IO object\" ) ! hardcode engine type to BP5 call adios2_set_engine ( self % io_handle , \"BP5\" , ierr ) if (. not . self % io_handle % valid ) & call self % handle_error ( 1 , \"Failed to create ADIOS2 IO object\" ) end subroutine writer_init_adios2 function writer_open_adios2 ( self , filename , mode , comm ) result ( file_handle ) class ( io_adios2_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: mode integer , intent ( in ) :: comm class ( io_file_t ), allocatable :: file_handle type ( io_adios2_file_t ) :: temp_handle integer :: ierr , use_comm use_comm = comm if (. not . self % io_handle % valid ) & call self % handle_error ( 1 , \"ADIOS2 IO object is not valid\" ) ! if opening in write mode, we are starting a new independent dataset ! remove all old variables from the IO object if ( mode == io_mode_write ) then call adios2_remove_all_variables ( self % io_handle , ierr ) call self % handle_error ( ierr , \"Failed to remove old ADIOS2 variables & &before open\" ) end if call adios2_open ( & temp_handle % engine , self % io_handle , filename , & adios2_mode_write , use_comm , ierr ) call self % handle_error ( ierr , \"Failed to open ADIOS2 engine for writing\" ) temp_handle % is_writer = . true . file_handle = temp_handle end function writer_open_adios2 subroutine write_data_i8_adios2 ( self , variable_name , value , file_handle ) class ( io_adios2_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer ( i8 ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle type ( adios2_variable ) :: var integer :: ierr select type ( file_handle ) type is ( io_adios2_file_t ) call adios2_inquire_variable ( var , self % io_handle , variable_name , ierr ) if ( ierr /= adios2_found ) then ! Use integer4 type for i8 compatibility - ADIOS2 will handle the conversion call adios2_define_variable ( & var , self % io_handle , variable_name , adios2_type_integer4 , ierr ) call self % handle_error ( ierr , & \"Error defining ADIOS2 scalar i8 variable\" ) end if call adios2_put ( & file_handle % engine , var , value , adios2_mode_deferred , ierr ) call self % handle_error ( ierr , \"Error writing ADIOS2 scalar i8 data\" ) class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine write_data_i8_adios2 subroutine write_data_integer_adios2 ( self , variable_name , value , file_handle ) class ( io_adios2_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer , intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle type ( adios2_variable ) :: var integer :: ierr select type ( file_handle ) type is ( io_adios2_file_t ) call adios2_inquire_variable ( var , self % io_handle , variable_name , ierr ) if ( ierr /= adios2_found ) then call adios2_define_variable ( & var , self % io_handle , variable_name , adios2_type_integer4 , ierr ) call self % handle_error ( ierr , & \"Error defining ADIOS2 scalar integer variable\" ) end if call adios2_put ( & file_handle % engine , var , value , adios2_mode_deferred , ierr ) call self % handle_error ( ierr , \"Error writing ADIOS2 scalar integer data\" ) class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine write_data_integer_adios2 subroutine write_data_real_adios2 ( self , variable_name , value , file_handle , & use_sp ) class ( io_adios2_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle logical , intent ( in ), optional :: use_sp type ( adios2_variable ) :: var integer :: ierr integer :: vartype real ( sp ) :: value_sp logical :: convert_to_sp ! Determine if we should convert to single precision convert_to_sp = . false . if ( present ( use_sp )) convert_to_sp = use_sp ! Get the appropriate ADIOS2 variable type vartype = get_adios2_vartype ( convert_to_sp ) select type ( file_handle ) type is ( io_adios2_file_t ) call adios2_inquire_variable ( var , self % io_handle , variable_name , ierr ) if ( ierr /= adios2_found ) then call adios2_define_variable ( var , self % io_handle , variable_name , & vartype , ierr ) call self % handle_error ( ierr , \"Error defining ADIOS2 & &scalar real variable\" ) end if ! Write data - convert to single precision if needed if ( convert_to_sp . and . . not . is_sp ) then value_sp = real ( value , sp ) ! Use sync mode to ensure data is copied before value_sp goes out of scope call adios2_put ( & file_handle % engine , var , value_sp , adios2_mode_sync , ierr ) call self % handle_error ( ierr , \"Error writing ADIOS2 scalar & &single precision real data\" ) else call adios2_put ( & file_handle % engine , var , value , adios2_mode_deferred , ierr ) call self % handle_error ( ierr , \"Error writing ADIOS2 scalar real data\" ) end if class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine write_data_real_adios2 subroutine write_data_array_3d_adios2 ( & self , variable_name , array , file_handle , & shape_dims , start_dims , count_dims , use_sp & ) class ( io_adios2_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( in ) :: array (:, :, :) class ( io_file_t ), intent ( inout ) :: file_handle integer ( i8 ), intent ( in ) :: shape_dims ( 3 ) integer ( i8 ), intent ( in ) :: start_dims ( 3 ) integer ( i8 ), intent ( in ) :: count_dims ( 3 ) logical , intent ( in ), optional :: use_sp type ( adios2_variable ) :: var integer :: ierr integer :: vartype real ( sp ), allocatable :: array_sp (:, :, :) logical :: convert_to_sp ! Determine if we should convert to single precision convert_to_sp = . false . if ( present ( use_sp )) convert_to_sp = use_sp ! Get the appropriate ADIOS2 variable type vartype = get_adios2_vartype ( convert_to_sp ) select type ( file_handle ) type is ( io_adios2_file_t ) call adios2_inquire_variable ( var , self % io_handle , variable_name , ierr ) if ( ierr /= adios2_found ) then call adios2_define_variable ( var , self % io_handle , variable_name , & vartype , 3 , shape_dims , & start_dims , count_dims , & adios2_constant_dims , ierr ) call self % handle_error ( ierr , \"Error defining ADIOS2 & &3D array real variable\" ) end if ! Write data - convert to single precision if needed if ( convert_to_sp . and . . not . is_sp ) then ! Allocate temporary single precision buffer allocate ( array_sp ( size ( array , 1 ), size ( array , 2 ), size ( array , 3 ))) array_sp = real ( array , sp ) ! Use sync mode to ensure data is copied before buffer is deallocated call adios2_put ( & file_handle % engine , var , array_sp , adios2_mode_sync , ierr ) deallocate ( array_sp ) call self % handle_error ( ierr , \"Error writing ADIOS2 3D array & &single precision real data\" ) else call adios2_put ( & file_handle % engine , var , array , adios2_mode_deferred , ierr ) call self % handle_error ( ierr , \"Error writing ADIOS2 & &3D array real data\" ) end if class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine write_data_array_3d_adios2 subroutine write_attribute_string_adios2 ( & self , attribute_name , value , file_handle & ) class ( io_adios2_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: attribute_name character ( len =* ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle type ( adios2_attribute ) :: attr integer :: ierr select type ( file_handle ) type is ( io_adios2_file_t ) call adios2_define_attribute ( & attr , self % io_handle , attribute_name , value , ierr ) call self % handle_error ( ierr , & \"Error defining ADIOS2 string attribute \" & // trim ( attribute_name )) class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine write_attribute_string_adios2 subroutine write_attribute_array_1d_real_adios2 ( & self , attribute_name , values , file_handle & ) class ( io_adios2_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: attribute_name real ( dp ), intent ( in ) :: values (:) class ( io_file_t ), intent ( inout ) :: file_handle type ( adios2_attribute ) :: attr integer :: ierr integer :: num_elements select type ( file_handle ) type is ( io_adios2_file_t ) num_elements = size ( values ) call adios2_define_attribute ( & attr , self % io_handle , attribute_name , values , num_elements , ierr ) call self % handle_error ( & ierr , \"Error defining ADIOS2 real & &array attribute \" & // trim ( attribute_name )) class default call self % handle_error ( 1 , \"Invalid file handle type for ADIOS2\" ) end select end subroutine write_attribute_array_1d_real_adios2 subroutine finalise_writer_adios2 ( self ) class ( io_adios2_writer_t ), intent ( inout ) :: self integer :: ierr if ( self % adios % valid ) then call adios2_finalize ( self % adios , ierr ) call self % handle_error ( ierr , \"Failed to finalise ADIOS2\" ) end if end subroutine finalise_writer_adios2 subroutine file_close_adios2 ( self ) class ( io_adios2_file_t ), intent ( inout ) :: self integer :: ierr if ( self % is_step_active ) call self % end_step () if ( self % engine % valid ) then call adios2_close ( self % engine , ierr ) call self % handle_error ( ierr , \"Failed to close ADIOS2 engine\" ) end if end subroutine file_close_adios2 subroutine file_begin_step_adios2 ( self ) class ( io_adios2_file_t ), intent ( inout ) :: self integer :: ierr if ( self % is_step_active ) return if ( self % is_writer ) then call adios2_begin_step ( self % engine , adios2_step_mode_append , ierr ) call self % handle_error ( ierr , \"Error beginning ADIOS2 step for writing\" ) else call adios2_begin_step ( self % engine , adios2_step_mode_read , ierr ) call self % handle_error ( ierr , \"Error beginning ADIOS2 step for reading\" ) end if self % is_step_active = . true . end subroutine file_begin_step_adios2 subroutine file_end_step_adios2 ( self ) class ( io_adios2_file_t ), intent ( inout ) :: self integer :: ierr if (. not . self % is_step_active ) return call adios2_end_step ( self % engine , ierr ) call self % handle_error ( ierr , \"Failed to end ADIOS2 step\" ) self % is_step_active = . false . end subroutine file_end_step_adios2 subroutine handle_error_reader ( self , ierr , message ) class ( io_adios2_reader_t ), intent ( inout ) :: self integer , intent ( in ) :: ierr character ( len =* ), intent ( in ) :: message if ( ierr /= 0 ) then print * , \"ADIOS2 Reader Error: \" , message print * , \"Error code: \" , ierr error stop end if end subroutine handle_error_reader subroutine handle_error_writer ( self , ierr , message ) class ( io_adios2_writer_t ), intent ( inout ) :: self integer , intent ( in ) :: ierr character ( len =* ), intent ( in ) :: message if ( ierr /= 0 ) then print * , \"ADIOS2 Writer Error: \" , message print * , \"Error code: \" , ierr error stop end if end subroutine handle_error_writer subroutine handle_error_file ( self , ierr , message ) class ( io_adios2_file_t ), intent ( inout ) :: self integer , intent ( in ) :: ierr character ( len =* ), intent ( in ) :: message if ( ierr /= 0 ) then print * , \"ADIOS2 File Error: \" , message print * , \"Error code: \" , ierr error stop end if end subroutine handle_error_file end module m_io_backend","tags":"","url":"sourcefile/io.f90~2.html"},{"title":"snapshot_manager.f90 – x3d2","text":"This file depends on sourcefile~~snapshot_manager.f90~~EfferentGraph sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~common.f90 common.f90 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~config.f90 config.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~field.f90 field.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~io.f90 io.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~solver.f90 solver.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~snapshot_manager.f90~~AfferentGraph sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_snapshot_manager !! @brief Manages the creation of simulation snapshots for post-processing !! and visualisation. !! !! @details This module is responsible for periodically writing simulation !! data to files intended for analysis and visualisation !! Unlike checkpoints, which are always full-resolution for exact restarts, !! snapshots can be strided to reduce file size. use mpi , only : MPI_COMM_WORLD , MPI_Comm_rank use m_common , only : dp , i8 , DIR_C , VERT , get_argument use m_field , only : field_t use m_solver , only : solver_t use m_io_session , only : writer_session_t use m_config , only : checkpoint_config_t use m_io_field_utils , only : field_buffer_map_t , field_ptr_t , & setup_field_arrays , cleanup_field_arrays , & stride_data_to_buffer , get_output_dimensions , & prepare_field_buffers , cleanup_field_buffers , & write_single_field_to_buffer implicit none private public :: snapshot_manager_t type :: snapshot_manager_t type ( checkpoint_config_t ) :: config integer , dimension ( 3 ) :: output_stride = [ 1 , 1 , 1 ] type ( field_buffer_map_t ), allocatable :: field_buffers (:) integer ( i8 ), dimension ( 3 ) :: last_shape_dims = 0 integer , dimension ( 3 ) :: last_stride_factors = 0 integer ( i8 ), dimension ( 3 ) :: last_output_shape = 0 character ( len = 4096 ) :: vtk_xml = \"\" logical :: is_snapshot_file_open = . false . type ( writer_session_t ) :: snapshot_writer logical :: convert_to_sp = . false . !! Flag for single precision snapshots contains procedure :: init procedure :: handle_snapshot_step procedure :: finalise procedure , private :: write_snapshot procedure , private :: write_fields procedure , private :: cleanup_output_buffers procedure , private :: generate_vtk_xml procedure , private :: open_snapshot_file procedure , private :: close_snapshot_file end type snapshot_manager_t contains subroutine init ( self , comm ) !! Initialise snapshot manager class ( snapshot_manager_t ), intent ( inout ) :: self integer , intent ( in ) :: comm self % config = checkpoint_config_t () call self % config % read ( nml_file = get_argument ( 1 )) if ( self % config % snapshot_freq > 0 ) then call configure_output ( self , comm ) end if end subroutine init subroutine configure_output ( self , comm ) !! Configure snapshot output settings use m_io_backend , only : get_default_backend , IO_BACKEND_DUMMY class ( snapshot_manager_t ), intent ( inout ) :: self integer , intent ( in ) :: comm integer :: myrank , ierr call MPI_Comm_rank ( comm , myrank , ierr ) self % output_stride = self % config % output_stride self % convert_to_sp = self % config % snapshot_sp if ( myrank == 0 . and . get_default_backend () /= IO_BACKEND_DUMMY ) then print * , 'Snapshot frequency: ' , self % config % snapshot_freq print * , 'Snapshot prefix: ' , trim ( self % config % snapshot_prefix ) print * , 'Output stride: ' , self % output_stride print * , 'Snapshot precision: ' , merge ( 'Single' , 'Double' , & self % config % snapshot_sp ) end if end subroutine configure_output subroutine handle_snapshot_step ( self , solver , timestep , comm ) !! Handle snapshot writing at a given timestep class ( snapshot_manager_t ), intent ( inout ) :: self class ( solver_t ), intent ( in ) :: solver integer , intent ( in ) :: timestep integer , intent ( in ), optional :: comm integer :: comm_to_use comm_to_use = MPI_COMM_WORLD if ( present ( comm )) comm_to_use = comm call self % write_snapshot ( solver , timestep , comm_to_use ) end subroutine handle_snapshot_step subroutine write_snapshot ( self , solver , timestep , comm ) !! Write a snapshot file for visualisation !! Uses a persistent file that stays open across multiple snapshots !! Each snapshot is written as a separate timestep in the file class ( snapshot_manager_t ), intent ( inout ) :: self class ( solver_t ), intent ( in ) :: solver integer , intent ( in ) :: timestep integer , intent ( in ) :: comm character ( len =* ), parameter :: field_names ( * ) = [ \"u\" , \"v\" , \"w\" ] integer :: myrank , ierr character ( len = 256 ) :: filename integer ( i8 ), dimension ( 3 ) :: output_shape_dims integer , dimension ( 3 ) :: global_dims , output_dims type ( field_ptr_t ), allocatable :: field_ptrs (:), host_fields (:) real ( dp ), dimension ( 3 ) :: origin , original_spacing , output_spacing real ( dp ) :: simulation_time logical :: snapshot_uses_stride = . true . integer :: i if ( self % config % snapshot_freq <= 0 ) return if ( mod ( timestep , self % config % snapshot_freq ) /= 0 ) return call MPI_Comm_rank ( comm , myrank , ierr ) write ( filename , '(A,A)' ) trim ( self % config % snapshot_prefix ), '.bp' ! Open snapshot file on first call (check for existence) if (. not . self % is_snapshot_file_open ) then call self % open_snapshot_file ( filename , comm ) else ! For subsequent snapshots, begin a new step call self % snapshot_writer % begin_step () end if global_dims = solver % mesh % get_global_dims ( VERT ) origin = solver % mesh % get_coordinates ( 1 , 1 , 1 ) original_spacing = solver % mesh % geo % d if ( snapshot_uses_stride ) then output_spacing = original_spacing * real ( self % output_stride , dp ) do i = 1 , size ( global_dims ) output_dims ( i ) = ( global_dims ( i ) + self % output_stride ( i ) - 1 ) / & self % output_stride ( i ) end do else output_spacing = original_spacing output_dims = global_dims end if output_shape_dims = int ( output_dims , i8 ) call self % generate_vtk_xml ( & output_shape_dims , field_names , origin , output_spacing & ) simulation_time = timestep * solver % dt if ( self % snapshot_writer % is_session_functional () . and . myrank == 0 ) then print * , 'Writing snapshot for time =' , simulation_time , & ' iteration =' , timestep end if ! Write VTK XML attributes for ParaView compatibility (only on first step) if ( timestep == self % config % snapshot_freq . and . myrank == 0 ) then call self % snapshot_writer % write_attribute ( \"vtk.xml\" , self % vtk_xml ) end if call self % snapshot_writer % write_data ( \"time\" , real ( simulation_time , dp )) call setup_field_arrays ( solver , field_names , field_ptrs , host_fields ) call self % write_fields ( & field_names , host_fields , & solver , self % snapshot_writer , solver % u % data_loc & ) call self % snapshot_writer % end_step () call cleanup_field_arrays ( solver , field_ptrs , host_fields ) end subroutine write_snapshot subroutine generate_vtk_xml ( self , dims , fields , origin , spacing ) !! Generate VTK XML string for ImageData format for ParaView's ADIOS2VTXReader class ( snapshot_manager_t ), intent ( inout ) :: self integer ( i8 ), dimension ( 3 ), intent ( in ) :: dims character ( len =* ), dimension (:), intent ( in ) :: fields real ( dp ), dimension ( 3 ), intent ( in ) :: origin , spacing character ( len = 4096 ) :: xml character ( len = 96 ) :: extent_str , origin_str , spacing_str integer :: i ! VTK uses (x,y,z) order, extent defines grid size from 0 to N-1 write ( extent_str , '(A,I0,A,I0,A,I0,A,I0,A,I0,A,I0,A)' ) & '0 ' , dims ( 3 ) - 1 , ' 0 ' , dims ( 2 ) - 1 , ' 0 ' , dims ( 1 ) - 1 write ( origin_str , '(G0, 1X, G0, 1X, G0)' ) origin write ( spacing_str , '(G0, 1X, G0, 1X, G0)' ) spacing xml = '<?xml version=\"1.0\"?>' // new_line ( 'a' ) // & '<VTKFile type=\"ImageData\" version=\"0.1\">' // new_line ( 'a' ) // & '  <ImageData WholeExtent=\" ' // trim ( adjustl ( extent_str )) // '\" ' & // 'Origin=\"' // trim ( adjustl ( origin_str )) // '\" ' // & 'Spacing=\"' // trim ( adjustl ( spacing_str )) // '\">' // new_line ( 'a' ) // & '    <Piece Extent=\"' // trim ( adjustl ( extent_str )) // '\">' & // new_line ( 'a' ) // '      <PointData>' // new_line ( 'a' ) do i = 1 , size ( fields ) xml = trim ( xml ) // '      <DataArray Name=\"' // trim ( fields ( i )) // '\">' // & trim ( fields ( i )) // '</DataArray>' // new_line ( 'a' ) end do xml = trim ( xml ) // '        <DataArray Name=\"TIME\">time</DataArray>' & // new_line ( 'a' ) xml = trim ( xml ) // '      </PointData>' // new_line ( 'a' ) // & '    </Piece>' // new_line ( 'a' ) // & '  </ImageData>' // new_line ( 'a' ) // & '</VTKFile>' self % vtk_xml = xml end subroutine generate_vtk_xml subroutine write_fields ( & self , field_names , host_fields , solver , writer_session , data_loc & ) !! Write field data with striding for snapshots class ( snapshot_manager_t ), intent ( inout ) :: self character ( len =* ), dimension (:), intent ( in ) :: field_names class ( field_ptr_t ), dimension (:), target , intent ( in ) :: host_fields class ( solver_t ), intent ( in ) :: solver type ( writer_session_t ), intent ( inout ) :: writer_session integer , intent ( in ) :: data_loc integer :: i_field integer ( i8 ), dimension ( 3 ) :: output_start , output_count integer , dimension ( 3 ) :: output_dims_local ! Prepare buffers with striding for snapshots call prepare_field_buffers ( & solver , self % output_stride , field_names , data_loc , & self % field_buffers , self % last_shape_dims , self % last_stride_factors , & self % last_output_shape & ) ! Calculate output dimensions for writing call get_output_dimensions ( & int ( solver % mesh % get_global_dims ( data_loc ), i8 ), & int ( solver % mesh % par % n_offset , i8 ), & int ( solver % mesh % get_dims ( data_loc ), i8 ), & self % output_stride , & self % last_output_shape , output_start , output_count , & output_dims_local , & self % last_shape_dims , self % last_stride_factors , & self % last_output_shape & ) do i_field = 1 , size ( field_names ) call write_single_field_to_buffer ( & trim ( field_names ( i_field )), host_fields ( i_field )% ptr , & solver , self % output_stride , data_loc , & self % field_buffers , self % last_shape_dims , self % last_stride_factors , & self % last_output_shape & ) call writer_session % write_data ( & trim ( field_names ( i_field )), & self % field_buffers ( i_field )% buffer , & self % last_output_shape , & output_start , output_count , & self % convert_to_sp ) end do end subroutine write_fields subroutine cleanup_output_buffers ( self ) !! Clean up dynamic field buffers class ( snapshot_manager_t ), intent ( inout ) :: self call cleanup_field_buffers ( self % field_buffers ) end subroutine cleanup_output_buffers subroutine finalise ( self ) !! Clean up snapshot manager class ( snapshot_manager_t ), intent ( inout ) :: self call self % cleanup_output_buffers () call self % close_snapshot_file () end subroutine finalise subroutine open_snapshot_file ( self , filename , comm ) !! Open a persistent snapshot file !! ADIOS2 handles both creating new files and appending to existing ones class ( snapshot_manager_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: comm logical :: file_exists integer :: myrank , ierr call MPI_Comm_rank ( comm , myrank , ierr ) if ( myrank == 0 ) then inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then print * , 'Appending to existing snapshot file: ' , trim ( filename ) else print * , 'Creating new snapshot file: ' , trim ( filename ) end if end if call self % snapshot_writer % open ( filename , comm ) self % is_snapshot_file_open = . true . end subroutine open_snapshot_file subroutine close_snapshot_file ( self ) !! Close the persistent snapshot file class ( snapshot_manager_t ), intent ( inout ) :: self if ( self % is_snapshot_file_open ) then call self % snapshot_writer % close () self % is_snapshot_file_open = . false . end if end subroutine close_snapshot_file end module m_snapshot_manager","tags":"","url":"sourcefile/snapshot_manager.f90.html"},{"title":"mesh.f90 – x3d2","text":"This file depends on sourcefile~~mesh.f90~~EfferentGraph sourcefile~mesh.f90 mesh.f90 sourcefile~common.f90 common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~field.f90 field.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mesh.f90~~AfferentGraph sourcefile~mesh.f90 mesh.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~mesh.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~mesh.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~mesh.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~mesh.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~mesh.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~mesh.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~mesh.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_mesh use iso_fortran_env , only : stderr => error_unit use mpi use m_common , only : dp , DIR_X , DIR_Y , DIR_Z , DIR_C , & CELL , VERT , X_FACE , Y_FACE , Z_FACE , & X_EDGE , Y_EDGE , Z_EDGE , & BC_PERIODIC , BC_NEUMANN , BC_DIRICHLET , BC_HALO use m_field , only : field_t use m_mesh_content implicit none ! The mesh class stores all the information about the global and local (due to domain decomposition) mesh ! It also includes getter functions to access some of its parameters type :: mesh_t type ( geo_t ), allocatable :: geo ! object containing geometry information class ( grid_t ), allocatable :: grid ! object containing grid information class ( par_t ), allocatable :: par ! object containing parallel domain decomposition information contains procedure :: get_dims procedure :: get_global_dims procedure :: get_n_dir procedure :: get_n_phi generic :: get_n => get_n_dir , get_n_phi procedure :: get_coordinates end type mesh_t interface mesh_t module procedure mesh_init end interface mesh_t contains function mesh_init ( dims_global , nproc_dir , L_global , BC_x , BC_y , BC_z , & stretching , beta , use_2decomp ) result ( mesh ) use m_decomp , only : is_avail_2decomp , decomposition_2decomp !! Completely initialise the mesh object. !! Upon initialisation the mesh object can be read-only and shouldn't be edited !! Takes as argument global information about the mesh like its length, number of cells and decomposition in each direction integer , dimension ( 3 ), intent ( in ) :: dims_global integer , dimension ( 3 ), intent ( in ) :: nproc_dir ! Number of proc in each direction real ( dp ), dimension ( 3 ), intent ( in ) :: L_global character ( len =* ), dimension ( 2 ), intent ( in ) :: BC_x , BC_y , BC_z character ( len =* ), dimension ( 3 ), optional , intent ( in ) :: stretching real ( dp ), dimension ( 3 ), optional , intent ( in ) :: beta logical , optional , intent ( in ) :: use_2decomp class ( mesh_t ), allocatable :: mesh character ( len = 20 ), dimension ( 3 , 2 ) :: BC_all logical :: is_first_domain , is_last_domain integer :: dir , j integer :: ierr allocate ( mesh ) allocate ( mesh % geo ) allocate ( mesh % grid ) allocate ( mesh % par ) BC_all ( 1 , 1 ) = BC_x ( 1 ); BC_all ( 1 , 2 ) = BC_x ( 2 ) BC_all ( 2 , 1 ) = BC_y ( 1 ); BC_all ( 2 , 2 ) = BC_y ( 2 ) BC_all ( 3 , 1 ) = BC_z ( 1 ); BC_all ( 3 , 2 ) = BC_z ( 2 ) do dir = 1 , 3 do j = 1 , 2 select case ( trim ( BC_all ( dir , j ))) case ( 'periodic' ) mesh % grid % BCs_global ( dir , j ) = BC_PERIODIC case ( 'neumann' ) mesh % grid % BCs_global ( dir , j ) = BC_NEUMANN case ( 'dirichlet' ) mesh % grid % BCs_global ( dir , j ) = BC_DIRICHLET case default error stop 'Unknown BC' end select end do end do do dir = 1 , 3 if ( any ( mesh % grid % BCs_global ( dir , :) == BC_PERIODIC ) . and . & (. not . all ( mesh % grid % BCs_global ( dir , :) == BC_PERIODIC ))) then error stop 'BCs are incompatible: in a direction make sure to have & &either both sides periodic or none.' end if mesh % grid % periodic_BC ( dir ) = all ( mesh % grid % BCs_global ( dir , :) & == BC_PERIODIC ) end do ! Set global vertex dims mesh % grid % global_vert_dims (:) = dims_global ! Set global cell dims do dir = 1 , 3 if ( mesh % grid % periodic_BC ( dir )) then mesh % grid % global_cell_dims ( dir ) = mesh % grid % global_vert_dims ( dir ) else mesh % grid % global_cell_dims ( dir ) = mesh % grid % global_vert_dims ( dir ) - 1 end if end do ! Parallel domain decomposition mesh % par % nproc_dir (:) = nproc_dir mesh % par % nproc = product ( nproc_dir (:)) call MPI_Comm_rank ( MPI_COMM_WORLD , mesh % par % nrank , ierr ) call MPI_Comm_size ( MPI_COMM_WORLD , mesh % par % nproc , ierr ) ! Either use 2decomp or the generic decomposition if ( present ( use_2decomp )) then if ( is_avail_2decomp () . and . use_2decomp ) then call decomposition_2decomp ( mesh % grid , mesh % par ) else call decomposition_generic ( mesh % grid , mesh % par ) end if else call decomposition_generic ( mesh % grid , mesh % par ) end if ! Set subdomain BCs do dir = 1 , 3 is_first_domain = mesh % par % nrank_dir ( dir ) == 0 is_last_domain = mesh % par % nrank_dir ( dir ) + 1 == mesh % par % nproc_dir ( dir ) ! subdomain-subdomain boundaries are identical to periodic BCs if ( is_first_domain . and . is_last_domain ) then mesh % grid % BCs ( dir , 1 ) = mesh % grid % BCs_global ( dir , 1 ) mesh % grid % BCs ( dir , 2 ) = mesh % grid % BCs_global ( dir , 2 ) else if ( is_first_domain ) then mesh % grid % BCs ( dir , 1 ) = mesh % grid % BCs_global ( dir , 1 ) mesh % grid % BCs ( dir , 2 ) = BC_HALO else if ( is_last_domain ) then mesh % grid % BCs ( dir , 1 ) = BC_HALO mesh % grid % BCs ( dir , 2 ) = mesh % grid % BCs_global ( dir , 2 ) else mesh % grid % BCs ( dir , :) = BC_HALO end if end do ! Geometry mesh % geo % L = L_global mesh % geo % d = mesh % geo % L / mesh % grid % global_cell_dims if ( present ( stretching )) then mesh % geo % stretching = stretching else mesh % geo % stretching (:) = 'uniform' end if if ( present ( beta )) then mesh % geo % beta = beta else mesh % geo % beta (:) = 1 end if call mesh % geo % obtain_coordinates ( & mesh % grid % vert_dims , mesh % grid % cell_dims , mesh % par % n_offset & ) end function mesh_init subroutine decomposition_generic ( grid , par ) ! Generic decomposition used when 2decomp isn't used use m_mesh_content , only : par_t , grid_t class ( grid_t ), intent ( inout ) :: grid class ( par_t ), intent ( inout ) :: par integer , allocatable , dimension (:, :, :) :: global_ranks integer :: i , nproc_x , nproc_y , nproc_z if ( par % is_root ()) then print * , \"Domain decomposition by x3d2 (generic)\" end if ! Number of processes on a direction basis nproc_x = par % nproc_dir ( 1 ) nproc_y = par % nproc_dir ( 2 ) nproc_z = par % nproc_dir ( 3 ) ! Define number of cells and vertices in each direction grid % vert_dims = grid % global_vert_dims / par % nproc_dir ! A 3D array corresponding to each region in the global domain allocate ( global_ranks ( nproc_x , nproc_y , nproc_z )) ! set the corresponding global rank for each sub-domain global_ranks = reshape ([( i , i = 0 , par % nproc - 1 )], & shape = [ nproc_x , nproc_y , nproc_z ]) call par % compute_rank_pos_from_global ( global_ranks ) call grid % copy_vert2cell_dims ( par ) par % n_offset (:) = grid % vert_dims (:) * par % nrank_dir (:) end subroutine pure function get_dims ( self , data_loc ) result ( dims ) !! Getter for local domain dimensions class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: data_loc integer , dimension ( 3 ) :: dims dims = get_dims_dataloc ( data_loc , self % grid % vert_dims , self % grid % cell_dims ) end function pure function get_global_dims ( self , data_loc ) result ( dims ) !! Getter for local domain dimensions class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: data_loc integer , dimension ( 3 ) :: dims dims = get_dims_dataloc ( data_loc , self % grid % global_vert_dims , & self % grid % global_cell_dims ) end function pure function get_dims_dataloc ( data_loc , vert_dims , cell_dims ) result ( dims ) !! Getter for domain dimensions integer , intent ( in ) :: data_loc integer , dimension ( 3 ), intent ( in ) :: vert_dims , cell_dims integer , dimension ( 3 ) :: dims select case ( data_loc ) case ( VERT ) dims = vert_dims case ( CELL ) dims = cell_dims case ( X_FACE ) dims ( 1 ) = vert_dims ( 1 ) dims ( 2 : 3 ) = cell_dims ( 2 : 3 ) case ( Y_FACE ) dims ( 1 ) = cell_dims ( 1 ) dims ( 2 ) = vert_dims ( 2 ) dims ( 3 ) = cell_dims ( 3 ) case ( Z_FACE ) dims ( 1 : 2 ) = cell_dims ( 1 : 2 ) dims ( 3 ) = vert_dims ( 3 ) case ( X_EDGE ) dims ( 1 ) = cell_dims ( 1 ) dims ( 2 : 3 ) = vert_dims ( 2 : 3 ) case ( Y_EDGE ) dims ( 1 ) = vert_dims ( 1 ) dims ( 2 ) = cell_dims ( 2 ) dims ( 3 ) = vert_dims ( 3 ) case ( Z_EDGE ) dims ( 1 : 2 ) = vert_dims ( 1 : 2 ) dims ( 3 ) = cell_dims ( 3 ) case default error stop \"Unknown location in get_dims_dataloc\" end select end function get_dims_dataloc pure function get_n_phi ( self , phi ) result ( n ) !! Getter for the main dimension of field phi class ( mesh_t ), intent ( in ) :: self class ( field_t ), intent ( in ) :: phi integer :: n n = self % get_n ( phi % dir , phi % data_loc ) end function pure function get_n_dir ( self , dir , data_loc ) result ( n ) !! Getter for the main dimension a field oriented along `dir` with data on `data_loc` class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: dir integer , intent ( in ) :: data_loc integer :: n , n_cell , n_vert n_cell = self % grid % cell_dims ( dir ) n_vert = self % grid % vert_dims ( dir ) ! default to n_vert n = n_vert select case ( data_loc ) case ( CELL ) n = n_cell case ( VERT ) n = n_vert case ( X_FACE ) if ( dir /= DIR_X ) then n = n_cell end if case ( Y_FACE ) if ( dir /= DIR_Y ) then n = n_cell end if case ( Z_FACE ) if ( dir /= DIR_Z ) then n = n_cell end if case ( X_EDGE ) if ( dir == DIR_X ) then n = n_cell end if case ( Y_EDGE ) if ( dir == DIR_Y ) then n = n_cell end if case ( Z_EDGE ) if ( dir == DIR_Z ) then n = n_cell end if case default error stop \"Unknown direction in get_n_dir\" end select end function get_n_dir pure function get_coordinates ( self , i , j , k , data_loc_op ) result ( coords ) !! Get the coordinates of a vertex with i, j, k local cartesian indices !! Avoid calling this in hot loops class ( mesh_t ), intent ( in ) :: self integer , intent ( in ) :: i , j , k integer , optional , intent ( in ) :: data_loc_op integer :: data_loc real ( dp ), dimension ( 3 ) :: coords if ( present ( data_loc_op )) then data_loc = data_loc_op else data_loc = VERT end if select case ( data_loc ) case ( VERT ) coords ( 1 ) = self % geo % vert_coords ( i , 1 ) coords ( 2 ) = self % geo % vert_coords ( j , 2 ) coords ( 3 ) = self % geo % vert_coords ( k , 3 ) case ( CELL ) coords ( 1 ) = self % geo % midp_coords ( i , 1 ) coords ( 2 ) = self % geo % midp_coords ( j , 2 ) coords ( 3 ) = self % geo % midp_coords ( k , 3 ) case ( X_FACE ) coords ( 1 ) = self % geo % vert_coords ( i , 1 ) coords ( 2 ) = self % geo % midp_coords ( j , 2 ) coords ( 3 ) = self % geo % midp_coords ( k , 3 ) case ( Y_FACE ) coords ( 1 ) = self % geo % midp_coords ( i , 1 ) coords ( 2 ) = self % geo % vert_coords ( j , 2 ) coords ( 3 ) = self % geo % midp_coords ( k , 3 ) case ( Z_FACE ) coords ( 1 ) = self % geo % midp_coords ( i , 1 ) coords ( 2 ) = self % geo % midp_coords ( j , 2 ) coords ( 3 ) = self % geo % vert_coords ( k , 3 ) case ( X_EDGE ) coords ( 1 ) = self % geo % midp_coords ( i , 1 ) coords ( 2 ) = self % geo % vert_coords ( j , 2 ) coords ( 3 ) = self % geo % vert_coords ( k , 3 ) case ( Y_EDGE ) coords ( 1 ) = self % geo % vert_coords ( i , 1 ) coords ( 2 ) = self % geo % midp_coords ( j , 2 ) coords ( 3 ) = self % geo % vert_coords ( k , 3 ) case ( Z_EDGE ) coords ( 1 ) = self % geo % vert_coords ( i , 1 ) coords ( 2 ) = self % geo % vert_coords ( j , 2 ) coords ( 3 ) = self % geo % midp_coords ( k , 3 ) case default error stop \"Unknown data_loc in get_coordinates\" end select end function end module m_mesh","tags":"","url":"sourcefile/mesh.f90.html"},{"title":"distributed.f90 – x3d2","text":"This file depends on sourcefile~~distributed.f90~~EfferentGraph sourcefile~distributed.f90 distributed.f90 sourcefile~common.f90 common.f90 sourcefile~distributed.f90->sourcefile~common.f90 sourcefile~common.f90~2 common.f90 sourcefile~distributed.f90->sourcefile~common.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~distributed.f90~~AfferentGraph sourcefile~distributed.f90 distributed.f90 sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~exec_dist.f90~2->sourcefile~distributed.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~exec_dist.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_omp_kernels_dist use omp_lib use m_common , only : dp use m_omp_common , only : SZ implicit none contains subroutine der_univ_dist ( & du , send_u_s , send_u_e , u , u_s , u_e , & n_tds , n_rhs , coeffs_s , coeffs_e , coeffs , ffr , fbc , faf & ) implicit none ! Arguments real ( dp ), intent ( out ), dimension (:, :) :: du , send_u_s , send_u_e real ( dp ), intent ( in ), dimension (:, :) :: u , u_s , u_e integer , intent ( in ) :: n_tds , n_rhs real ( dp ), intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e ! start/end real ( dp ), intent ( in ), dimension (:) :: coeffs real ( dp ), intent ( in ), dimension (:) :: ffr , fbc , faf ! Local variables integer :: i , j real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 , & alpha , last_r ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) last_r = ffr ( 1 ) !$omp simd do i = 1 , SZ du ( i , 1 ) = coeffs_s ( 1 , 1 ) * u_s ( i , 1 ) & + coeffs_s ( 2 , 1 ) * u_s ( i , 2 ) & + coeffs_s ( 3 , 1 ) * u_s ( i , 3 ) & + coeffs_s ( 4 , 1 ) * u_s ( i , 4 ) & + coeffs_s ( 5 , 1 ) * u ( i , 1 ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 ) du ( i , 1 ) = du ( i , 1 ) * faf ( 1 ) du ( i , 2 ) = coeffs_s ( 1 , 2 ) * u_s ( i , 2 ) & + coeffs_s ( 2 , 2 ) * u_s ( i , 3 ) & + coeffs_s ( 3 , 2 ) * u_s ( i , 4 ) & + coeffs_s ( 4 , 2 ) * u ( i , 1 ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 ) du ( i , 2 ) = du ( i , 2 ) * faf ( 2 ) du ( i , 3 ) = coeffs_s ( 1 , 3 ) * u_s ( i , 3 ) & + coeffs_s ( 2 , 3 ) * u_s ( i , 4 ) & + coeffs_s ( 3 , 3 ) * u ( i , 1 ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 ) du ( i , 3 ) = ffr ( 3 ) * ( du ( i , 3 ) - faf ( 3 ) * du ( i , 2 )) du ( i , 4 ) = coeffs_s ( 1 , 4 ) * u_s ( i , 4 ) & + coeffs_s ( 2 , 4 ) * u ( i , 1 ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 ) du ( i , 4 ) = ffr ( 4 ) * ( du ( i , 4 ) - faf ( 4 ) * du ( i , 3 )) end do !$omp end simd ! alpha is always the same in the bulk region for us alpha = faf ( 5 ) do j = 5 , n_rhs - 4 !$omp simd do i = 1 , SZ du ( i , j ) = c_m4 * u ( i , j - 4 ) + c_m3 * u ( i , j - 3 ) & + c_m2 * u ( i , j - 2 ) + c_m1 * u ( i , j - 1 ) & + c_j * u ( i , j ) & + c_p1 * u ( i , j + 1 ) + c_p2 * u ( i , j + 2 ) & + c_p3 * u ( i , j + 3 ) + c_p4 * u ( i , j + 4 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - alpha * du ( i , j - 1 )) end do !$omp end simd end do !$omp simd do i = 1 , SZ j = n_rhs - 3 du ( i , j ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 1 ) * u ( i , j ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 ) & + coeffs_e ( 9 , 1 ) * u_e ( i , 1 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n_rhs - 2 du ( i , j ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 2 ) * u ( i , j ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 ) & + coeffs_e ( 8 , 2 ) * u_e ( i , 1 ) & + coeffs_e ( 9 , 2 ) * u_e ( i , 2 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n_rhs - 1 du ( i , j ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 3 ) * u ( i , j ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 3 ) * u_e ( i , 1 ) & + coeffs_e ( 8 , 3 ) * u_e ( i , 2 ) & + coeffs_e ( 9 , 3 ) * u_e ( i , 3 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) j = n_rhs du ( i , j ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 4 ) * u ( i , j ) & + coeffs_e ( 6 , 4 ) * u_e ( i , 1 ) & + coeffs_e ( 7 , 4 ) * u_e ( i , 2 ) & + coeffs_e ( 8 , 4 ) * u_e ( i , 3 ) & + coeffs_e ( 9 , 4 ) * u_e ( i , 4 ) du ( i , j ) = ffr ( j ) * ( du ( i , j ) - faf ( j ) * du ( i , j - 1 )) end do !$omp end simd !$omp simd do i = 1 , SZ send_u_e ( i , 1 ) = du ( i , n_tds ) end do !$omp end simd ! Backward pass of the hybrid algorithm do j = n_tds - 2 , 2 , - 1 !$omp simd do i = 1 , SZ du ( i , j ) = du ( i , j ) - fbc ( j ) * du ( i , j + 1 ) end do !$omp end simd end do !$omp simd do i = 1 , SZ du ( i , 1 ) = last_r * ( du ( i , 1 ) - fbc ( 1 ) * du ( i , 2 )) send_u_s ( i , 1 ) = du ( i , 1 ) end do !$omp end simd end subroutine der_univ_dist subroutine der_univ_subs ( du , recv_u_s , recv_u_e , n , dist_sa , dist_sc , strch ) implicit none ! Arguments real ( dp ), intent ( out ), dimension (:, :) :: du real ( dp ), intent ( in ), dimension (:, :) :: recv_u_s , recv_u_e real ( dp ), intent ( in ), dimension (:) :: dist_sa , dist_sc , strch integer , intent ( in ) :: n ! Local variables integer :: i , j !, b real ( dp ) :: ur , bl , recp real ( dp ), dimension ( SZ ) :: du_s , du_e !$omp simd do i = 1 , SZ ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' bl = dist_sa ( 1 ) ur = dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s ( i ) = recp * ( du ( i , 1 ) - bl * recv_u_s ( i , 1 )) ! End ! At the end we have the 'ur', and assume 'bl' bl = dist_sc ( n ) ur = dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e ( i ) = recp * ( du ( i , n ) - ur * recv_u_e ( i , 1 )) end do !$omp end simd !$omp simd do i = 1 , SZ du ( i , 1 ) = du_s ( i ) * strch ( 1 ) end do !$omp end simd do j = 2 , n - 1 !$omp simd do i = 1 , SZ du ( i , j ) = ( du ( i , j ) - dist_sa ( j ) * du_s ( i ) - dist_sc ( j ) * du_e ( i )) & * strch ( j ) end do !$omp end simd end do !$omp simd do i = 1 , SZ du ( i , n ) = du_e ( i ) * strch ( n ) end do !$omp end simd end subroutine der_univ_subs subroutine der_univ_fused_subs ( & rhs_du , dud , d2u , v , & du_recv_s , du_recv_e , dud_recv_s , dud_recv_e , d2u_recv_s , d2u_recv_e , & nu , n , du_dist_sa , du_dist_sc , du_strch , & dud_dist_sa , dud_dist_sc , dud_strch , & d2u_dist_sa , d2u_dist_sc , d2u_strch , d2u_strch_cor & ) implicit none ! Arguments real ( dp ), intent ( inout ), dimension (:, :) :: rhs_du real ( dp ), intent ( in ), dimension (:, :) :: dud , d2u , v real ( dp ), intent ( in ), dimension (:, :) :: du_recv_s , du_recv_e real ( dp ), intent ( in ), dimension (:, :) :: dud_recv_s , dud_recv_e real ( dp ), intent ( in ), dimension (:, :) :: d2u_recv_s , d2u_recv_e real ( dp ), intent ( in ), dimension (:) :: du_dist_sa , du_dist_sc , du_strch real ( dp ), intent ( in ), dimension (:) :: dud_dist_sa , dud_dist_sc , dud_strch real ( dp ), intent ( in ), dimension (:) :: d2u_dist_sa , d2u_dist_sc , d2u_strch real ( dp ), intent ( in ), dimension (:) :: d2u_strch_cor real ( dp ), intent ( in ) :: nu integer , intent ( in ) :: n ! Local variables integer :: i , j real ( dp ) :: ur , bl , recp real ( dp ), dimension ( SZ ) :: du_s , du_e , dud_s , dud_e , d2u_s , d2u_e , & temp_du , temp_dud , temp_d2u !$omp simd do i = 1 , SZ ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' bl = du_dist_sa ( 1 ) ur = du_dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s ( i ) = recp * ( rhs_du ( i , 1 ) - bl * du_recv_s ( i , 1 )) bl = dud_dist_sa ( 1 ) ur = dud_dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) dud_s ( i ) = recp * ( dud ( i , 1 ) - bl * dud_recv_s ( i , 1 )) bl = d2u_dist_sa ( 1 ) ur = d2u_dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) d2u_s ( i ) = recp * ( d2u ( i , 1 ) - bl * d2u_recv_s ( i , 1 )) ! End ! At the end we have the 'ur', and assume 'bl' bl = du_dist_sc ( n ) ur = du_dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e ( i ) = recp * ( rhs_du ( i , n ) - ur * du_recv_e ( i , 1 )) bl = dud_dist_sc ( n ) ur = dud_dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) dud_e ( i ) = recp * ( dud ( i , n ) - ur * dud_recv_e ( i , 1 )) bl = d2u_dist_sc ( n ) ur = d2u_dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) d2u_e ( i ) = recp * ( d2u ( i , n ) - ur * d2u_recv_e ( i , 1 )) end do !$omp end simd !$omp simd do i = 1 , SZ rhs_du ( i , 1 ) = - 0.5_dp * ( v ( i , 1 ) * du_s ( i ) * du_strch ( 1 ) & + dud_s ( i ) * dud_strch ( 1 )) & + nu * ( d2u_s ( i ) * d2u_strch ( 1 ) & + du_s ( i ) * du_strch ( 1 ) * d2u_strch_cor ( 1 )) end do !$omp end simd do j = 2 , n - 1 !$omp simd do i = 1 , SZ temp_du ( i ) = du_strch ( j ) * ( rhs_du ( i , j ) - du_dist_sa ( j ) * du_s ( i ) & - du_dist_sc ( j ) * du_e ( i )) temp_dud ( i ) = dud_strch ( j ) * ( dud ( i , j ) - dud_dist_sa ( j ) * dud_s ( i ) & - dud_dist_sc ( j ) * dud_e ( i )) temp_d2u ( i ) = d2u_strch ( j ) * ( d2u ( i , j ) - d2u_dist_sa ( j ) * d2u_s ( i ) & - d2u_dist_sc ( j ) * d2u_e ( i )) & + temp_du ( i ) * d2u_strch_cor ( j ) rhs_du ( i , j ) = - 0.5_dp * ( v ( i , j ) * temp_du ( i ) + temp_dud ( i )) & + nu * temp_d2u ( i ) end do !$omp end simd end do !$omp simd do i = 1 , SZ rhs_du ( i , n ) = - 0.5_dp * ( v ( i , n ) * du_e ( i ) * du_strch ( n ) & + dud_e ( i ) * dud_strch ( n )) & + nu * ( d2u_e ( i ) * d2u_strch ( n ) & + du_e ( i ) * du_strch ( n ) * d2u_strch_cor ( n )) end do !$omp end simd end subroutine der_univ_fused_subs end module m_omp_kernels_dist","tags":"","url":"sourcefile/distributed.f90.html"},{"title":"channel.f90 – x3d2","text":"This file depends on sourcefile~~channel.f90~~EfferentGraph sourcefile~channel.f90 channel.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~channel.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~common.f90 common.f90 sourcefile~channel.f90->sourcefile~common.f90 sourcefile~config.f90 config.f90 sourcefile~channel.f90->sourcefile~config.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~channel.f90->sourcefile~mesh.f90 sourcefile~solver.f90 solver.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90->sourcefile~common.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~base_case.f90->sourcefile~field.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~channel.f90~~AfferentGraph sourcefile~channel.f90 channel.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_case_channel use iso_fortran_env , only : stderr => error_unit use mpi use m_allocator , only : allocator_t , field_t use m_base_backend , only : base_backend_t use m_base_case , only : base_case_t use m_common , only : dp , MPI_X3D2_DP , get_argument , DIR_C , VERT , CELL , Y_FACE use m_config , only : channel_config_t use m_mesh , only : mesh_t use m_solver , only : init implicit none type , extends ( base_case_t ) :: case_channel_t type ( channel_config_t ) :: channel_cfg contains procedure :: boundary_conditions => boundary_conditions_channel procedure :: initial_conditions => initial_conditions_channel procedure :: forcings => forcings_channel procedure :: pre_correction => pre_correction_channel procedure :: postprocess => postprocess_channel end type case_channel_t interface case_channel_t module procedure case_channel_init end interface case_channel_t contains function case_channel_init ( backend , mesh , host_allocator ) result ( flow_case ) implicit none class ( base_backend_t ), target , intent ( inout ) :: backend type ( mesh_t ), target , intent ( inout ) :: mesh type ( allocator_t ), target , intent ( inout ) :: host_allocator type ( case_channel_t ) :: flow_case call flow_case % channel_cfg % read ( nml_file = get_argument ( 1 )) call flow_case % case_init ( backend , mesh , host_allocator ) end function case_channel_init subroutine boundary_conditions_channel ( self ) implicit none class ( case_channel_t ) :: self real ( dp ) :: can , ub integer :: ierr ub = self % solver % backend % field_volume_integral ( self % solver % u ) ub = ub / ( product ( self % solver % mesh % get_global_dims ( CELL ))) call MPI_Allreduce ( MPI_IN_PLACE , ub , 1 , MPI_X3D2_DP , & MPI_SUM , MPI_COMM_WORLD , ierr ) can = 2._dp / 3._dp - ub call self % solver % backend % field_shift ( self % solver % u , can ) end subroutine boundary_conditions_channel subroutine initial_conditions_channel ( self ) implicit none class ( case_channel_t ) :: self class ( field_t ), pointer :: u_init , v_init , w_init integer :: i , j , k , dims ( 3 ) real ( dp ) :: xloc ( 3 ), y , noise , um dims = self % solver % mesh % get_dims ( VERT ) u_init => self % solver % host_allocator % get_block ( DIR_C ) v_init => self % solver % host_allocator % get_block ( DIR_C ) w_init => self % solver % host_allocator % get_block ( DIR_C ) call random_number ( u_init % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 ))) call random_number ( v_init % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 ))) call random_number ( w_init % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 ))) noise = self % channel_cfg % noise do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) do i = 1 , dims ( 1 ) xloc = self % solver % mesh % get_coordinates ( i , j , k ) y = xloc ( 2 ) - self % solver % mesh % geo % L ( 2 ) / 2._dp um = exp ( - 0.2_dp * y * y ) u_init % data ( i , j , k ) = 1._dp - y * y & + noise * um * ( 2 * u_init % data ( i , j , k ) - 1._dp ) v_init % data ( i , j , k ) = noise * um * ( 2 * v_init % data ( i , j , k ) - 1._dp ) w_init % data ( i , j , k ) = noise * um * ( 2 * w_init % data ( i , j , k ) - 1._dp ) end do end do end do u_init % data (:, 1 , :) = 0 v_init % data (:, 1 , :) = 0 w_init % data (:, 1 , :) = 0 u_init % data (:, dims ( 2 ), :) = 0 v_init % data (:, dims ( 2 ), :) = 0 w_init % data (:, dims ( 2 ), :) = 0 call self % solver % backend % set_field_data ( self % solver % u , u_init % data ) call self % solver % backend % set_field_data ( self % solver % v , v_init % data ) call self % solver % backend % set_field_data ( self % solver % w , w_init % data ) call self % solver % host_allocator % release_block ( u_init ) call self % solver % host_allocator % release_block ( v_init ) call self % solver % host_allocator % release_block ( w_init ) call self % solver % u % set_data_loc ( VERT ) call self % solver % v % set_data_loc ( VERT ) call self % solver % w % set_data_loc ( VERT ) end subroutine initial_conditions_channel subroutine forcings_channel ( self , du , dv , dw , iter ) implicit none class ( case_channel_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw integer , intent ( in ) :: iter real ( dp ) :: rot if ( self % channel_cfg % rotation . and . iter < self % channel_cfg % n_rotate ) then rot = self % channel_cfg % omega_rot call self % solver % backend % vecadd ( - rot , self % solver % v , 1._dp , du ) call self % solver % backend % vecadd ( rot , self % solver % u , 1._dp , dv ) end if end subroutine forcings_channel subroutine pre_correction_channel ( self , u , v , w ) implicit none class ( case_channel_t ) :: self class ( field_t ), intent ( inout ) :: u , v , w call self % solver % backend % field_set_face ( u , 0._dp , 0._dp , Y_FACE ) call self % solver % backend % field_set_face ( v , 0._dp , 0._dp , Y_FACE ) call self % solver % backend % field_set_face ( w , 0._dp , 0._dp , Y_FACE ) end subroutine pre_correction_channel subroutine postprocess_channel ( self , iter , t ) implicit none class ( case_channel_t ) :: self integer , intent ( in ) :: iter real ( dp ), intent ( in ) :: t if ( self % solver % mesh % par % is_root ()) then print * , 'time =' , t , 'iteration =' , iter end if call self % print_enstrophy ( self % solver % u , self % solver % v , self % solver % w ) call self % print_div_max_mean ( self % solver % u , self % solver % v , self % solver % w ) end subroutine postprocess_channel end module m_case_channel","tags":"","url":"sourcefile/channel.f90.html"},{"title":"allocator.f90 – x3d2","text":"This file depends on sourcefile~~allocator.f90~2~~EfferentGraph sourcefile~allocator.f90~2 allocator.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~allocator.f90~2->sourcefile~allocator.f90 sourcefile~common.f90 common.f90 sourcefile~allocator.f90~2->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~allocator.f90~2->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~allocator.f90~2~~AfferentGraph sourcefile~allocator.f90~2 allocator.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_allocator use m_allocator , only : allocator_t use m_common , only : dp use m_field , only : field_t use m_mesh , only : mesh_t implicit none type , extends ( allocator_t ) :: cuda_allocator_t contains procedure :: create_block => create_cuda_block end type cuda_allocator_t interface cuda_allocator_t module procedure cuda_allocator_init end interface cuda_allocator_t type , extends ( field_t ) :: cuda_field_t real ( dp ), device , pointer , private :: p_data_d (:) real ( dp ), device , pointer , contiguous :: data_d (:, :, :) contains procedure :: fill => fill_cuda procedure :: get_shape => get_shape_cuda procedure :: set_shape => set_shape_cuda end type cuda_field_t interface cuda_field_t module procedure cuda_field_init end interface cuda_field_t contains function cuda_field_init ( ngrid , next , id ) result ( f ) integer , intent ( in ) :: ngrid , id type ( cuda_field_t ), pointer , intent ( in ) :: next type ( cuda_field_t ) :: f allocate ( f % p_data_d ( ngrid )) f % refcount = 0 f % next => next f % id = id end function cuda_field_init subroutine fill_cuda ( self , c ) implicit none class ( cuda_field_t ) :: self real ( dp ), intent ( in ) :: c self % p_data_d = c end subroutine fill_cuda function get_shape_cuda ( self ) result ( dims ) implicit none class ( cuda_field_t ) :: self integer :: dims ( 3 ) dims = shape ( self % data_d ) end function get_shape_cuda subroutine set_shape_cuda ( self , dims ) implicit none class ( cuda_field_t ) :: self integer , intent ( in ) :: dims ( 3 ) self % data_d ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 )) => self % p_data_d end subroutine set_shape_cuda function cuda_allocator_init ( dims , sz ) result ( allocator ) integer , intent ( in ) :: dims ( 3 ), sz type ( cuda_allocator_t ) :: allocator allocator % allocator_t = allocator_t ( dims , sz ) end function cuda_allocator_init function create_cuda_block ( self , next ) result ( ptr ) class ( cuda_allocator_t ), intent ( inout ) :: self type ( cuda_field_t ), pointer , intent ( in ) :: next type ( cuda_field_t ), pointer :: newblock class ( field_t ), pointer :: ptr allocate ( newblock ) self % next_id = self % next_id + 1 newblock = cuda_field_t ( self % ngrid , next , id = self % next_id ) ptr => newblock end function create_cuda_block end module m_cuda_allocator","tags":"","url":"sourcefile/allocator.f90~2.html"},{"title":"checkpoint_manager.f90 – x3d2","text":"This file depends on sourcefile~~checkpoint_manager.f90~~EfferentGraph sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~common.f90 common.f90 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~config.f90 config.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~field.f90 field.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~solver.f90 solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~checkpoint_manager.f90~~AfferentGraph sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_checkpoint_manager ! @brief Manages the creation and restoration of simulation checkpoints !! for restart capabilities. !! !! @details This module is responsible for periodically saving the full, unstrided !! simulation state to a file. This allows a simulation to be stopped and resumed !! from the exact state it was in. !! !! Key features include: !! - Reading all checkpoint settings from a configuration file !! - Periodically writing the full-resolution simulation state !! - Handling the full logic for restarting a simulation from !! a specified checkpoint file. !! - A safe-write strategy that writes to a temporary file first, !!   then atomically renames it to the final filename to !! prevent corrupted checkpoints. !! - Optional cleanup of old checkpoint files to conserve disk space. use mpi , only : MPI_COMM_WORLD , MPI_Comm_rank , MPI_Abort use m_common , only : dp , i8 , DIR_X , get_argument use m_field , only : field_t use m_solver , only : solver_t use m_io_session , only : reader_session_t , writer_session_t use m_config , only : checkpoint_config_t use m_io_field_utils , only : field_buffer_map_t , field_ptr_t , & setup_field_arrays , cleanup_field_arrays , & stride_data_to_buffer , get_output_dimensions , & prepare_field_buffers , cleanup_field_buffers , & write_single_field_to_buffer implicit none type :: raw_old_field_buffer_t real ( dp ), allocatable :: data (:, :, :) end type raw_old_field_buffer_t private public :: checkpoint_manager_t type :: checkpoint_manager_t type ( checkpoint_config_t ) :: config integer :: last_checkpoint_step = - 1 integer , dimension ( 3 ) :: full_resolution = [ 1 , 1 , 1 ] type ( field_buffer_map_t ), allocatable :: field_buffers (:) integer ( i8 ), dimension ( 3 ) :: last_shape_dims = 0 integer , dimension ( 3 ) :: last_stride_factors = 0 integer ( i8 ), dimension ( 3 ) :: last_output_shape = 0 contains procedure :: init procedure :: handle_restart procedure :: handle_checkpoint_step procedure :: is_restart procedure :: finalise procedure , private :: write_checkpoint procedure , private :: restart_checkpoint procedure , private :: write_fields procedure , private :: cleanup_output_buffers end type checkpoint_manager_t contains subroutine init ( self , comm ) !! Initialise checkpoint manager class ( checkpoint_manager_t ), intent ( inout ) :: self integer , intent ( in ) :: comm self % config = checkpoint_config_t () call self % config % read ( nml_file = get_argument ( 1 )) if ( self % config % checkpoint_freq > 0 ) then call configure_output ( self , comm ) end if end subroutine init subroutine configure_output ( self , comm ) !! Configure checkpoint output settings use m_io_backend , only : get_default_backend , IO_BACKEND_DUMMY class ( checkpoint_manager_t ), intent ( inout ) :: self integer , intent ( in ) :: comm integer :: myrank , ierr call MPI_Comm_rank ( comm , myrank , ierr ) if ( myrank == 0 . and . get_default_backend () /= IO_BACKEND_DUMMY ) then print * , 'Checkpoint frequency: ' , self % config % checkpoint_freq print * , 'Keep all checkpoints: ' , self % config % keep_checkpoint print * , 'Checkpoint prefix: ' , trim ( self % config % checkpoint_prefix ) end if end subroutine configure_output function is_restart ( self ) result ( restart ) !! Check if this is a restart run class ( checkpoint_manager_t ), intent ( in ) :: self logical :: restart restart = self % config % restart_from_checkpoint end function is_restart subroutine handle_restart ( self , solver , comm ) !! Handle restart from checkpoint class ( checkpoint_manager_t ), intent ( inout ) :: self class ( solver_t ), intent ( inout ) :: solver integer , intent ( in ), optional :: comm character ( len = 256 ) :: restart_file integer :: restart_timestep real ( dp ) :: restart_time restart_file = trim ( self % config % restart_file ) if ( solver % mesh % par % is_root ()) then print * , 'Restarting from checkpoint: ' , restart_file end if call self % restart_checkpoint ( solver , restart_file , restart_timestep , & restart_time , comm ) solver % current_iter = restart_timestep if ( solver % mesh % par % is_root ()) then print * , 'Successfully restarted from checkpoint at iteration ' , & restart_timestep , ' with time ' , restart_time end if end subroutine handle_restart subroutine handle_checkpoint_step ( self , solver , timestep , comm ) !! Handle checkpoint writing at a given timestep class ( checkpoint_manager_t ), intent ( inout ) :: self class ( solver_t ), intent ( in ) :: solver integer , intent ( in ) :: timestep integer , intent ( in ), optional :: comm integer :: comm_to_use comm_to_use = MPI_COMM_WORLD if ( present ( comm )) comm_to_use = comm call self % write_checkpoint ( solver , timestep , comm_to_use ) end subroutine handle_checkpoint_step subroutine write_checkpoint ( self , solver , timestep , comm ) !! Write a checkpoint file for simulation restart class ( checkpoint_manager_t ), intent ( inout ) :: self class ( solver_t ), intent ( in ) :: solver integer , intent ( in ) :: timestep integer , intent ( in ) :: comm character ( len = 256 ) :: filename , temp_filename , old_filename integer :: ierr , myrank character ( len =* ), parameter :: field_names ( * ) = [ \"u\" , \"v\" , \"w\" ] real ( dp ) :: simulation_time logical :: file_exists type ( field_ptr_t ), allocatable :: field_ptrs (:), host_fields (:) integer :: data_loc , is_ab , i , j , n_total_vars type ( writer_session_t ) :: writer_session integer :: nolds_total , idx character ( len = 16 ), allocatable :: old_field_names (:) if ( self % config % checkpoint_freq <= 0 ) return if ( mod ( timestep , self % config % checkpoint_freq ) /= 0 ) return call MPI_Comm_rank ( comm , myrank , ierr ) write ( filename , '(A,A,I0.6,A)' ) & trim ( self % config % checkpoint_prefix ), '_' , timestep , '.bp' write ( temp_filename , '(A,A)' ) & trim ( self % config % checkpoint_prefix ), '_temp.bp' call writer_session % open ( temp_filename , comm ) if ( writer_session % is_session_functional () . and . myrank == 0 ) then print * , 'Writing checkpoint: ' , trim ( filename ) end if simulation_time = timestep * solver % dt data_loc = solver % u % data_loc call writer_session % write_data ( \"timestep\" , timestep ) call writer_session % write_data ( \"time\" , real ( simulation_time , dp )) call writer_session % write_data ( \"dt\" , real ( solver % dt , dp )) call writer_session % write_data ( \"data_loc\" , data_loc ) n_total_vars = size ( field_names ) call setup_field_arrays ( solver , field_names , field_ptrs , host_fields ) call self % write_fields ( & field_names , host_fields , & solver , writer_session , data_loc & ) ! serialise time integrator metadata if ( solver % time_integrator % sname ( 1 : 2 ) == 'AB' ) then is_ab = 1 else is_ab = 0 end if call writer_session % write_data ( 'ti_is_ab' , is_ab ) call writer_session % write_data ( 'ti_order' , solver % time_integrator % order ) call writer_session % write_data ( 'ti_istep' , solver % time_integrator % istep ) call writer_session % write_data ( 'ti_nstep' , solver % time_integrator % nstep ) ! for AB methods with order >1, keep derivative history olds(i,j) if ( is_ab == 1 . and . solver % time_integrator % order > 1 ) then nolds_total = solver % time_integrator % nolds * n_total_vars allocate ( old_field_names ( nolds_total )) ! Olds fields live in padded DIR_X layout. Persist the raw blocked data per rank ! so that restarts can reconstruct the exact derivative history, including padding. block integer :: rank_id , ierr_local integer :: padded_dims ( 3 ) character ( len = 16 ) :: rank_suffix character ( len = 64 ) :: ranked_name type ( raw_old_field_buffer_t ), allocatable :: raw_buffers (:) call MPI_Comm_rank ( comm , rank_id , ierr_local ) write ( rank_suffix , '(\"_rank\",I0.6)' ) rank_id allocate ( raw_buffers ( nolds_total )) idx = 0 do i = 1 , n_total_vars do j = 1 , solver % time_integrator % nolds idx = idx + 1 write ( old_field_names ( idx ), '(A,\"_rhs_old\",I0)' ) & trim ( field_names ( i )), j write ( ranked_name , '(A,A)' ) trim ( old_field_names ( idx )), & trim ( rank_suffix ) padded_dims = solver % time_integrator % olds ( i , j )% ptr % get_shape () if ( allocated ( raw_buffers ( idx )% data )) then if ( any ( shape ( raw_buffers ( idx )% data ) /= padded_dims )) then deallocate ( raw_buffers ( idx )% data ) end if end if if (. not . allocated ( raw_buffers ( idx )% data )) then allocate ( raw_buffers ( idx )% data ( padded_dims ( 1 ), & padded_dims ( 2 ), padded_dims ( 3 ))) end if raw_buffers ( idx )% data = solver % time_integrator % olds ( i , j )% ptr % data ! Use -1 to signal local per-rank variables (not decomposed across ranks) ! Each rank writes to its own uniquely named variable (with _rank suffix) call writer_session % write_data ( trim ( ranked_name ), & raw_buffers ( idx )% data , & [ - 1_i8 , - 1_i8 , - 1_i8 ], & [ - 1_i8 , - 1_i8 , - 1_i8 ], & int ( padded_dims , i8 )) end do end do ! Ensure ADIOS2 still sees a valid buffer until after close call writer_session % close () do idx = 1 , nolds_total if ( allocated ( raw_buffers ( idx )% data )) then deallocate ( raw_buffers ( idx )% data ) end if end do deallocate ( raw_buffers ) end block else call writer_session % close () end if ! clean up buffers after session close (ADIOS2 deferred writes need them until end_step) call self % cleanup_output_buffers () if ( allocated ( old_field_names )) then deallocate ( old_field_names ) end if call cleanup_field_arrays ( solver , field_ptrs , host_fields ) if ( myrank == 0 ) then inquire ( file = trim ( temp_filename ), exist = file_exists ) if ( file_exists ) then ! Move temporary file to final checkpoint filename call execute_command_line ( 'mv ' // trim ( temp_filename ) // ' ' // & trim ( filename )) inquire ( file = trim ( filename ), exist = file_exists ) if (. not . file_exists ) then print * , 'ERROR: Checkpoint file not created: ' , trim ( filename ) end if else ! temp file doesn't exist - skip file operations silently end if ! Remove old checkpoint if configured to keep only the latest if (. not . self % config % keep_checkpoint & . and . self % last_checkpoint_step > 0 ) then write ( old_filename , '(A,A,I0.6,A)' ) & trim ( self % config % checkpoint_prefix ), '_' , & self % last_checkpoint_step , '.bp' inquire ( file = trim ( old_filename ), exist = file_exists ) if ( file_exists ) then call execute_command_line ( 'rm -rf ' // trim ( old_filename ), & exitstat = ierr ) if ( ierr /= 0 ) then print * , 'WARNING: failed to remove old checkpoint: ' , & trim ( old_filename ) end if end if end if end if self % last_checkpoint_step = timestep end subroutine write_checkpoint subroutine restart_checkpoint ( & self , solver , filename , timestep , restart_time , comm & ) !! Restart simulation state from checkpoint file class ( checkpoint_manager_t ), intent ( inout ) :: self class ( solver_t ), intent ( inout ) :: solver character ( len =* ), intent ( in ) :: filename integer , intent ( out ) :: timestep real ( dp ), intent ( out ) :: restart_time integer , intent ( in ) :: comm type ( reader_session_t ) :: reader_session integer :: ierr , myrank , data_loc integer :: dims ( 3 ) integer ( i8 ), dimension ( 3 ) :: start_dims , count_dims character ( len =* ), parameter :: field_names ( * ) = [ \"u\" , \"v\" , \"w\" ] logical :: file_exists integer :: ti_is_ab , ti_order , ti_istep , ti_nstep logical :: have_ti_meta character ( len = 16 ), allocatable :: var_names (:) integer :: n_total_vars character ( len = 64 ) :: old_name integer :: i , j call MPI_Comm_rank ( comm , myrank , ierr ) inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then if ( solver % mesh % par % is_root ()) then print * , 'ERROR: Checkpoint file not found: ' , trim ( filename ) end if call MPI_Abort ( comm , 1 , ierr ) return end if call reader_session % open ( filename , comm ) call reader_session % read_data ( \"timestep\" , timestep ) call reader_session % read_data ( \"time\" , restart_time ) call reader_session % read_data ( \"data_loc\" , data_loc ) ! restore dt if present block real ( dp ) :: chk_dt call reader_session % read_data ( \"dt\" , chk_dt ) solver % dt = chk_dt end block ! attempt to read time integrator metadata have_ti_meta = . true . block call reader_session % read_data ( 'ti_is_ab' , ti_is_ab ) call reader_session % read_data ( 'ti_order' , ti_order ) call reader_session % read_data ( 'ti_istep' , ti_istep ) call reader_session % read_data ( 'ti_nstep' , ti_nstep ) end block dims = solver % mesh % get_dims ( data_loc ) start_dims = int ( solver % mesh % par % n_offset , i8 ) count_dims = int ( dims , i8 ) call solver % u % set_data_loc ( data_loc ) call solver % v % set_data_loc ( data_loc ) call solver % w % set_data_loc ( data_loc ) block real ( dp ), allocatable , target :: field_data_u (:, :, :) real ( dp ), allocatable , target :: field_data_v (:, :, :) real ( dp ), allocatable , target :: field_data_w (:, :, :) ! Zero velocity fields before restoring to ensure padding is initialized call solver % u % fill ( 0.0_dp ) call solver % v % fill ( 0.0_dp ) call solver % w % fill ( 0.0_dp ) allocate ( field_data_u ( count_dims ( 1 ), count_dims ( 2 ), count_dims ( 3 ))) allocate ( field_data_v ( count_dims ( 1 ), count_dims ( 2 ), count_dims ( 3 ))) allocate ( field_data_w ( count_dims ( 1 ), count_dims ( 2 ), count_dims ( 3 ))) call reader_session % read_data ( \"u\" , field_data_u , start_dims = start_dims , & count_dims = count_dims ) call reader_session % read_data ( \"v\" , field_data_v , start_dims = start_dims , & count_dims = count_dims ) call reader_session % read_data ( \"w\" , field_data_w , start_dims = start_dims , & count_dims = count_dims ) call solver % backend % set_field_data ( solver % u , field_data_u ) call solver % backend % set_field_data ( solver % v , field_data_v ) call solver % backend % set_field_data ( solver % w , field_data_w ) end block ! restore AB derivative history if metadata indicates AB and order>1 if ( have_ti_meta ) then if ( ti_is_ab == 1 ) then solver % time_integrator % istep = ti_istep solver % time_integrator % nstep = ti_nstep if ( solver % time_integrator % order /= ti_order ) then if ( solver % mesh % par % is_root ()) then print * , 'WARNING: checkpoint AB order differs from current & & solver config; using checkpoint order' end if solver % time_integrator % order = ti_order end if if ( ti_order > 1 ) then ! Restore the raw padded derivative history per rank block character ( len = 16 ) :: rank_suffix character ( len = 64 ) :: ranked_name real ( dp ), allocatable , target :: old_field (:, :, :) integer :: padded_dims ( 3 ) n_total_vars = size ( field_names ) allocate ( var_names ( n_total_vars )) var_names = field_names write ( rank_suffix , '(\"_rank\",I0.6)' ) myrank do i = 1 , n_total_vars do j = 1 , solver % time_integrator % nolds call solver % time_integrator % olds ( i , j )% ptr % fill ( 0.0_dp ) end do end do do i = 1 , n_total_vars do j = 1 , solver % time_integrator % nolds write ( old_name , '(A,\"_rhs_old\",I0)' ) trim ( var_names ( i )), j write ( ranked_name , '(A,A)' ) trim ( old_name ), trim ( rank_suffix ) padded_dims = shape ( solver % time_integrator % olds ( i , j )% ptr % data ) if ( allocated ( old_field )) then if ( any ( shape ( old_field ) /= padded_dims )) then deallocate ( old_field ) end if end if if (. not . allocated ( old_field )) then allocate ( old_field ( padded_dims ( 1 ), & padded_dims ( 2 ), padded_dims ( 3 ))) end if ! Clear the buffer before reading old_field = 0.0_dp call reader_session % read_data ( trim ( ranked_name ), old_field ) solver % time_integrator % olds ( i , j )% ptr % data = old_field end do end do if ( allocated ( old_field )) deallocate ( old_field ) deallocate ( var_names ) end block end if end if end if call reader_session % close () end subroutine restart_checkpoint subroutine write_fields ( & self , field_names , host_fields , solver , writer_session , data_loc & ) !! Write field data for checkpoints (no striding) class ( checkpoint_manager_t ), intent ( inout ) :: self character ( len =* ), dimension (:), intent ( in ) :: field_names class ( field_ptr_t ), dimension (:), target , intent ( in ) :: host_fields class ( solver_t ), intent ( in ) :: solver type ( writer_session_t ), intent ( inout ) :: writer_session integer , intent ( in ) :: data_loc integer :: i_field integer ( i8 ), dimension ( 3 ) :: output_start , output_count integer , dimension ( 3 ) :: output_dims_local ! Prepare buffers for full resolution (no striding for checkpoints) call prepare_field_buffers ( & solver , self % full_resolution , field_names , data_loc , & self % field_buffers , self % last_shape_dims , self % last_stride_factors , & self % last_output_shape & ) ! Calculate output dimensions for writing call get_output_dimensions ( & int ( solver % mesh % get_global_dims ( data_loc ), i8 ), & int ( solver % mesh % par % n_offset , i8 ), & int ( solver % mesh % get_dims ( data_loc ), i8 ), & self % full_resolution , & self % last_output_shape , output_start , output_count , & output_dims_local , & self % last_shape_dims , self % last_stride_factors , & self % last_output_shape & ) do i_field = 1 , size ( field_names ) call write_single_field_to_buffer ( & trim ( field_names ( i_field )), host_fields ( i_field )% ptr , & solver , self % full_resolution , data_loc , & self % field_buffers , self % last_shape_dims , self % last_stride_factors , & self % last_output_shape & ) call writer_session % write_data ( & trim ( field_names ( i_field )), & self % field_buffers ( i_field )% buffer , & self % last_output_shape , & output_start , output_count & ) end do end subroutine write_fields subroutine cleanup_output_buffers ( self ) !! Clean up dynamic field buffers class ( checkpoint_manager_t ), intent ( inout ) :: self call cleanup_field_buffers ( self % field_buffers ) end subroutine cleanup_output_buffers subroutine finalise ( self ) !! Clean up checkpoint manager class ( checkpoint_manager_t ), intent ( inout ) :: self call self % cleanup_output_buffers () end subroutine finalise end module m_checkpoint_manager","tags":"","url":"sourcefile/checkpoint_manager.f90.html"},{"title":"tdsops.f90 – x3d2","text":"This file depends on sourcefile~~tdsops.f90~~EfferentGraph sourcefile~tdsops.f90 tdsops.f90 sourcefile~common.f90 common.f90 sourcefile~tdsops.f90->sourcefile~common.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~tdsops.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tdsops.f90~~AfferentGraph sourcefile~tdsops.f90 tdsops.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90 sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~exec_dist.f90->sourcefile~tdsops.f90 sourcefile~exec_thom.f90 exec_thom.f90 sourcefile~exec_thom.f90->sourcefile~tdsops.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_tdsops use iso_fortran_env , only : stderr => error_unit use m_common , only : dp use m_tdsops , only : tdsops_t , tdsops_init implicit none type , extends ( tdsops_t ) :: cuda_tdsops_t !! CUDA extension of the Tridiagonal Solver Operators class. !! !! Regular tdsops_t class is initiated and the coefficient arrays are !! copied into device arrays so that cuda kernels can use them. real ( dp ), device , allocatable :: dist_fw_dev (:), dist_bw_dev (:), & dist_sa_dev (:), dist_sc_dev (:), & dist_af_dev (:) real ( dp ), device , allocatable :: thom_f_dev (:), thom_s_dev (:), & thom_w_dev (:), thom_p_dev (:) real ( dp ), device , allocatable :: stretch_dev (:), stretch_correct_dev (:) real ( dp ), device , allocatable :: coeffs_dev (:), & coeffs_s_dev (:, :), coeffs_e_dev (:, :) contains end type cuda_tdsops_t interface cuda_tdsops_t module procedure cuda_tdsops_init end interface cuda_tdsops_t contains function cuda_tdsops_init ( & n_tds , delta , operation , scheme , bc_start , bc_end , & stretch , stretch_correct , n_halo , from_to , sym , c_nu , nu0_nu & ) result ( tdsops ) !! Constructor function for the cuda_tdsops_t class. !! See tdsops_t for details. implicit none type ( cuda_tdsops_t ) :: tdsops !! return value of the function integer , intent ( in ) :: n_tds real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: operation , scheme integer , intent ( in ) :: bc_start , bc_end real ( dp ), optional , intent ( in ) :: stretch (:), stretch_correct (:) integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu integer :: n , n_stencil tdsops % tdsops_t = tdsops_init ( n_tds , delta , operation , scheme , bc_start , & bc_end , stretch , stretch_correct , n_halo , & from_to , sym , c_nu , nu0_nu ) n = tdsops % n_rhs allocate ( tdsops % dist_fw_dev ( n ), tdsops % dist_bw_dev ( n )) allocate ( tdsops % dist_sa_dev ( n ), tdsops % dist_sc_dev ( n )) allocate ( tdsops % dist_af_dev ( n )) allocate ( tdsops % thom_f_dev ( n ), tdsops % thom_s_dev ( n )) allocate ( tdsops % thom_w_dev ( n ), tdsops % thom_p_dev ( n )) allocate ( tdsops % stretch_dev ( tdsops % n_tds )) allocate ( tdsops % stretch_correct_dev ( tdsops % n_tds )) n_stencil = 2 * tdsops % n_halo + 1 allocate ( tdsops % coeffs_dev ( n_stencil )) allocate ( tdsops % coeffs_s_dev ( n_stencil , tdsops % n_halo )) allocate ( tdsops % coeffs_e_dev ( n_stencil , tdsops % n_halo )) tdsops % dist_fw_dev (:) = tdsops % dist_fw (:) tdsops % dist_bw_dev (:) = tdsops % dist_bw (:) tdsops % dist_sa_dev (:) = tdsops % dist_sa (:) tdsops % dist_sc_dev (:) = tdsops % dist_sc (:) tdsops % dist_af_dev (:) = tdsops % dist_af (:) tdsops % thom_f_dev (:) = tdsops % thom_f (:) tdsops % thom_s_dev (:) = tdsops % thom_s (:) tdsops % thom_w_dev (:) = tdsops % thom_w (:) tdsops % thom_p_dev (:) = tdsops % thom_p (:) tdsops % stretch_dev (:) = tdsops % stretch (:) tdsops % stretch_correct_dev (:) = tdsops % stretch_correct (:) tdsops % coeffs_dev (:) = tdsops % coeffs (:) tdsops % coeffs_s_dev (:, :) = tdsops % coeffs_s (:, :) tdsops % coeffs_e_dev (:, :) = tdsops % coeffs_e (:, :) end function cuda_tdsops_init end module m_cuda_tdsops","tags":"","url":"sourcefile/tdsops.f90.html"},{"title":"common.f90 – x3d2","text":"Files dependent on this one sourcefile~~common.f90~2~~AfferentGraph sourcefile~common.f90~2 common.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~common.f90~2 sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~backend.f90->sourcefile~exec_dist.f90~2 sourcefile~distributed.f90 distributed.f90 sourcefile~distributed.f90->sourcefile~common.f90~2 sourcefile~exec_dist.f90~2->sourcefile~common.f90~2 sourcefile~exec_dist.f90~2->sourcefile~distributed.f90 sourcefile~thomas.f90~2 thomas.f90 sourcefile~thomas.f90~2->sourcefile~common.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~common.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~exec_thom.f90~2 exec_thom.f90 sourcefile~exec_thom.f90~2->sourcefile~thomas.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_omp_common implicit none integer , parameter :: SZ = 16 end module m_omp_common","tags":"","url":"sourcefile/common.f90~2.html"},{"title":"solver.f90 – x3d2","text":"This file depends on sourcefile~~solver.f90~~EfferentGraph sourcefile~solver.f90 solver.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~common.f90 common.f90 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~config.f90 config.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~field.f90 field.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io.f90 io.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~solver.f90~~AfferentGraph sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_solver use iso_fortran_env , only : stderr => error_unit use mpi use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_common , only : dp , get_argument , & RDR_X2Y , RDR_X2Z , RDR_Y2X , RDR_Y2Z , RDR_Z2X , RDR_Z2Y , & RDR_Z2C , RDR_C2Z , & DIR_X , DIR_Y , DIR_Z , DIR_C , VERT , CELL , & BC_NEUMANN , BC_DIRICHLET use m_config , only : solver_config_t use m_field , only : field_t , flist_t use m_ibm , only : ibm_t use m_mesh , only : mesh_t use m_tdsops , only : dirps_t use m_time_integrator , only : time_intg_t use m_vector_calculus , only : vector_calculus_t implicit none type :: solver_t !! solver class defines the Incompact3D algorithm at a very high level. !! !! Procedures defined here that are part of the Incompact3D algorithm !! are: transeq, divergence, poisson, and gradient. !! !! The operations these high level procedures require are provided by !! the relavant backend implementations. !! !! transeq procedure obtains the derivations in x, y, and z directions !! using the transeq_x, transeq_y, and transeq_z operations provided by !! the backend. !! There are two different algorithms available for this operation, a !! distributed algorithm and the Thomas algorithm. At the solver class !! level it isn't known which algorithm will be executed, that is decided !! at run time and therefore backend implementations are responsible for !! executing the right subroutines. !! !! Allocator is responsible from giving us a field sized array when !! requested. For example, when the derivations in x direction are !! completed and we are ready for the y directional derivatives, we need !! three fields to reorder and store the velocities in y direction. Also, !! we need three more fields for storing the results, and the get_block !! method of the allocator is used to arrange all these memory !! assignments. Later, when a field is no more required, release_block !! method of the allocator can be used to make this field available !! for later use. real ( dp ) :: dt , nu real ( dp ), dimension (:), allocatable :: nu_species integer :: n_iters , n_output integer :: current_iter = 0 integer :: ngrid integer :: nvars = 3 integer :: nspecies = 0 class ( field_t ), pointer :: u , v , w type ( flist_t ), dimension (:), pointer :: species => null () class ( base_backend_t ), pointer :: backend type ( mesh_t ), pointer :: mesh type ( time_intg_t ) :: time_integrator type ( allocator_t ), pointer :: host_allocator type ( dirps_t ), pointer :: xdirps , ydirps , zdirps type ( vector_calculus_t ) :: vector_calculus type ( ibm_t ) :: ibm logical :: ibm_on procedure ( poisson_solver ), pointer :: poisson => null () procedure ( transport_equation ), pointer :: transeq => null () contains procedure :: transeq_species procedure :: pressure_correction procedure :: divergence_v2p procedure :: gradient_p2v procedure :: curl end type solver_t abstract interface subroutine poisson_solver ( self , pressure , div_u ) import :: solver_t import :: field_t implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u end subroutine poisson_solver subroutine transport_equation ( self , rhs , variables ) import :: solver_t import :: flist_t implicit none class ( solver_t ) :: self type ( flist_t ), intent ( inout ) :: rhs (:), variables (:) end subroutine transport_equation end interface interface solver_t module procedure init end interface solver_t contains function init ( backend , mesh , host_allocator ) result ( solver ) implicit none class ( base_backend_t ), target , intent ( inout ) :: backend type ( mesh_t ), target , intent ( inout ) :: mesh type ( allocator_t ), target , intent ( inout ) :: host_allocator type ( solver_t ) :: solver type ( solver_config_t ) :: solver_cfg integer :: i solver % backend => backend solver % mesh => mesh solver % host_allocator => host_allocator allocate ( solver % xdirps , solver % ydirps , solver % zdirps ) solver % xdirps % dir = DIR_X solver % ydirps % dir = DIR_Y solver % zdirps % dir = DIR_Z solver % vector_calculus = vector_calculus_t ( solver % backend ) solver % u => solver % backend % allocator % get_block ( DIR_X ) solver % v => solver % backend % allocator % get_block ( DIR_X ) solver % w => solver % backend % allocator % get_block ( DIR_X ) call solver_cfg % read ( nml_file = get_argument ( 1 )) ! Add transported species solver % nspecies = solver_cfg % n_species if ( solver % nspecies > 0 ) then ! Increase the number of variables solver % nvars = solver % nvars + solver % nspecies ! Init the diffusivity coefficients for species allocate ( solver % nu_species ( solver % nspecies )) solver % nu_species = 1._dp / solver_cfg % Re / solver_cfg % pr_species ! Get blocks for the species allocate ( solver % species ( solver % nspecies )) do i = 1 , solver % nspecies solver % species ( i )% ptr => solver % backend % allocator % get_block ( DIR_X ) end do end if solver % time_integrator = time_intg_t ( solver % backend , & solver % backend % allocator , & solver_cfg % time_intg , solver % nvars ) if ( solver % mesh % par % is_root ()) then print * , solver_cfg % time_intg // ' time integrator instantiated' end if solver % dt = solver_cfg % dt solver % nu = 1._dp / solver_cfg % Re solver % n_iters = solver_cfg % n_iters solver % n_output = solver_cfg % n_output solver % ngrid = product ( solver % mesh % get_global_dims ( VERT )) ! Allocate and set the tdsops call allocate_tdsops ( & solver % xdirps , solver % backend , solver % mesh , solver_cfg % der1st_scheme , & solver_cfg % der2nd_scheme , solver_cfg % interpl_scheme , & solver_cfg % stagder_scheme & ) call allocate_tdsops ( & solver % ydirps , solver % backend , solver % mesh , solver_cfg % der1st_scheme , & solver_cfg % der2nd_scheme , solver_cfg % interpl_scheme , & solver_cfg % stagder_scheme & ) call allocate_tdsops ( & solver % zdirps , solver % backend , solver % mesh , solver_cfg % der1st_scheme , & solver_cfg % der2nd_scheme , solver_cfg % interpl_scheme , & solver_cfg % stagder_scheme & ) select case ( trim ( solver_cfg % poisson_solver_type )) case ( 'FFT' ) if ( solver % mesh % par % is_root ()) print * , 'Poisson solver: FFT' call solver % backend % init_poisson_fft ( solver % mesh , solver % xdirps , & solver % ydirps , solver % zdirps , & solver_cfg % lowmem_fft ) solver % poisson => poisson_fft case ( 'CG' ) if ( solver % mesh % par % is_root ()) & print * , 'Poisson solver: CG, not yet implemented' solver % poisson => poisson_cg case default error stop 'poisson_solver_type is not valid. Use \"FFT\" or \"CG\".' end select ! Initialize the IBM module solver % ibm_on = solver_cfg % ibm_on if ( solver % ibm_on ) & solver % ibm = ibm_t ( backend , mesh , host_allocator ) if ( solver_cfg % lowmem_transeq ) then solver % transeq => transeq_lowmem else solver % transeq => transeq_default end if end function init subroutine allocate_tdsops ( dirps , backend , mesh , der1st_scheme , & der2nd_scheme , interpl_scheme , stagder_scheme ) type ( dirps_t ), intent ( inout ) :: dirps class ( base_backend_t ), intent ( in ) :: backend type ( mesh_t ), intent ( in ) :: mesh character ( * ), intent ( in ) :: der1st_scheme , der2nd_scheme , & interpl_scheme , stagder_scheme integer :: dir , bc_start , bc_end , bc_mp_start , bc_mp_end , n_vert , n_cell , i real ( dp ) :: d dir = dirps % dir d = mesh % geo % d ( dir ) bc_start = mesh % grid % BCs ( dir , 1 ) bc_end = mesh % grid % BCs ( dir , 2 ) ! For the FFT based poisson solver, the BC for the pressure has to be ! Neumann. This is not strictly compatible with Navier-Stokes equations, ! but it does not affect the quality of the simulation. ! Thus, if the BC is Dirichlet, we enforce Neumann for the midpoint & ! operators. (It could be BC_HALO too, if so we just keep it as is) if ( bc_start == BC_DIRICHLET ) then bc_mp_start = BC_NEUMANN else bc_mp_start = bc_start end if if ( bc_end == BC_DIRICHLET ) then bc_mp_end = BC_NEUMANN else bc_mp_end = bc_end end if n_vert = mesh % get_n ( dir , VERT ) n_cell = mesh % get_n ( dir , CELL ) call backend % alloc_tdsops ( & dirps % der1st , n_vert , d , 'first-deriv' , der1st_scheme , & bc_start , bc_end , stretch = mesh % geo % vert_ds ( 1 : n_vert , dir ) & ) call backend % alloc_tdsops ( & dirps % der1st_sym , n_vert , d , 'first-deriv' , der1st_scheme , & bc_start , bc_end , stretch = mesh % geo % vert_ds ( 1 : n_vert , dir ) & ) call backend % alloc_tdsops ( & dirps % der2nd , n_vert , d , 'second-deriv' , der2nd_scheme , & bc_start , bc_end , stretch = mesh % geo % vert_ds2 ( 1 : n_vert , dir ), & stretch_correct = mesh % geo % vert_d2s ( 1 : n_vert , dir ) & ) call backend % alloc_tdsops ( & dirps % der2nd_sym , n_vert , d , 'second-deriv' , der2nd_scheme , & bc_start , bc_end , stretch = mesh % geo % vert_ds2 ( 1 : n_vert , dir ), & stretch_correct = mesh % geo % vert_d2s ( 1 : n_vert , dir ) & ) call backend % alloc_tdsops ( & dirps % stagder_v2p , n_cell , d , 'stag-deriv' , stagder_scheme , & bc_mp_start , bc_mp_end , from_to = 'v2p' , & stretch = mesh % geo % midp_ds ( 1 : n_cell , dir ) & ) call backend % alloc_tdsops ( & dirps % stagder_p2v , n_vert , d , 'stag-deriv' , stagder_scheme , & bc_mp_start , bc_mp_end , from_to = 'p2v' , & stretch = mesh % geo % vert_ds ( 1 : n_vert , dir ) & ) call backend % alloc_tdsops ( & dirps % interpl_v2p , n_cell , d , 'interpolate' , interpl_scheme , & bc_mp_start , bc_mp_end , from_to = 'v2p' , stretch = [( 1._dp , i = 1 , n_cell )] & ) call backend % alloc_tdsops ( & dirps % interpl_p2v , n_vert , d , 'interpolate' , interpl_scheme , & bc_mp_start , bc_mp_end , from_to = 'p2v' , stretch = [( 1._dp , i = 1 , n_vert )] & ) end subroutine subroutine transeq_default ( self , rhs , variables ) !! Skew-symmetric form of convection-diffusion terms in the !! incompressible Navier-Stokes momemtum equations, excluding !! pressure terms. !! Inputs from velocity grid and outputs to velocity grid. implicit none class ( solver_t ) :: self type ( flist_t ), intent ( inout ) :: rhs (:) type ( flist_t ), intent ( inout ) :: variables (:) class ( field_t ), pointer :: u_y , v_y , w_y , u_z , v_z , w_z , & du_y , dv_y , dw_y , du_z , dv_z , dw_z , & du , dv , dw , u , v , w du => rhs ( 1 )% ptr dv => rhs ( 2 )% ptr dw => rhs ( 3 )% ptr u => variables ( 1 )% ptr v => variables ( 2 )% ptr w => variables ( 3 )% ptr ! -1/2(nabla u curl u + u nabla u) + nu nablasq u ! call derivatives in x direction. Based on the run time arguments this ! executes a distributed algorithm or the Thomas algorithm. call self % backend % transeq_x ( du , dv , dw , u , v , w , self % nu , self % xdirps ) ! request fields from the allocator u_y => self % backend % allocator % get_block ( DIR_Y ) v_y => self % backend % allocator % get_block ( DIR_Y ) w_y => self % backend % allocator % get_block ( DIR_Y ) du_y => self % backend % allocator % get_block ( DIR_Y ) dv_y => self % backend % allocator % get_block ( DIR_Y ) dw_y => self % backend % allocator % get_block ( DIR_Y ) ! reorder data from x orientation to y orientation call self % backend % reorder ( u_y , u , RDR_X2Y ) call self % backend % reorder ( v_y , v , RDR_X2Y ) call self % backend % reorder ( w_y , w , RDR_X2Y ) ! similar to the x direction, obtain derivatives in y. call self % backend % transeq_y ( du_y , dv_y , dw_y , u_y , v_y , w_y , & self % nu , self % ydirps ) ! we don't need the velocities in y orientation any more, so release ! them to open up space. ! It is important that this doesn't actually deallocate any memory, ! it just makes the corresponding memory space available for use. call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( v_y ) call self % backend % allocator % release_block ( w_y ) call self % backend % sum_yintox ( du , du_y ) call self % backend % sum_yintox ( dv , dv_y ) call self % backend % sum_yintox ( dw , dw_y ) call self % backend % allocator % release_block ( du_y ) call self % backend % allocator % release_block ( dv_y ) call self % backend % allocator % release_block ( dw_y ) ! just like in y direction, get some fields for the z derivatives. u_z => self % backend % allocator % get_block ( DIR_Z ) v_z => self % backend % allocator % get_block ( DIR_Z ) w_z => self % backend % allocator % get_block ( DIR_Z ) du_z => self % backend % allocator % get_block ( DIR_Z ) dv_z => self % backend % allocator % get_block ( DIR_Z ) dw_z => self % backend % allocator % get_block ( DIR_Z ) ! reorder from x to z call self % backend % reorder ( u_z , u , RDR_X2Z ) call self % backend % reorder ( v_z , v , RDR_X2Z ) call self % backend % reorder ( w_z , w , RDR_X2Z ) ! get the derivatives in z call self % backend % transeq_z ( du_z , dv_z , dw_z , u_z , v_z , w_z , & self % nu , self % zdirps ) ! there is no need to keep velocities in z orientation around, so release call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( v_z ) call self % backend % allocator % release_block ( w_z ) ! gather all the contributions into the x result array call self % backend % sum_zintox ( du , du_z ) call self % backend % sum_zintox ( dv , dv_z ) call self % backend % sum_zintox ( dw , dw_z ) ! release all the unnecessary blocks. call self % backend % allocator % release_block ( du_z ) call self % backend % allocator % release_block ( dv_z ) call self % backend % allocator % release_block ( dw_z ) ! Convection-diffusion for species if ( self % nspecies > 0 ) then call self % transeq_species ( rhs ( 4 :), variables ) end if end subroutine transeq_default subroutine transeq_lowmem ( self , rhs , variables ) !! low memory version of the transport equation, roughly %2 slower overall implicit none class ( solver_t ) :: self type ( flist_t ), intent ( inout ) :: rhs (:) type ( flist_t ), intent ( inout ) :: variables (:) class ( field_t ), pointer :: u_y , v_y , w_y , u_z , v_z , w_z , & du_y , dv_y , dw_y , du_z , dv_z , dw_z , du , dv , dw , u , v , w du => rhs ( 1 )% ptr dv => rhs ( 2 )% ptr dw => rhs ( 3 )% ptr u => variables ( 1 )% ptr v => variables ( 2 )% ptr w => variables ( 3 )% ptr ! -1/2(nabla u curl u + u nabla u) + nu nablasq u ! call derivatives in x direction. Based on the run time arguments this ! executes a distributed algorithm or the Thomas algorithm. call self % backend % transeq_x ( du , dv , dw , u , v , w , self % nu , self % xdirps ) ! request fields from the allocator u_y => self % backend % allocator % get_block ( DIR_Y ) v_y => self % backend % allocator % get_block ( DIR_Y ) w_y => self % backend % allocator % get_block ( DIR_Y ) ! reorder data from x orientation to y orientation call self % backend % reorder ( u_y , u , RDR_X2Y ) call self % backend % reorder ( v_y , v , RDR_X2Y ) call self % backend % reorder ( w_y , w , RDR_X2Y ) ! now release the x-directional fields for saving memory call self % backend % allocator % release_block ( u ) call self % backend % allocator % release_block ( v ) call self % backend % allocator % release_block ( w ) du_y => self % backend % allocator % get_block ( DIR_Y ) dv_y => self % backend % allocator % get_block ( DIR_Y ) dw_y => self % backend % allocator % get_block ( DIR_Y ) ! similar to the x direction, obtain derivatives in y. call self % backend % transeq_y ( du_y , dv_y , dw_y , u_y , v_y , w_y , & self % nu , self % ydirps ) call self % backend % sum_yintox ( du , du_y ) call self % backend % sum_yintox ( dv , dv_y ) call self % backend % sum_yintox ( dw , dw_y ) call self % backend % allocator % release_block ( du_y ) call self % backend % allocator % release_block ( dv_y ) call self % backend % allocator % release_block ( dw_y ) ! just like in y direction, get some fields for the z derivatives. u_z => self % backend % allocator % get_block ( DIR_Z ) v_z => self % backend % allocator % get_block ( DIR_Z ) w_z => self % backend % allocator % get_block ( DIR_Z ) ! reorder from y to z call self % backend % reorder ( u_z , u_y , RDR_Y2Z ) call self % backend % reorder ( v_z , v_y , RDR_Y2Z ) call self % backend % reorder ( w_z , w_y , RDR_Y2Z ) ! we don't need the velocities in y orientation any more, so release call self % backend % allocator % release_block ( u_y ) call self % backend % allocator % release_block ( v_y ) call self % backend % allocator % release_block ( w_y ) du_z => self % backend % allocator % get_block ( DIR_Z ) dv_z => self % backend % allocator % get_block ( DIR_Z ) dw_z => self % backend % allocator % get_block ( DIR_Z ) ! get the derivatives in z call self % backend % transeq_z ( du_z , dv_z , dw_z , u_z , v_z , w_z , & self % nu , self % zdirps ) ! gather all the contributions into the x result array call self % backend % sum_zintox ( du , du_z ) call self % backend % sum_zintox ( dv , dv_z ) call self % backend % sum_zintox ( dw , dw_z ) ! release all the unnecessary blocks. call self % backend % allocator % release_block ( du_z ) call self % backend % allocator % release_block ( dv_z ) call self % backend % allocator % release_block ( dw_z ) u => self % backend % allocator % get_block ( DIR_X ) v => self % backend % allocator % get_block ( DIR_X ) w => self % backend % allocator % get_block ( DIR_X ) ! reorder from z to x call self % backend % reorder ( u , u_z , RDR_Z2X ) call self % backend % reorder ( v , v_z , RDR_Z2X ) call self % backend % reorder ( w , w_z , RDR_Z2X ) ! there is no need to keep velocities in z orientation around, so release call self % backend % allocator % release_block ( u_z ) call self % backend % allocator % release_block ( v_z ) call self % backend % allocator % release_block ( w_z ) variables ( 1 )% ptr => u variables ( 2 )% ptr => v variables ( 3 )% ptr => w self % u => u self % v => v self % w => w ! Convection-diffusion for species if ( self % nspecies > 0 ) then call self % transeq_species ( rhs ( 4 :), variables ) end if end subroutine transeq_lowmem subroutine transeq_species ( self , rhs , variables ) !! Skew-symmetric form of convection-diffusion terms in the !! species equation. !! Inputs from velocity grid and outputs to velocity grid. implicit none class ( solver_t ) :: self type ( flist_t ), intent ( inout ) :: rhs (:) type ( flist_t ), intent ( in ) :: variables (:) integer :: i class ( field_t ), pointer :: u , v , w , & v_y , spec_y , dspec_y , & w_z , spec_z , dspec_z ! Map the velocity vector u => variables ( 1 )% ptr v => variables ( 2 )% ptr w => variables ( 3 )% ptr ! FIXME later ! Minor optimization ! species could start with z convection-diffusion ! velocity components are ready to use in the z dir. ! derivatives in x do i = 1 , size ( rhs ) call self % backend % transeq_species ( rhs ( i )% ptr , u , & variables ( 3 + i )% ptr , & self % nu_species ( i ), & self % xdirps , & i <= 1 ) end do ! Request blocks v_y => self % backend % allocator % get_block ( DIR_Y ) spec_y => self % backend % allocator % get_block ( DIR_Y ) dspec_y => self % backend % allocator % get_block ( DIR_Y ) ! reorder velocity call self % backend % reorder ( v_y , v , RDR_X2Y ) do i = 1 , size ( rhs ) ! reorder spec in y call self % backend % reorder ( spec_y , variables ( 3 + i )% ptr , RDR_X2Y ) ! y-derivatives call self % backend % transeq_species ( dspec_y , v_y , & spec_y , & self % nu_species ( i ), & self % ydirps , & i <= 1 ) ! sum_yintox call self % backend % sum_yintox ( rhs ( i )% ptr , dspec_y ) end do ! Release blocks call self % backend % allocator % release_block ( v_y ) call self % backend % allocator % release_block ( spec_y ) call self % backend % allocator % release_block ( dspec_y ) ! Request blocks w_z => self % backend % allocator % get_block ( DIR_Z ) spec_z => self % backend % allocator % get_block ( DIR_Z ) dspec_z => self % backend % allocator % get_block ( DIR_Z ) ! reorder velocity call self % backend % reorder ( w_z , w , RDR_X2Z ) do i = 1 , size ( rhs ) ! reorder spec in z call self % backend % reorder ( spec_z , variables ( 3 + i )% ptr , RDR_X2Z ) ! z-derivatives call self % backend % transeq_species ( dspec_z , w_z , & spec_z , & self % nu_species ( i ), & self % zdirps , & i <= 1 ) ! sum_zintox call self % backend % sum_zintox ( rhs ( i )% ptr , dspec_z ) end do ! Release blocks call self % backend % allocator % release_block ( w_z ) call self % backend % allocator % release_block ( spec_z ) call self % backend % allocator % release_block ( dspec_z ) end subroutine transeq_species subroutine divergence_v2p ( self , div_u , u , v , w ) !! Wrapper for divergence_v2p implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: div_u class ( field_t ), intent ( in ) :: u , v , w call self % vector_calculus % divergence_v2c ( & div_u , u , v , w , & self % xdirps % stagder_v2p , self % xdirps % interpl_v2p , & self % ydirps % stagder_v2p , self % ydirps % interpl_v2p , & self % zdirps % stagder_v2p , self % zdirps % interpl_v2p & ) end subroutine divergence_v2p subroutine gradient_p2v ( self , dpdx , dpdy , dpdz , pressure ) !! Wrapper for gradient_p2v implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: dpdx , dpdy , dpdz class ( field_t ), intent ( in ) :: pressure call self % vector_calculus % gradient_c2v ( & dpdx , dpdy , dpdz , pressure , & self % xdirps % stagder_p2v , self % xdirps % interpl_p2v , & self % ydirps % stagder_p2v , self % ydirps % interpl_p2v , & self % zdirps % stagder_p2v , self % zdirps % interpl_p2v & ) end subroutine gradient_p2v subroutine curl ( self , o_i_hat , o_j_hat , o_k_hat , u , v , w ) !! Wrapper for curl implicit none class ( solver_t ) :: self !> Vector components of the output vector field Omega class ( field_t ), intent ( inout ) :: o_i_hat , o_j_hat , o_k_hat class ( field_t ), intent ( in ) :: u , v , w call self % vector_calculus % curl ( & o_i_hat , o_j_hat , o_k_hat , u , v , w , & self % xdirps % der1st , self % ydirps % der1st , self % zdirps % der1st & ) end subroutine curl subroutine poisson_fft ( self , pressure , div_u ) implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u class ( field_t ), pointer :: p_temp , temp ! reorder into 3D Cartesian data structure p_temp => self % backend % allocator % get_block ( DIR_C ) call self % backend % reorder ( p_temp , div_u , RDR_Z2C ) temp => self % backend % allocator % get_block ( DIR_C ) ! solve poisson equation with FFT based approach call self % backend % poisson_fft % solve_poisson ( p_temp , temp ) call self % backend % allocator % release_block ( temp ) ! reorder back to our specialist data structure from 3D Cartesian call self % backend % reorder ( pressure , p_temp , RDR_C2Z ) call self % backend % allocator % release_block ( p_temp ) end subroutine poisson_fft subroutine poisson_cg ( self , pressure , div_u ) implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: pressure class ( field_t ), intent ( in ) :: div_u ! set the pressure field to 0 so that we can do performance tests easily ! this will be removed once the CG solver is implemented of course call pressure % fill ( 0._dp ) end subroutine poisson_cg subroutine pressure_correction ( self , u , v , w ) implicit none class ( solver_t ) :: self class ( field_t ), intent ( inout ) :: u , v , w class ( field_t ), pointer :: div_u , pressure , dpdx , dpdy , dpdz div_u => self % backend % allocator % get_block ( DIR_Z ) call self % divergence_v2p ( div_u , u , v , w ) pressure => self % backend % allocator % get_block ( DIR_Z ) call self % poisson ( pressure , div_u ) call self % backend % allocator % release_block ( div_u ) dpdx => self % backend % allocator % get_block ( DIR_X ) dpdy => self % backend % allocator % get_block ( DIR_X ) dpdz => self % backend % allocator % get_block ( DIR_X ) call self % gradient_p2v ( dpdx , dpdy , dpdz , pressure ) call self % backend % allocator % release_block ( pressure ) ! velocity correction call self % backend % vecadd ( - 1._dp , dpdx , 1._dp , u ) call self % backend % vecadd ( - 1._dp , dpdy , 1._dp , v ) call self % backend % vecadd ( - 1._dp , dpdz , 1._dp , w ) call self % backend % allocator % release_block ( dpdx ) call self % backend % allocator % release_block ( dpdy ) call self % backend % allocator % release_block ( dpdz ) end subroutine pressure_correction end module m_solver","tags":"","url":"sourcefile/solver.f90.html"},{"title":"mesh_content.f90 – x3d2","text":"This file depends on sourcefile~~mesh_content.f90~~EfferentGraph sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~common.f90 common.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mesh_content.f90~~AfferentGraph sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~decomp_dummy.f90 decomp_dummy.f90 sourcefile~decomp_dummy.f90->sourcefile~mesh_content.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~mesh.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~mesh.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~mesh.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~mesh.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~mesh.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~mesh.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~mesh.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_mesh_content use m_common , only : dp , pi implicit none type :: geo_t !! Stores geometry information !> Origin: coordinates of vertex (1, 1, 1) real ( dp ) :: origin ( 3 ) !> size of a cell in each direction for a uniform mesh real ( dp ) :: d ( 3 ) !> Global dimensions of the domain in each direction real ( dp ) :: L ( 3 ) !> Global coordinates at vertices real ( dp ), allocatable , dimension (:, :) :: vert_coords !> Global coordinates at midpoints real ( dp ), allocatable , dimension (:, :) :: midp_coords !> Stretching type character ( len = 20 ), dimension ( 3 ) :: stretching !> Stretching logical :: stretched ( 3 ) !> Stretching parameters real ( dp ) :: alpha ( 3 ), beta ( 3 ) !> Stretching factors at vertices real ( dp ), allocatable , dimension (:, :) :: vert_ds , vert_ds2 , vert_d2s !> Stretching factors at midpoints real ( dp ), allocatable , dimension (:, :) :: midp_ds , midp_ds2 , midp_d2s contains procedure :: obtain_coordinates end type type :: grid_t !! Stores grid information integer , dimension ( 3 ) :: global_vert_dims ! global number of vertices in each direction without padding (cartesian structure) integer , dimension ( 3 ) :: global_cell_dims ! global number of cells in each direction without padding (cartesian structure) integer , dimension ( 3 ) :: vert_dims ! local number of vertices in each direction without padding (cartesian structure) integer , dimension ( 3 ) :: cell_dims ! local number of cells in each direction without padding (cartesian structure) logical , dimension ( 3 ) :: periodic_BC ! Whether or not a direction has a periodic BC integer , dimension ( 3 , 2 ) :: BCs_global integer , dimension ( 3 , 2 ) :: BCs contains procedure :: copy_cell2vert_dims ! Copies cell_dims to vert_dims taking periodicity into account procedure :: copy_vert2cell_dims ! Copies vert_dims to cell_dims taking periodicity into account end type type :: par_t !! Stores parallel domain related information integer :: nrank ! local rank ID integer :: nproc ! total number of ranks/proc participating in the domain decomposition integer , dimension ( 3 ) :: nrank_dir ! local rank ID in each direction integer , dimension ( 3 ) :: nproc_dir ! total number of proc in each direction integer , dimension ( 3 ) :: n_offset ! number of cells offset in each direction due to domain decomposition integer , dimension ( 3 ) :: pnext ! rank ID of the previous rank in each direction integer , dimension ( 3 ) :: pprev ! rank ID of the next rank in each direction contains procedure :: is_root ! returns if the current rank is the root rank procedure :: compute_rank_pos_from_global ! fills in pnext, pprev and nrank_dir from global ranks map end type contains pure function is_root ( self ) result ( is_root_rank ) !! Returns wether or not the current rank is the root rank class ( par_t ), intent ( in ) :: self logical :: is_root_rank is_root_rank = ( self % nrank == 0 ) end function pure subroutine compute_rank_pos_from_global ( self , global_ranks ) !! From the global rank maps, fills in the rank position as well !! as the previous and next rank in the `par` structure class ( par_t ), intent ( inout ) :: self integer , dimension (:, :, :), intent ( in ) :: global_ranks integer , dimension ( 3 ) :: subd_pos , subd_pos_prev , subd_pos_next integer :: dir , nproc ! subdomain position in the global domain subd_pos = findloc ( global_ranks , self % nrank ) ! local/directional position of the subdomain self % nrank_dir (:) = subd_pos (:) - 1 do dir = 1 , 3 nproc = self % nproc_dir ( dir ) subd_pos_prev (:) = subd_pos (:) subd_pos_prev ( dir ) = modulo ( subd_pos ( dir ) - 2 , nproc ) + 1 self % pprev ( dir ) = global_ranks ( subd_pos_prev ( 1 ), & subd_pos_prev ( 2 ), & subd_pos_prev ( 3 )) subd_pos_next (:) = subd_pos (:) subd_pos_next ( dir ) = modulo ( subd_pos ( dir ) - nproc , nproc ) + 1 self % pnext ( dir ) = global_ranks ( subd_pos_next ( 1 ), & subd_pos_next ( 2 ), & subd_pos_next ( 3 )) end do end subroutine pure subroutine copy_vert2cell_dims ( self , par ) !! Copies vert_dims information to cell_dims taking !! periodicity into account class ( grid_t ), intent ( inout ) :: self type ( par_t ), intent ( in ) :: par integer :: dir logical :: is_last_domain do dir = 1 , 3 is_last_domain = ( par % nrank_dir ( dir ) + 1 == par % nproc_dir ( dir )) if ( is_last_domain . and . (. not . self % periodic_BC ( dir ))) then self % cell_dims ( dir ) = self % vert_dims ( dir ) - 1 else self % cell_dims ( dir ) = self % vert_dims ( dir ) end if end do end subroutine pure subroutine copy_cell2vert_dims ( self , par ) !! Copies cell_dims information to vert_dims taking !! periodicity into account class ( grid_t ), intent ( inout ) :: self type ( par_t ), intent ( in ) :: par integer :: dir logical :: is_last_domain do dir = 1 , 3 is_last_domain = ( par % nrank_dir ( dir ) + 1 == par % nproc_dir ( dir )) if ( is_last_domain . and . (. not . self % periodic_BC ( dir ))) then self % vert_dims ( dir ) = self % cell_dims ( dir ) + 1 else self % vert_dims ( dir ) = self % cell_dims ( dir ) end if end do end subroutine subroutine obtain_coordinates ( self , vert_dims , cell_dims , n_offset ) !! Obtains global coordinates for all the vertices and midpoints implicit none class ( geo_t ) :: self integer , intent ( in ) :: vert_dims ( 3 ), cell_dims ( 3 ), n_offset ( 3 ) integer :: dir , i , i_glob real ( dp ) :: L_inf , alpha , beta , r , const , s , yeta_vt , yeta_mp , coord real ( dp ), parameter :: beta_tolerance = epsilon ( 1._dp ) allocate ( self % vert_coords ( maxval ( vert_dims ), 3 )) allocate ( self % vert_ds ( maxval ( vert_dims ), 3 )) allocate ( self % vert_ds2 ( maxval ( vert_dims ), 3 )) allocate ( self % vert_d2s ( maxval ( vert_dims ), 3 )) allocate ( self % midp_coords ( maxval ( cell_dims ), 3 )) allocate ( self % midp_ds ( maxval ( cell_dims ), 3 )) allocate ( self % midp_ds2 ( maxval ( cell_dims ), 3 )) allocate ( self % midp_d2s ( maxval ( cell_dims ), 3 )) ! vertex coordinates do dir = 1 , 3 if ( trim ( self % stretching ( dir )) == 'uniform' ) then self % stretched ( dir ) = . false . self % alpha ( dir ) = 0._dp self % vert_coords ( 1 : vert_dims ( dir ), dir ) = & [(( n_offset ( dir ) + i - 1 ) * self % d ( dir ), i = 1 , vert_dims ( dir ))] self % vert_ds (:, dir ) = 1._dp self % vert_ds2 (:, dir ) = 1._dp self % vert_d2s (:, dir ) = 0._dp self % midp_coords ( 1 : cell_dims ( dir ), dir ) = & [(( n_offset ( dir ) + i - 0.5_dp ) * self % d ( dir ), i = 1 , cell_dims ( dir ))] self % midp_ds (:, dir ) = 1._dp self % midp_ds2 (:, dir ) = 1._dp self % midp_d2s (:, dir ) = 0._dp else self % stretched ( dir ) = . true . L_inf = self % L ( dir ) / 2 beta = self % beta ( dir ) if ( beta <= beta_tolerance ) then error stop 'Invalid beta in domain_settings' end if alpha = abs (( L_inf - sqrt (( pi * beta ) ** 2 + L_inf ** 2 )) / ( 2 * beta * L_inf )) self % alpha ( dir ) = alpha r = sqrt (( alpha * beta + 1 ) / ( alpha * beta )) const = sqrt ( beta ) / ( 2 * sqrt ( alpha ) * sqrt ( alpha * beta + 1 )) s = self % d ( dir ) / self % L ( dir ) do i = 1 , vert_dims ( dir ) i_glob = i + n_offset ( dir ) select case ( trim ( self % stretching ( dir ))) case ( 'centred' ) yeta_vt = ( i_glob - 1 ) * s case ( 'top-bottom' ) yeta_vt = ( i_glob - 1 ) * s - 0.5_dp case ( 'bottom' ) yeta_vt = ( i_glob - 1 ) * s / 2 - 0.5_dp case default error stop 'Invalid stretching type' end select ! vertex coordinates coord = const * atan2 ( r * sin ( pi * yeta_vt ), cos ( pi * yeta_vt )) & * ( 2 * alpha * beta - cos ( 2 * pi * yeta_vt ) + 1 ) & / ( sin ( pi * yeta_vt ) ** 2 + alpha * beta ) self % vert_coords ( i , dir ) = coord + pi * const self % vert_ds ( i , dir ) = self % L ( dir ) * ( alpha / pi & + sin ( pi * yeta_vt ) ** 2 / ( pi * beta )) self % vert_ds2 ( i , dir ) = self % vert_ds ( i , dir ) ** 2 self % vert_d2s ( i , dir ) = 2 * cos ( pi * yeta_vt ) * sin ( pi * yeta_vt ) / beta end do do i = 1 , cell_dims ( dir ) i_glob = i + n_offset ( dir ) select case ( trim ( self % stretching ( dir ))) case ( 'centred' ) yeta_mp = ( i_glob - 0.5_dp ) * s case ( 'top-bottom' ) yeta_mp = ( i_glob - 0.5_dp ) * s - 0.5_dp case ( 'bottom' ) yeta_mp = ( i_glob - 0.5_dp ) * s / 2 - 0.5_dp case default error stop 'Invalid stretching type' end select ! midpoint coordinates coord = const * atan2 ( r * sin ( pi * yeta_mp ), cos ( pi * yeta_mp )) & * ( 2 * alpha * beta - cos ( 2 * pi * yeta_mp ) + 1 ) & / ( sin ( pi * yeta_mp ) ** 2 + alpha * beta ) self % midp_coords ( i , dir ) = coord + pi * const self % midp_ds ( i , dir ) = self % L ( dir ) * ( alpha / pi & + sin ( pi * yeta_mp ) ** 2 / ( pi * beta )) self % midp_ds2 ( i , dir ) = self % midp_ds ( i , dir ) ** 2 self % midp_d2s ( i , dir ) = 2 * cos ( pi * yeta_mp ) * sin ( pi * yeta_mp ) / beta end do ! final shifts/corrections select case ( trim ( self % stretching ( dir ))) case ( 'centred' ) self % vert_coords (:, dir ) = self % vert_coords (:, dir ) - L_inf self % midp_coords (:, dir ) = self % midp_coords (:, dir ) - L_inf case ( 'bottom' ) self % vert_coords (:, dir ) = 2 * ( self % vert_coords (:, dir )) self % vert_d2s (:, dir ) = self % vert_d2s (:, dir ) / 2 self % midp_coords (:, dir ) = 2 * ( self % midp_coords (:, dir )) self % midp_d2s (:, dir ) = self % midp_d2s (:, dir ) / 2 end select end if end do end subroutine obtain_coordinates end module m_mesh_content","tags":"","url":"sourcefile/mesh_content.f90.html"},{"title":"common.f90 – x3d2","text":"Files dependent on this one sourcefile~~common.f90~3~~AfferentGraph sourcefile~common.f90~3 common.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~common.f90~3 sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~fieldops.f90 fieldops.f90 sourcefile~backend.f90~3->sourcefile~fieldops.f90 sourcefile~reorder.f90 reorder.f90 sourcefile~backend.f90~3->sourcefile~reorder.f90 sourcefile~exec_dist.f90->sourcefile~common.f90~3 sourcefile~fieldops.f90->sourcefile~common.f90~3 sourcefile~reorder.f90->sourcefile~common.f90~3 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~common.f90~3 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_common implicit none integer , parameter :: SZ = 32 end module m_cuda_common","tags":"","url":"sourcefile/common.f90~3.html"},{"title":"exec_dist.f90 – x3d2","text":"This file depends on sourcefile~~exec_dist.f90~~EfferentGraph sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~common.f90 common.f90 sourcefile~exec_dist.f90->sourcefile~common.f90 sourcefile~common.f90~3 common.f90 sourcefile~exec_dist.f90->sourcefile~common.f90~3 sourcefile~distributed.f90~2 distributed.f90 sourcefile~exec_dist.f90->sourcefile~distributed.f90~2 sourcefile~sendrecv.f90~2 sendrecv.f90 sourcefile~exec_dist.f90->sourcefile~sendrecv.f90~2 sourcefile~tdsops.f90 tdsops.f90 sourcefile~exec_dist.f90->sourcefile~tdsops.f90 sourcefile~distributed.f90~2->sourcefile~common.f90 sourcefile~sendrecv.f90~2->sourcefile~common.f90 sourcefile~tdsops.f90->sourcefile~common.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~tdsops.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~exec_dist.f90~~AfferentGraph sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_exec_dist use cudafor use mpi use m_common , only : dp use m_cuda_common , only : SZ use m_cuda_kernels_dist , only : der_univ_dist , der_univ_subs , & transeq_3fused_dist , transeq_3fused_subs use m_cuda_sendrecv , only : sendrecv_fields , sendrecv_3fields use m_cuda_tdsops , only : cuda_tdsops_t implicit none contains subroutine exec_dist_tds_compact ( & du , u , u_recv_s , u_recv_e , du_send_s , du_send_e , du_recv_s , du_recv_e , & tdsops , nproc , pprev , pnext , blocks , threads & ) implicit none ! du = d(u) real ( dp ), device , dimension (:, :, :), intent ( out ) :: du real ( dp ), device , dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care the data they pass back real ( dp ), device , dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e type ( cuda_tdsops_t ), intent ( in ) :: tdsops integer , intent ( in ) :: nproc , pprev , pnext type ( dim3 ), intent ( in ) :: blocks , threads integer :: n_data n_data = SZ * 1 * blocks % x call der_univ_dist <<< blocks , threads >>> ( & !& du , du_send_s , du_send_e , u , u_recv_s , u_recv_e , & tdsops % n_tds , tdsops % n_rhs , & tdsops % coeffs_s_dev , tdsops % coeffs_e_dev , tdsops % coeffs_dev , & tdsops % dist_fw_dev , tdsops % dist_bw_dev , tdsops % dist_af_dev & ) ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) call der_univ_subs <<< blocks , threads >>> ( & !& du , du_recv_s , du_recv_e , tdsops % n_tds , & tdsops % dist_sa_dev , tdsops % dist_sc_dev , tdsops % stretch_dev & ) end subroutine exec_dist_tds_compact subroutine exec_dist_transeq_3fused ( & r_du , u , u_recv_s , u_recv_e , v , v_recv_s , v_recv_e , & dud , d2u , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , nu , nproc , pprev , pnext , & blocks , threads & ) implicit none ! r_du = -1/2*(v*d1(u) + d1(u*v)) + nu*d2(u) !> The result array, it is also used as temporary storage real ( dp ), device , dimension (:, :, :), intent ( out ) :: r_du real ( dp ), device , dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e real ( dp ), device , dimension (:, :, :), intent ( in ) :: v , v_recv_s , v_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care the data they pass back real ( dp ), device , dimension (:, :, :), intent ( out ) :: dud , d2u real ( dp ), device , dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e type ( cuda_tdsops_t ), intent ( in ) :: tdsops_du , tdsops_dud , tdsops_d2u real ( dp ), intent ( in ) :: nu integer , intent ( in ) :: nproc , pprev , pnext type ( dim3 ), intent ( in ) :: blocks , threads integer :: n_data n_data = SZ * 1 * blocks % x call transeq_3fused_dist <<< blocks , threads >>> ( & !& r_du , dud , d2u , & du_send_s , du_send_e , & dud_send_s , dud_send_e , & d2u_send_s , d2u_send_e , & u , u_recv_s , u_recv_e , & v , v_recv_s , v_recv_e , & tdsops_du % n_tds , tdsops_du % n_rhs , & tdsops_du % coeffs_s_dev , tdsops_du % coeffs_e_dev , tdsops_du % coeffs_dev , & tdsops_du % dist_fw_dev , tdsops_du % dist_bw_dev , tdsops_du % dist_af_dev , & tdsops_dud % coeffs_s_dev , tdsops_dud % coeffs_e_dev , & tdsops_dud % coeffs_dev , tdsops_dud % dist_fw_dev , tdsops_dud % dist_bw_dev , & tdsops_dud % dist_af_dev , & tdsops_d2u % coeffs_s_dev , tdsops_d2u % coeffs_e_dev , & tdsops_d2u % coeffs_dev , tdsops_d2u % dist_fw_dev , tdsops_d2u % dist_bw_dev , & tdsops_d2u % dist_af_dev & ) ! halo exchange for 2x2 systems call sendrecv_3fields ( & du_recv_s , du_recv_e , dud_recv_s , dud_recv_e , & d2u_recv_s , d2u_recv_e , & du_send_s , du_send_e , dud_send_s , dud_send_e , & d2u_send_s , d2u_send_e , & n_data , nproc , pprev , pnext & ) call transeq_3fused_subs <<< blocks , threads >>> ( & !& r_du , v , dud , d2u , & du_recv_s , du_recv_e , dud_recv_s , dud_recv_e , d2u_recv_s , d2u_recv_e , & tdsops_du % n_tds , nu , & tdsops_du % dist_sa_dev , tdsops_du % dist_sc_dev , tdsops_du % stretch_dev , & tdsops_dud % dist_sa_dev , tdsops_dud % dist_sc_dev , tdsops_dud % stretch_dev , & tdsops_d2u % dist_sa_dev , tdsops_d2u % dist_sc_dev , tdsops_d2u % stretch_dev , & tdsops_d2u % stretch_correct_dev & ) end subroutine exec_dist_transeq_3fused end module m_cuda_exec_dist","tags":"","url":"sourcefile/exec_dist.f90.html"},{"title":"poisson_fft.f90 – x3d2","text":"This file depends on sourcefile~~poisson_fft.f90~2~~EfferentGraph sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~common.f90 common.f90 sourcefile~poisson_fft.f90~2->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~poisson_fft.f90~2->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~spectral_processing.f90~2 spectral_processing.f90 sourcefile~poisson_fft.f90~2->sourcefile~spectral_processing.f90~2 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~poisson_fft.f90~2->sourcefile~tdsops.f90~2 sourcefile~allocator.f90~2->sourcefile~common.f90 sourcefile~allocator.f90~2->sourcefile~field.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~allocator.f90~2->sourcefile~allocator.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~spectral_processing.f90~2->sourcefile~common.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~poisson_fft.f90~2~~AfferentGraph sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_poisson_fft use iso_c_binding , only : c_loc , c_ptr , c_f_pointer , c_int , c_float , & c_double_complex , c_float_complex use iso_fortran_env , only : stderr => error_unit use cudafor use cufftXt use cufft use mpi use m_common , only : dp , CELL , is_sp use m_field , only : field_t use m_mesh use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : dirps_t use m_cuda_allocator , only : cuda_field_t use m_cuda_spectral , only : memcpy3D , memcpy3D_with_transpose , & memcpy3D_with_transpose_back , & process_spectral_000 , process_spectral_010 , & process_spectral_110 , & enforce_periodicity_x , undo_periodicity_x , & enforce_periodicity_y , undo_periodicity_y , & process_spectral_010_fw , & process_spectral_010_poisson , & process_spectral_010_bw implicit none type , extends ( poisson_fft_t ) :: cuda_poisson_fft_t !! FFT based Poisson solver !> Local domain sized array storing the spectral equivalence constants complex ( dp ), device , allocatable , dimension (:, :, :) :: waves_dev !> Wave numbers in x, y, and z real ( dp ), device , allocatable , dimension (:) :: ax_dev , bx_dev , & ay_dev , by_dev , & az_dev , bz_dev !> Stretching operator matrices stores real ( dp ), device , allocatable , dimension (:, :, :, :) :: & store_a_odd_re_dev , store_a_odd_im_dev , & store_a_even_re_dev , store_a_even_im_dev , & store_a_re_dev , store_a_im_dev !> Stretching operator matrices real ( dp ), device , allocatable , dimension (:, :, :, :) :: & a_odd_re_dev , a_odd_im_dev , a_even_re_dev , a_even_im_dev , & a_re_dev , a_im_dev !> Forward and backward FFT transform plans integer :: plan3D_fw , plan3D_bw !> Flag to indicate whether cuFFTMp is used logical :: use_cufftmp = . true . !> cuFFTMp object manages decomposition and data storage type ( cudaLibXtDesc ), pointer :: xtdesc !> Standard cuFFT storage complex ( dp ), device , allocatable , dimension (:, :, :) :: c_dev !> cuFFT real workspace (input/output of R2C/C2R) real ( dp ), device , allocatable , dimension (:, :, :) :: r_dev contains procedure :: fft_forward => fft_forward_cuda procedure :: fft_forward_010 => fft_forward_cuda procedure :: fft_forward_100 => fft_forward_100_cuda procedure :: fft_forward_110 => fft_forward_cuda procedure :: fft_backward => fft_backward_cuda procedure :: fft_backward_010 => fft_backward_cuda procedure :: fft_backward_100 => fft_backward_100_cuda procedure :: fft_backward_110 => fft_backward_cuda procedure :: fft_postprocess_000 => fft_postprocess_000_cuda procedure :: fft_postprocess_010 => fft_postprocess_010_cuda procedure :: fft_postprocess_100 => fft_postprocess_100_cuda procedure :: fft_postprocess_110 => fft_postprocess_110_cuda procedure :: enforce_periodicity_x => enforce_periodicity_x_cuda procedure :: undo_periodicity_x => undo_periodicity_x_cuda procedure :: enforce_periodicity_y => enforce_periodicity_y_cuda procedure :: undo_periodicity_y => undo_periodicity_y_cuda end type cuda_poisson_fft_t interface cuda_poisson_fft_t module procedure init end interface cuda_poisson_fft_t ! Explicit C interfaces for cuFFT functions that nvfortran has trouble with interface integer ( c_int ) function cufftExecR2C_C ( plan , idata , odata ) & bind ( C , name = 'cufftExecR2C' ) use iso_c_binding integer ( c_int ), value :: plan type ( c_ptr ), value :: idata type ( c_ptr ), value :: odata end function cufftExecR2C_C integer ( c_int ) function cufftExecC2R_C ( plan , idata , odata ) & bind ( C , name = 'cufftExecC2R' ) use iso_c_binding integer ( c_int ), value :: plan type ( c_ptr ), value :: idata type ( c_ptr ), value :: odata end function cufftExecC2R_C end interface private :: init , create_fft_plan contains subroutine create_fft_plan ( plan , use_cufftmp , nx , ny , nz , & plan_type , is_root , plan_name ) !! Helper subroutine to create FFT plan with automatic cuFFTMp fallback implicit none integer , intent ( inout ) :: plan logical , intent ( inout ) :: use_cufftmp integer , intent ( in ) :: nx , ny , nz , plan_type logical , intent ( in ) :: is_root character ( * ), intent ( in ) :: plan_name integer :: ierr integer ( int_ptr_kind ()) :: worksize logical :: cufftmp_failed cufftmp_failed = . false . ierr = cufftCreate ( plan ) if ( use_cufftmp ) then ! Try to attach MPI communicator for cuFFTMp ierr = cufftMpAttachComm ( plan , CUFFT_COMM_MPI , MPI_COMM_WORLD ) if ( ierr /= 0 ) then if ( is_root ) then print * , 'cuFFTMp: MPI attach failed (error ' , ierr , ')' end if cufftmp_failed = . true . else ! MPI attach succeeded, create the plan ierr = cufftMakePlan3D ( plan , nz , ny , nx , plan_type , worksize ) if ( ierr /= 0 ) then if ( is_root ) then print * , 'cuFFTMp: Plan creation failed (error ' , ierr , ')' end if cufftmp_failed = . true . end if end if ! if cuFFTMp failed at any stage, fall back to cuFFT if ( cufftmp_failed ) then if ( is_root ) then print * , 'Falling back to cuFFT' end if use_cufftmp = . false . ierr = cufftDestroy ( plan ) ierr = cufftCreate ( plan ) end if end if ! create plan with cuFFT if (. not . use_cufftmp ) then ierr = cufftMakePlan3D ( plan , nz , ny , nx , plan_type , worksize ) if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop trim ( plan_name ) // ' 3D FFT plan generation failed' end if end if end subroutine create_fft_plan function init ( mesh , xdirps , ydirps , zdirps , lowmem ) & result ( poisson_fft ) implicit none type ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps logical , optional , intent ( in ) :: lowmem type ( cuda_poisson_fft_t ) :: poisson_fft integer :: nx , ny , nz integer :: ierr integer ( int_ptr_kind ()) :: worksize integer :: dims_glob ( 3 ), dims_loc ( 3 ), n_spec ( 3 ), n_sp_st ( 3 ) logical :: periodic_x , periodic_y , periodic_z logical :: fw_was_cufftmp ! Get periodicity from mesh BEFORE base_init periodic_x = mesh % grid % periodic_BC ( 1 ) periodic_y = mesh % grid % periodic_BC ( 2 ) periodic_z = mesh % grid % periodic_BC ( 3 ) ! 1D decomposition along Z in real domain, and along Y in spectral space if ( mesh % par % nproc_dir ( 2 ) /= 1 ) print * , 'nproc_dir in y-dir must be 1' ! Work out the spectral dimensions in the permuted state dims_glob = mesh % get_global_dims ( CELL ) dims_loc = mesh % get_dims ( CELL ) if ((. not . periodic_x ) . and . periodic_y . and . periodic_z ) then ! 100 case: Non-Periodic X, Periodic Y, Periodic Z n_spec ( 1 ) = dims_loc ( 1 ) / 2 + 1 n_spec ( 2 ) = dims_loc ( 2 ) / mesh % par % nproc_dir ( 3 ) n_spec ( 3 ) = dims_glob ( 3 ) n_sp_st ( 1 ) = 0 n_sp_st ( 2 ) = dims_loc ( 2 ) / mesh % par % nproc_dir ( 3 ) * mesh % par % nrank_dir ( 3 ) n_sp_st ( 3 ) = 0 else if ( periodic_x . and . (. not . periodic_y ) . and . periodic_z ) then ! 010 case: Periodic X, Non-Periodic Y, Periodic Z n_spec ( 1 ) = dims_loc ( 1 ) / 2 + 1 n_spec ( 2 ) = dims_loc ( 2 ) / mesh % par % nproc_dir ( 3 ) n_spec ( 3 ) = dims_glob ( 3 ) n_sp_st ( 1 ) = 0 n_sp_st ( 2 ) = dims_loc ( 2 ) / mesh % par % nproc_dir ( 3 ) * mesh % par % nrank_dir ( 3 ) n_sp_st ( 3 ) = 0 else if ((. not . periodic_x ) . and . (. not . periodic_y ) . and . periodic_z ) then ! 110 case: Non-Periodic X, Non-Periodic Y, Periodic Z ! Standard spectral layout (no transpose needed) n_spec ( 1 ) = dims_loc ( 1 ) / 2 + 1 ! nx/2+1 (R2C) n_spec ( 2 ) = dims_loc ( 2 ) / mesh % par % nproc_dir ( 3 ) ! ny n_spec ( 3 ) = dims_glob ( 3 ) ! nz n_sp_st ( 1 ) = dims_loc ( 1 ) / mesh % par % nproc_dir ( 3 ) * mesh % par % nrank_dir ( 3 ) n_sp_st ( 2 ) = dims_loc ( 2 ) / mesh % par % nproc_dir ( 3 ) * mesh % par % nrank_dir ( 3 ) n_sp_st ( 3 ) = 0 else if ( periodic_x . and . periodic_y . and . periodic_z ) then ! 000 case: Periodic X, Periodic Y, Periodic Z ! Standard spectral layout (no transpose needed) n_spec ( 1 ) = dims_loc ( 1 ) / 2 + 1 n_spec ( 2 ) = dims_loc ( 2 ) / mesh % par % nproc_dir ( 3 ) n_spec ( 3 ) = dims_glob ( 3 ) n_sp_st ( 1 ) = 0 n_sp_st ( 2 ) = dims_loc ( 2 ) / mesh % par % nproc_dir ( 3 ) * mesh % par % nrank_dir ( 3 ) n_sp_st ( 3 ) = 0 else error stop \"not implemented yet!!\" end if call poisson_fft % base_init ( mesh , xdirps , ydirps , zdirps , n_spec , n_sp_st ) nx = poisson_fft % nx_glob ny = poisson_fft % ny_glob nz = poisson_fft % nz_glob allocate ( poisson_fft % waves_dev ( poisson_fft % nx_spec , & poisson_fft % ny_spec , & poisson_fft % nz_spec )) poisson_fft % waves_dev = poisson_fft % waves allocate ( poisson_fft % ax_dev ( nx ), poisson_fft % bx_dev ( nx )) allocate ( poisson_fft % ay_dev ( ny ), poisson_fft % by_dev ( ny )) allocate ( poisson_fft % az_dev ( nz ), poisson_fft % bz_dev ( nz )) poisson_fft % ax_dev = poisson_fft % ax ; poisson_fft % bx_dev = poisson_fft % bx poisson_fft % ay_dev = poisson_fft % ay ; poisson_fft % by_dev = poisson_fft % by poisson_fft % az_dev = poisson_fft % az ; poisson_fft % bz_dev = poisson_fft % bz ! will store the a matrix coefficients in GPU memory if (.not. lowmem) ! and do a device-to-device copy at each iter. Otherwise copy from host. ! lowmem is .false. by default if ( present ( lowmem )) poisson_fft % lowmem = lowmem ! Try cuFFTMp first, with automatic fallback to cuFFT if not supported poisson_fft % use_cufftmp = . true . ! if stretching in y is 'centred' or 'top-bottom' if ( poisson_fft % stretched_y . and . poisson_fft % stretched_y_sym ) then poisson_fft % a_odd_re_dev = poisson_fft % a_odd_re poisson_fft % a_odd_im_dev = poisson_fft % a_odd_im poisson_fft % a_even_re_dev = poisson_fft % a_even_re poisson_fft % a_even_im_dev = poisson_fft % a_even_im if (. not . poisson_fft % lowmem ) then poisson_fft % store_a_odd_re_dev = poisson_fft % a_odd_re poisson_fft % store_a_odd_im_dev = poisson_fft % a_odd_im poisson_fft % store_a_even_re_dev = poisson_fft % a_even_re poisson_fft % store_a_even_im_dev = poisson_fft % a_even_im end if !! if stretching in y is 'bottom' else if ( poisson_fft % stretched_y . and . & (. not . poisson_fft % stretched_y_sym )) then poisson_fft % a_re_dev = poisson_fft % a_re poisson_fft % a_im_dev = poisson_fft % a_im if (. not . poisson_fft % lowmem ) then poisson_fft % store_a_re_dev = poisson_fft % a_re poisson_fft % store_a_im_dev = poisson_fft % a_im end if end if ! Create forward FFT plan with automatic cuFFTMp detection/fallback if ( is_sp ) then call create_fft_plan ( poisson_fft % plan3D_fw , & poisson_fft % use_cufftmp , & nx , ny , nz , CUFFT_R2C , & mesh % par % is_root (), 'Forward' ) else call create_fft_plan ( poisson_fft % plan3D_fw , & poisson_fft % use_cufftmp , & nx , ny , nz , CUFFT_D2Z , & mesh % par % is_root (), 'Forward' ) end if fw_was_cufftmp = poisson_fft % use_cufftmp ! Create backward FFT plan with automatic cuFFTMp detection/fallback if ( is_sp ) then call create_fft_plan ( poisson_fft % plan3D_bw , & poisson_fft % use_cufftmp , & nx , ny , nz , CUFFT_C2R , & mesh % par % is_root (), 'Backward' ) else call create_fft_plan ( poisson_fft % plan3D_bw , & poisson_fft % use_cufftmp , & nx , ny , nz , CUFFT_Z2D , & mesh % par % is_root (), 'Backward' ) end if ! If backward plan forced fallback, rebuild forward plan in cuFFT mode too. if ( fw_was_cufftmp . and . (. not . poisson_fft % use_cufftmp )) then ierr = cufftDestroy ( poisson_fft % plan3D_fw ) if ( is_sp ) then call create_fft_plan ( poisson_fft % plan3D_fw , & poisson_fft % use_cufftmp , & nx , ny , nz , CUFFT_R2C , & mesh % par % is_root (), 'Forward' ) else call create_fft_plan ( poisson_fft % plan3D_fw , & poisson_fft % use_cufftmp , & nx , ny , nz , CUFFT_D2Z , & mesh % par % is_root (), 'Forward' ) end if end if ! Allocate storage - cuFFTMp uses xtdesc, cuFFT uses c_dev if ( poisson_fft % use_cufftmp ) then ! allocate storage for cuFFTMp ierr = cufftXtMalloc ( poisson_fft % plan3D_fw , poisson_fft % xtdesc , & CUFFT_XT_FORMAT_INPLACE ) if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'cufftXtMalloc failed' end if else ! allocate storage for cuFFT allocate ( poisson_fft % c_dev ( poisson_fft % nx_spec , & poisson_fft % ny_spec , & poisson_fft % nz_spec )) allocate ( poisson_fft % r_dev ( poisson_fft % nx_loc , & poisson_fft % ny_loc , & poisson_fft % nz_loc )) end if ! Print final status if ( mesh % par % is_root ()) then if ( poisson_fft % use_cufftmp ) then print * , 'Using cuFFTMp for FFT' else print * , 'Using cuFFT for FFT' end if end if end function init subroutine fft_forward_100_cuda ( self , f ) !! Forward FFT for non-periodic-X case !! We transpose X<->Y so that the non-periodic direction becomes the !! \"Y\" direction in the transposed space, then use the same FFT approach as 010 implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), device , pointer :: padded_dev (:, :, :), d_dev (:, :, :) type ( cudaXtDesc ), pointer :: descriptor integer :: tsize , ierr type ( dim3 ) :: blocks , threads select type ( f ) type is ( cuda_field_t ) padded_dev => f % data_d end select if ( self % use_cufftmp ) then call c_f_pointer ( self % xtdesc % descriptor , descriptor ) ! For 100 case with transposed FFT plan (ny, nx, nz): ! The descriptor has shape (ny + 2, nx, nz) for R2C output call c_f_pointer ( descriptor % data ( 1 ), d_dev , & [ 2 * ( self % ny_loc / 2 + 1 ), self % nx_loc , self % nz_loc ]) tsize = 16 blocks = dim3 (( self % nx_loc - 1 ) / tsize + 1 , self % nz_loc , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! Copy with transpose: src(nx,ny,nz) -> dst(ny,nx,nz) call memcpy3D_with_transpose <<< blocks , threads >>> ( & !& d_dev , padded_dev , self % nx_loc , self % ny_loc , self % nz_loc & ) ierr = cufftXtExecDescriptor ( self % plan3D_fw , self % xtdesc , self % xtdesc , & CUFFT_FORWARD ) else ! using standard cuFFT with explicit real workspace call c_f_pointer ( c_loc ( self % r_dev ), d_dev , & [ self % ny_loc , self % nx_loc , self % nz_loc ]) tsize = 16 blocks = dim3 (( self % nx_loc - 1 ) / tsize + 1 , self % nz_loc , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! copy with transpose: src(nx,ny,nz) -> dst(ny,nx,nz) call memcpy3D_with_transpose <<< blocks , threads >>> ( & !& d_dev , padded_dev , self % nx_loc , self % ny_loc , self % nz_loc & ) #ifdef SINGLE_PREC ierr = cufftExecR2C_C ( self % plan3D_fw , c_loc ( self % r_dev ), & c_loc ( self % c_dev )) #else ierr = cufftExecD2Z ( self % plan3D_fw , self % r_dev , self % c_dev ) #endif end if if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'Forward 3D FFT execution failed (100 case)' end if end subroutine fft_forward_100_cuda subroutine fft_backward_100_cuda ( self , f ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), device , pointer :: padded_dev (:, :, :), d_dev (:, :, :) type ( cudaXtDesc ), pointer :: descriptor integer :: tsize , ierr type ( dim3 ) :: blocks , threads select type ( f ) type is ( cuda_field_t ) padded_dev => f % data_d end select if ( self % use_cufftmp ) then ierr = cufftXtExecDescriptor ( self % plan3D_bw , self % xtdesc , self % xtdesc , & CUFFT_INVERSE ) else ! using standard cuFFT with explicit real workspace #ifdef SINGLE_PREC ierr = cufftExecC2R_C ( self % plan3D_bw , c_loc ( self % c_dev ), & c_loc ( self % r_dev )) #else ierr = cufftExecZ2D ( self % plan3D_bw , self % c_dev , self % r_dev ) #endif end if if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'Backward 3D FFT execution failed (100 case)' end if if ( self % use_cufftmp ) then call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), d_dev , & [ 2 * ( self % ny_loc / 2 + 1 ), self % nx_loc , self % nz_loc ]) tsize = 16 blocks = dim3 (( self % nx_loc - 1 ) / tsize + 1 , self % nz_loc , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! Copy with transpose back: src(ny,nx,nz) -> dst(nx,ny,nz) call memcpy3D_with_transpose_back <<< blocks , threads >>> ( & !& padded_dev , d_dev , self % nx_loc , self % ny_loc , self % nz_loc & ) else ! ensure untouched padded/halo entries are deterministic padded_dev = 0._dp ! cast r_dev as (ny, nx, nz) real buffer call c_f_pointer ( c_loc ( self % r_dev ), d_dev , & [ self % ny_loc , self % nx_loc , self % nz_loc ]) tsize = 16 blocks = dim3 (( self % nx_loc - 1 ) / tsize + 1 , self % nz_loc , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! copy with transpose back: src(ny,nx,nz) -> dst(nx,ny,nz) call memcpy3D_with_transpose_back <<< blocks , threads >>> ( & !& padded_dev , d_dev , self % nx_loc , self % ny_loc , self % nz_loc & ) end if end subroutine fft_backward_100_cuda subroutine fft_forward_cuda ( self , f ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), device , pointer :: padded_dev (:, :, :), d_dev (:, :, :) type ( cudaXtDesc ), pointer :: descriptor integer :: tsize , ierr type ( dim3 ) :: blocks , threads select type ( f ) type is ( cuda_field_t ) padded_dev => f % data_d end select if ( self % use_cufftmp ) then ! using cuFFTMp ! tsize is different than SZ, because here we work on a 3D Cartesian ! data structure, and free to specify any suitable thread/block size. tsize = 16 blocks = dim3 (( self % ny_loc - 1 ) / tsize + 1 , self % nz_loc , 1 ) threads = dim3 ( tsize , 1 , 1 ) call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), d_dev , & [ 2 * ( self % nx_loc / 2 + 1 ), self % ny_loc , self % nz_loc ]) call memcpy3D <<< blocks , threads >>> ( & !& d_dev , padded_dev , self % nx_loc , self % ny_loc , self % nz_loc & ) ierr = cufftXtExecDescriptor ( self % plan3D_fw , self % xtdesc , self % xtdesc , & CUFFT_FORWARD ) else ! using standard cuFFT with explicit real workspace call c_f_pointer ( c_loc ( self % r_dev ), d_dev , & [ self % nx_loc , self % ny_loc , self % nz_loc ]) tsize = 16 blocks = dim3 (( self % ny_loc - 1 ) / tsize + 1 , self % nz_loc , 1 ) threads = dim3 ( tsize , 1 , 1 ) call memcpy3D <<< blocks , threads >>> ( & !& d_dev , padded_dev , self % nx_loc , self % ny_loc , self % nz_loc & ) #ifdef SINGLE_PREC ierr = cufftExecR2C_C ( self % plan3D_fw , c_loc ( self % r_dev ), & c_loc ( self % c_dev )) #else ierr = cufftExecD2Z ( self % plan3D_fw , self % r_dev , self % c_dev ) #endif end if if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'Forward 3D FFT execution failed' end if end subroutine fft_forward_cuda subroutine fft_backward_cuda ( self , f ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), device , pointer :: padded_dev (:, :, :), d_dev (:, :, :) type ( cudaXtDesc ), pointer :: descriptor integer :: tsize , ierr type ( dim3 ) :: blocks , threads select type ( f ) type is ( cuda_field_t ) padded_dev => f % data_d end select if ( self % use_cufftmp ) then ! using cuFFTMp ierr = cufftXtExecDescriptor ( self % plan3D_bw , self % xtdesc , self % xtdesc , & CUFFT_INVERSE ) else ! using standard cuFFT with explicit real workspace #ifdef SINGLE_PREC ierr = cufftExecC2R_C ( self % plan3D_bw , c_loc ( self % c_dev ), & c_loc ( self % r_dev )) #else ierr = cufftExecZ2D ( self % plan3D_bw , self % c_dev , self % r_dev ) #endif end if if ( ierr /= 0 ) then write ( stderr , * ), 'cuFFT Error Code: ' , ierr error stop 'Backward 3D FFT execution failed' end if if ( self % use_cufftmp ) then ! cuFFTMp path: cast xtdesc as (nx+2, ny, nz) real buffer call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), d_dev , & [ 2 * ( self % nx_loc / 2 + 1 ), self % ny_loc , self % nz_loc ]) else ! ensure untouched padded/halo entries are deterministic padded_dev = 0._dp ! cuFFT path: cast r_dev as (nx, ny, nz) real buffer call c_f_pointer ( c_loc ( self % r_dev ), d_dev , & [ self % nx_loc , self % ny_loc , self % nz_loc ]) end if tsize = 16 blocks = dim3 (( self % ny_loc - 1 ) / tsize + 1 , self % nz_loc , 1 ) threads = dim3 ( tsize , 1 , 1 ) call memcpy3D <<< blocks , threads >>> ( & !& padded_dev , d_dev , self % nx_loc , self % ny_loc , self % nz_loc & ) end subroutine fft_backward_cuda subroutine fft_postprocess_000_cuda ( self ) implicit none class ( cuda_poisson_fft_t ) :: self type ( cudaXtDesc ), pointer :: descriptor complex ( dp ), device , dimension (:, :, :), pointer :: c_dev type ( dim3 ) :: blocks , threads integer :: tsize ! tsize is different than SZ, because here we work on a 3D Cartesian ! data structure, and free to specify any suitable thread/block size. tsize = 16 blocks = dim3 (( self % ny_spec - 1 ) / tsize + 1 , self % nz_spec , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! Get pointer to the appropriate FFT data storage if ( self % use_cufftmp ) then ! cuFFTMp path: get pointer from xtdesc call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) else ! cuFFT path: get pointer to self%c_dev call c_f_pointer ( c_loc ( self % c_dev ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) end if ! Postprocess div_u in spectral space call process_spectral_000 <<< blocks , threads >>> ( & !& c_dev , self % waves_dev , self % nx_spec , self % ny_spec , self % y_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax_dev , self % bx_dev , self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) end subroutine fft_postprocess_000_cuda subroutine fft_postprocess_100_cuda ( self ) implicit none class ( cuda_poisson_fft_t ) :: self type ( cudaXtDesc ), pointer :: descriptor complex ( dp ), device , dimension (:, :, :), pointer :: c_dev type ( dim3 ) :: blocks , threads integer :: tsize ! Get pointer to the appropriate FFT data storage if ( self % use_cufftmp ) then call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) else call c_f_pointer ( c_loc ( self % c_dev ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) end if ! tsize is different than SZ, because here we work on a 3D Cartesian ! data structure, and free to specify any suitable thread/block size. tsize = 16 blocks = dim3 (( self % nx_spec - 1 ) / tsize + 1 , self % nz_spec , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! Call process_spectral_010 with swapped parameters: ! - Swap nx <-> ny for grid sizes ! - Swap ax,bx <-> ay,by for wave coefficients ! - Use x_sp_st instead of y_sp_st for the offset call process_spectral_010 <<< blocks , threads >>> ( & !& c_dev , self % waves_dev , & self % nx_spec , self % ny_spec , self % x_sp_st , & ! spectral dims and offset self % ny_glob , self % nx_glob , self % nz_glob , & ! SWAP nx <-> ny self % ay_dev , self % by_dev , & ! First dim uses Y coefficients (was periodic Y) self % ax_dev , self % bx_dev , & ! Second dim uses X coefficients (non-periodic X) self % az_dev , self % bz_dev & ! Third dim uses Z coefficients (unchanged) ) end subroutine fft_postprocess_100_cuda subroutine fft_postprocess_010_cuda ( self ) implicit none class ( cuda_poisson_fft_t ) :: self type ( cudaXtDesc ), pointer :: descriptor complex ( dp ), device , dimension (:, :, :), pointer :: c_dev type ( dim3 ) :: blocks , threads integer :: tsize , off , inc ! tsize is different than SZ, because here we work on a 3D Cartesian ! data structure, and free to specify any suitable thread/block size. tsize = 16 blocks = dim3 (( self % nx_spec - 1 ) / tsize + 1 , self % nz_spec , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! Get pointer to the appropriate FFT data storage if ( self % use_cufftmp ) then ! cuFFTMp path: get pointer from xtdesc call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) else ! cuFFT path: get pointer to self%c_dev call c_f_pointer ( c_loc ( self % c_dev ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) end if ! Postprocess div_u in spectral space if (. not . self % stretched_y ) then call process_spectral_010 <<< blocks , threads >>> ( & !& c_dev , self % waves_dev , self % nx_spec , self % ny_spec , self % y_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax_dev , self % bx_dev , self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) else call process_spectral_010_fw <<< blocks , threads >>> ( & !& c_dev , self % nx_spec , self % ny_spec , self % y_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax_dev , self % bx_dev , self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) ! if stretching in y is 'centred' or 'top-bottom' if ( self % stretched_y_sym ) then ! copy from host to device if lowmem else from device stores if ( self % lowmem ) then self % a_odd_re_dev = self % a_odd_re self % a_odd_im_dev = self % a_odd_im self % a_even_re_dev = self % a_even_re self % a_even_im_dev = self % a_even_im else self % a_odd_re_dev = self % store_a_odd_re_dev self % a_odd_im_dev = self % store_a_odd_im_dev self % a_even_re_dev = self % store_a_even_re_dev self % a_even_im_dev = self % store_a_even_im_dev end if ! start from the first odd entry and continue with odd ones off = 0 inc = 2 call process_spectral_010_poisson <<< blocks , threads >>> ( & !& c_dev , self % a_odd_re_dev , self % a_odd_im_dev , off , inc , & self % nx_spec , self % ny_spec / 2 , & self % nx_glob , self % ny_glob , self % nz_glob & ) ! start from the first even entry and continue with even ones off = 1 call process_spectral_010_poisson <<< blocks , threads >>> ( & !& c_dev , self % a_even_re_dev , self % a_even_im_dev , off , inc , & self % nx_spec , self % ny_spec / 2 , & self % nx_glob , self % ny_glob , self % nz_glob & ) !! if stretching in y is 'bottom' else ! copy from host to device if lowmem else from device stores if ( self % lowmem ) then self % a_re_dev = self % a_re self % a_im_dev = self % a_im else self % a_re_dev = self % store_a_re_dev self % a_im_dev = self % store_a_im_dev end if ! start from the first entry and increment 1 off = 0 inc = 1 call process_spectral_010_poisson <<< blocks , threads >>> ( & !& c_dev , self % a_re_dev , self % a_im_dev , off , inc , & self % nx_spec , self % ny_spec , & self % nx_glob , self % ny_glob , self % nz_glob & ) end if call process_spectral_010_bw <<< blocks , threads >>> ( & !& c_dev , self % nx_spec , self % ny_spec , self % y_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax_dev , self % bx_dev , self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) end if end subroutine fft_postprocess_010_cuda subroutine fft_postprocess_110_cuda ( self ) implicit none class ( cuda_poisson_fft_t ) :: self type ( cudaXtDesc ), pointer :: descriptor complex ( dp ), device , dimension (:, :, :), pointer :: c_dev type ( dim3 ) :: blocks , threads integer :: tsize , off , inc ! Get pointer to the appropriate FFT data storage if ( self % use_cufftmp ) then call c_f_pointer ( self % xtdesc % descriptor , descriptor ) call c_f_pointer ( descriptor % data ( 1 ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) else call c_f_pointer ( c_loc ( self % c_dev ), c_dev , & [ self % nx_spec , self % ny_spec , self % nz_spec ]) end if ! tsize is different than SZ, because here we work on a 3D Cartesian ! data structure, and free to specify any suitable thread/block size. tsize = 16 blocks = dim3 (( self % nx_spec - 1 ) / tsize + 1 , self % nz_spec , 1 ) threads = dim3 ( tsize , 1 , 1 ) ! Postprocess div_u in spectral space if (. not . self % stretched_y ) then call process_spectral_110 <<< blocks , threads >>> ( & !& c_dev , self % waves_dev , & self % nx_spec , self % ny_spec , & self % x_sp_st , self % y_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax_dev , self % bx_dev , & self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) else call process_spectral_010_fw <<< blocks , threads >>> ( & !& c_dev , self % nx_spec , self % ny_spec , self % y_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax_dev , self % bx_dev , self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) ! if stretching in y is 'centred' or 'top-bottom' if ( self % stretched_y_sym ) then ! copy from host to device if lowmem else from device stores if ( self % lowmem ) then self % a_odd_re_dev = self % a_odd_re self % a_odd_im_dev = self % a_odd_im self % a_even_re_dev = self % a_even_re self % a_even_im_dev = self % a_even_im else self % a_odd_re_dev = self % store_a_odd_re_dev self % a_odd_im_dev = self % store_a_odd_im_dev self % a_even_re_dev = self % store_a_even_re_dev self % a_even_im_dev = self % store_a_even_im_dev end if ! start from the first odd entry off = 0 ! and continue with odd ones inc = 2 call process_spectral_010_poisson <<< blocks , threads >>> ( & !& c_dev , self % a_odd_re_dev , self % a_odd_im_dev , off , inc , & self % nx_spec , self % ny_spec / 2 , & self % nx_glob , self % ny_glob , self % nz_glob & ) ! start from the first even entry, and continue with even ones off = 1 call process_spectral_010_poisson <<< blocks , threads >>> ( & !& c_dev , self % a_even_re_dev , self % a_even_im_dev , off , inc , & self % nx_spec , self % ny_spec / 2 , & self % nx_glob , self % ny_glob , self % nz_glob & ) !! if stretching in y is 'bottom' else ! copy from host to device if lowmem else from device stores if ( self % lowmem ) then self % a_re_dev = self % a_re self % a_im_dev = self % a_im else self % a_re_dev = self % store_a_re_dev self % a_im_dev = self % store_a_im_dev end if off = 0 inc = 1 ! start from the first entry and increment 1 call process_spectral_010_poisson <<< blocks , threads >>> ( & !& c_dev , self % a_re_dev , self % a_im_dev , off , inc , & self % nx_spec , self % ny_spec , & self % nx_glob , self % ny_glob , self % nz_glob & ) end if call process_spectral_010_bw <<< blocks , threads >>> ( & !& c_dev , self % nx_spec , self % ny_spec , self % y_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax_dev , self % bx_dev , self % ay_dev , self % by_dev , & self % az_dev , self % bz_dev & ) end if end subroutine fft_postprocess_110_cuda subroutine enforce_periodicity_x_cuda ( self , f_out , f_in ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in real ( dp ), device , pointer , dimension (:, :, :) :: f_out_dev , f_in_dev type ( dim3 ) :: blocks , threads select type ( f_out ) type is ( cuda_field_t ) f_out_dev => f_out % data_d end select select type ( f_in ) type is ( cuda_field_t ) f_in_dev => f_in % data_d end select blocks = dim3 ( self % nz_loc , 1 , 1 ) threads = dim3 ( self % ny_loc , 1 , 1 ) ! cuFFT path can consume stale padded/halo entries. if (. not . self % use_cufftmp ) f_out_dev = 0._dp call enforce_periodicity_x <<< blocks , threads >>> ( & !& f_out_dev , f_in_dev , self % nx_glob & ) end subroutine enforce_periodicity_x_cuda subroutine undo_periodicity_x_cuda ( self , f_out , f_in ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in real ( dp ), device , pointer , dimension (:, :, :) :: f_out_dev , f_in_dev type ( dim3 ) :: blocks , threads select type ( f_out ) type is ( cuda_field_t ) f_out_dev => f_out % data_d end select select type ( f_in ) type is ( cuda_field_t ) f_in_dev => f_in % data_d end select blocks = dim3 ( self % nz_loc , 1 , 1 ) threads = dim3 ( self % ny_loc , 1 , 1 ) ! cuFFT path can consume stale padded/halo entries. if (. not . self % use_cufftmp ) f_out_dev = 0._dp call undo_periodicity_x <<< blocks , threads >>> ( & !& f_out_dev , f_in_dev , self % nx_glob & ) end subroutine undo_periodicity_x_cuda subroutine enforce_periodicity_y_cuda ( self , f_out , f_in ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in real ( dp ), device , pointer , dimension (:, :, :) :: f_out_dev , f_in_dev type ( dim3 ) :: blocks , threads select type ( f_out ) type is ( cuda_field_t ) f_out_dev => f_out % data_d end select select type ( f_in ) type is ( cuda_field_t ) f_in_dev => f_in % data_d end select blocks = dim3 ( self % nz_loc , 1 , 1 ) threads = dim3 ( self % nx_loc , 1 , 1 ) ! cuFFT path can consume stale padded/halo entries. if (. not . self % use_cufftmp ) f_out_dev = 0._dp call enforce_periodicity_y <<< blocks , threads >>> ( & !& f_out_dev , f_in_dev , self % ny_glob & ) end subroutine enforce_periodicity_y_cuda subroutine undo_periodicity_y_cuda ( self , f_out , f_in ) implicit none class ( cuda_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in real ( dp ), device , pointer , dimension (:, :, :) :: f_out_dev , f_in_dev type ( dim3 ) :: blocks , threads select type ( f_out ) type is ( cuda_field_t ) f_out_dev => f_out % data_d end select select type ( f_in ) type is ( cuda_field_t ) f_in_dev => f_in % data_d end select blocks = dim3 ( self % nz_loc , 1 , 1 ) threads = dim3 ( self % nx_loc , 1 , 1 ) ! cuFFT path can consume stale padded/halo entries. if (. not . self % use_cufftmp ) f_out_dev = 0._dp call undo_periodicity_y <<< blocks , threads >>> ( & !& f_out_dev , f_in_dev , self % ny_glob & ) end subroutine undo_periodicity_y_cuda end module m_cuda_poisson_fft","tags":"","url":"sourcefile/poisson_fft.f90~2.html"},{"title":"thomas.f90 – x3d2","text":"This file depends on sourcefile~~thomas.f90~2~~EfferentGraph sourcefile~thomas.f90~2 thomas.f90 sourcefile~common.f90 common.f90 sourcefile~thomas.f90~2->sourcefile~common.f90 sourcefile~common.f90~2 common.f90 sourcefile~thomas.f90~2->sourcefile~common.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~thomas.f90~2~~AfferentGraph sourcefile~thomas.f90~2 thomas.f90 sourcefile~exec_thom.f90~2 exec_thom.f90 sourcefile~exec_thom.f90~2->sourcefile~thomas.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_omp_kernels_thom use m_common , only : dp use m_omp_common , only : SZ implicit none contains subroutine der_univ_thom ( du , u , n_tds , n_rhs , coeffs_s , coeffs_e , coeffs , & thom_f , thom_s , thom_w , strch ) implicit none real ( dp ), dimension (:, :), intent ( out ) :: du real ( dp ), dimension (:, :), intent ( in ) :: u integer , intent ( in ) :: n_tds , n_rhs real ( dp ), intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e ! start/end real ( dp ), intent ( in ), dimension (:) :: coeffs real ( dp ), intent ( in ), dimension (:) :: thom_f , thom_s , thom_w , strch integer :: i , j real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) ! Forward pass !$omp simd do i = 1 , SZ du ( i , 1 ) = coeffs_s ( 5 , 1 ) * u ( i , 1 ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 ) du ( i , 2 ) = coeffs_s ( 4 , 2 ) * u ( i , 1 ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 ) & - du ( i , 1 ) * thom_s ( 2 ) du ( i , 3 ) = coeffs_s ( 3 , 3 ) * u ( i , 1 ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 ) & - du ( i , 2 ) * thom_s ( 3 ) du ( i , 4 ) = coeffs_s ( 2 , 4 ) * u ( i , 1 ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 ) & - du ( i , 3 ) * thom_s ( 4 ) end do !$omp end simd do j = 5 , n_rhs - 4 !$omp simd do i = 1 , SZ du ( i , j ) = c_m4 * u ( i , j - 4 ) + c_m3 * u ( i , j - 3 ) & + c_m2 * u ( i , j - 2 ) + c_m1 * u ( i , j - 1 ) & + c_j * u ( i , j ) & + c_p1 * u ( i , j + 1 ) + c_p2 * u ( i , j + 2 ) & + c_p3 * u ( i , j + 3 ) + c_p4 * u ( i , j + 4 ) & - du ( i , j - 1 ) * thom_s ( j ) end do !$omp end simd end do !$omp simd do i = 1 , SZ j = n_rhs - 3 du ( i , j ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 1 ) * u ( i , j ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 ) & - du ( i , j - 1 ) * thom_s ( j ) j = n_rhs - 2 du ( i , j ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 2 ) * u ( i , j ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 ) & - du ( i , j - 1 ) * thom_s ( j ) j = n_rhs - 1 du ( i , j ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 3 ) * u ( i , j ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 ) & - du ( i , j - 1 ) * thom_s ( j ) j = n_rhs du ( i , j ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 ) & + coeffs_e ( 5 , 4 ) * u ( i , j ) & - du ( i , j - 1 ) * thom_s ( j ) end do !$omp end simd ! Backward pass !$omp simd do i = 1 , SZ du ( i , n_tds ) = du ( i , n_tds ) * thom_w ( n_tds ) * strch ( n_tds ) end do !$omp end simd do j = n_tds - 1 , 1 , - 1 !$omp simd do i = 1 , SZ ! du(j) = (du(j) - f*du(j+1)/strch(j))*w*strch(j) du ( i , j ) = ( du ( i , j ) * strch ( j ) - thom_f ( j ) * du ( i , j + 1 )) * thom_w ( j ) end do !$omp end simd end do end subroutine der_univ_thom subroutine der_univ_thom_per ( & du , u , n , coeffs , alpha , thom_f , thom_s , thom_w , thom_p , strch & ) implicit none real ( dp ), dimension (:, :), intent ( out ) :: du real ( dp ), dimension (:, :), intent ( in ) :: u integer , intent ( in ) :: n real ( dp ), intent ( in ), dimension (:) :: coeffs real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ), dimension (:) :: thom_f , thom_s , thom_w , thom_p , strch integer :: i , j integer :: jm4 , jm3 , jm2 , jm1 , jp1 , jp2 , jp3 , jp4 real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 real ( dp ), dimension ( SZ ) :: ss c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) ! Forward pass do j = 1 , n jm4 = modulo ( j - 5 , n ) + 1 jm3 = modulo ( j - 4 , n ) + 1 jm2 = modulo ( j - 3 , n ) + 1 jm1 = modulo ( j - 2 , n ) + 1 jp1 = modulo ( j - n , n ) + 1 jp2 = modulo ( j - n + 1 , n ) + 1 jp3 = modulo ( j - n + 2 , n ) + 1 jp4 = modulo ( j - n + 3 , n ) + 1 !$omp simd do i = 1 , SZ du ( i , j ) = c_m4 * u ( i , jm4 ) + c_m3 * u ( i , jm3 ) & + c_m2 * u ( i , jm2 ) + c_m1 * u ( i , jm1 ) & + c_j * u ( i , j ) & + c_p1 * u ( i , jp1 ) + c_p2 * u ( i , jp2 ) & + c_p3 * u ( i , jp3 ) + c_p4 * u ( i , jp4 ) & - du ( i , jm1 ) * thom_s ( j ) end do !$omp end simd end do ! Backward pass !$omp simd do i = 1 , SZ du ( i , n ) = du ( i , n ) * thom_w ( n ) end do !$omp end simd do j = n - 1 , 1 , - 1 !$omp simd do i = 1 , SZ du ( i , j ) = ( du ( i , j ) - thom_f ( j ) * du ( i , j + 1 )) * thom_w ( j ) end do !$omp end simd end do ! Periodic final pass !$omp simd do i = 1 , SZ ss ( i ) = ( du ( i , 1 ) - alpha * du ( i , n )) & / ( 1.0_dp + thom_p ( 1 ) - alpha * thom_p ( n )) end do !$omp end simd do j = 1 , n !$omp simd do i = 1 , SZ du ( i , j ) = ( du ( i , j ) - ss ( i ) * thom_p ( j )) * strch ( j ) end do !$omp end simd end do end subroutine der_univ_thom_per end module m_omp_kernels_thom","tags":"","url":"sourcefile/thomas.f90~2.html"},{"title":"base_case.f90 – x3d2","text":"This file depends on sourcefile~~base_case.f90~~EfferentGraph sourcefile~base_case.f90 base_case.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~common.f90 common.f90 sourcefile~base_case.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~base_case.f90->sourcefile~field.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~field.f90->sourcefile~common.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~config.f90 config.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~base_case.f90~~AfferentGraph sourcefile~base_case.f90 base_case.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_base_case !! Provides the base case for running a simulation. New cases are !! implemented by extending this to specify the initial and boundary !! conditions, forcing terms and case-specific postprocessing and analysis. use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_common , only : dp , DIR_X , DIR_Z , DIR_C , VERT use m_field , only : field_t , flist_t use m_mesh , only : mesh_t use m_solver , only : solver_t , init use m_io_manager , only : io_manager_t use mpi , only : MPI_COMM_WORLD implicit none type , abstract :: base_case_t class ( solver_t ), allocatable :: solver type ( io_manager_t ) :: checkpoint_mgr contains procedure ( boundary_conditions ), deferred :: boundary_conditions procedure ( initial_conditions ), deferred :: initial_conditions procedure ( forcings ), deferred :: forcings procedure ( pre_correction ), deferred :: pre_correction procedure ( postprocess ), deferred :: postprocess procedure :: case_init procedure :: case_finalise procedure :: set_init procedure :: run procedure :: print_enstrophy procedure :: print_div_max_mean end type base_case_t abstract interface subroutine boundary_conditions ( self ) !! Applies case-specific boundary coinditions import :: base_case_t implicit none class ( base_case_t ) :: self end subroutine boundary_conditions subroutine initial_conditions ( self ) !! Sets case-specific initial conditions import :: base_case_t implicit none class ( base_case_t ) :: self end subroutine initial_conditions subroutine forcings ( self , du , dv , dw , iter ) !! Applies case-specific or model realated forcings after transeq import :: base_case_t import :: field_t implicit none class ( base_case_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw integer , intent ( in ) :: iter end subroutine forcings subroutine pre_correction ( self , u , v , w ) !! Applies case-specific pre-correction to the velocity fields before !! pressure correction import :: base_case_t import :: field_t implicit none class ( base_case_t ) :: self class ( field_t ), intent ( inout ) :: u , v , w end subroutine pre_correction subroutine postprocess ( self , iter , t ) !! Triggers case-specific postprocessings at user specified intervals import :: base_case_t import :: dp implicit none class ( base_case_t ) :: self integer , intent ( in ) :: iter real ( dp ), intent ( in ) :: t end subroutine postprocess end interface contains subroutine case_init ( self , backend , mesh , host_allocator ) implicit none class ( base_case_t ) :: self class ( base_backend_t ), target , intent ( inout ) :: backend type ( mesh_t ), target , intent ( inout ) :: mesh type ( allocator_t ), target , intent ( inout ) :: host_allocator self % solver = init ( backend , mesh , host_allocator ) call self % checkpoint_mgr % init ( MPI_COMM_WORLD ) if ( self % checkpoint_mgr % is_restart ()) then call self % checkpoint_mgr % handle_restart ( self % solver , MPI_COMM_WORLD ) else call self % initial_conditions () end if end subroutine case_init subroutine case_finalise ( self ) class ( base_case_t ) :: self if ( self % solver % mesh % par % is_root ()) print * , 'run end' call self % checkpoint_mgr % finalise () end subroutine case_finalise subroutine set_init ( self , field , field_func ) implicit none class ( base_case_t ) :: self class ( field_t ), intent ( inout ) :: field interface pure function field_func ( coords ) result ( r ) import dp implicit none real ( dp ), intent ( in ) :: coords ( 3 ) real ( dp ) :: r end function field_func end interface class ( field_t ), pointer :: field_init integer :: i , j , k , dims ( 3 ) real ( dp ) :: coords ( 3 ) dims = self % solver % mesh % get_dims ( VERT ) field_init => self % solver % host_allocator % get_block ( DIR_C ) do k = 1 , dims ( 3 ) do j = 1 , dims ( 2 ) do i = 1 , dims ( 1 ) coords = self % solver % mesh % get_coordinates ( i , j , k ) field_init % data ( i , j , k ) = field_func ( coords ) end do end do end do call self % solver % backend % set_field_data ( field , field_init % data ) call self % solver % host_allocator % release_block ( field_init ) end subroutine set_init subroutine print_enstrophy ( self , u , v , w ) !! Reports the enstrophy implicit none class ( base_case_t ), intent ( in ) :: self class ( field_t ), intent ( in ) :: u , v , w class ( field_t ), pointer :: du , dv , dw real ( dp ) :: enstrophy du => self % solver % backend % allocator % get_block ( DIR_X , VERT ) dv => self % solver % backend % allocator % get_block ( DIR_X , VERT ) dw => self % solver % backend % allocator % get_block ( DIR_X , VERT ) call self % solver % curl ( du , dv , dw , u , v , w ) enstrophy = 0.5_dp * ( self % solver % backend % scalar_product ( du , du ) & + self % solver % backend % scalar_product ( dv , dv ) & + self % solver % backend % scalar_product ( dw , dw )) & / self % solver % ngrid if ( self % solver % mesh % par % is_root ()) print * , 'enstrophy:' , enstrophy call self % solver % backend % allocator % release_block ( du ) call self % solver % backend % allocator % release_block ( dv ) call self % solver % backend % allocator % release_block ( dw ) end subroutine print_enstrophy subroutine print_div_max_mean ( self , u , v , w ) !! Reports the div(u) at cell centres implicit none class ( base_case_t ), intent ( in ) :: self class ( field_t ), intent ( in ) :: u , v , w class ( field_t ), pointer :: div_u real ( dp ) :: div_u_max , div_u_mean div_u => self % solver % backend % allocator % get_block ( DIR_Z ) call self % solver % divergence_v2p ( div_u , u , v , w ) call self % solver % backend % field_max_mean ( div_u_max , div_u_mean , div_u ) if ( self % solver % mesh % par % is_root ()) & print * , 'div u max mean:' , div_u_max , div_u_mean call self % solver % backend % allocator % release_block ( div_u ) end subroutine print_div_max_mean subroutine run ( self ) !! Runs the solver forwards in time from t=t_0 to t=T, performing !! postprocessing/IO and reporting diagnostics. implicit none class ( base_case_t ), intent ( inout ) :: self type ( flist_t ), allocatable :: curr (:) type ( flist_t ), allocatable :: deriv (:) real ( dp ) :: t integer :: i , iter , sub_iter , start_iter if ( self % checkpoint_mgr % is_restart ()) then t = self % solver % current_iter * self % solver % dt if ( self % solver % mesh % par % is_root ()) & ! for restarts current_iter is read from the checkpoint file print * , 'Continuing from iteration:' , & self % solver % current_iter , 'at time ' , t else self % solver % current_iter = 0 if ( self % solver % mesh % par % is_root ()) print * , 'initial conditions' t = 0._dp end if call self % postprocess ( self % solver % current_iter , t ) start_iter = self % solver % current_iter + 1 if ( self % solver % mesh % par % is_root ()) print * , 'start run' allocate ( curr ( self % solver % time_integrator % nvars )) allocate ( deriv ( self % solver % time_integrator % nvars )) curr ( 1 )% ptr => self % solver % u curr ( 2 )% ptr => self % solver % v curr ( 3 )% ptr => self % solver % w do i = 1 , self % solver % nspecies curr ( 3 + i )% ptr => self % solver % species ( i )% ptr end do do iter = start_iter , self % solver % n_iters do sub_iter = 1 , self % solver % time_integrator % nstage ! first apply case-specific BCs call self % boundary_conditions () do i = 1 , self % solver % nvars deriv ( i )% ptr => self % solver % backend % allocator % get_block ( DIR_X ) end do call self % solver % transeq ( deriv , curr ) ! models that introduce source terms handled here call self % forcings ( deriv ( 1 )% ptr , deriv ( 2 )% ptr , deriv ( 3 )% ptr , iter ) ! time integration call self % solver % time_integrator % step ( curr , deriv , self % solver % dt ) do i = 1 , self % solver % nvars call self % solver % backend % allocator % release_block ( deriv ( i )% ptr ) end do call self % pre_correction ( self % solver % u , self % solver % v , self % solver % w ) if ( self % solver % ibm_on ) then call self % solver % ibm % body ( self % solver % u , self % solver % v , & self % solver % w ) end if call self % solver % pressure_correction ( self % solver % u , self % solver % v , & self % solver % w ) end do self % solver % current_iter = iter if ( mod ( iter , self % solver % n_output ) == 0 ) then t = iter * self % solver % dt call self % postprocess ( iter , t ) end if call self % checkpoint_mgr % handle_io_step ( self % solver , & iter , MPI_COMM_WORLD ) end do call self % case_finalise ! deallocate memory deallocate ( curr ) deallocate ( deriv ) end subroutine run end module m_base_case","tags":"","url":"sourcefile/base_case.f90.html"},{"title":"exec_dist.f90 – x3d2","text":"This file depends on sourcefile~~exec_dist.f90~2~~EfferentGraph sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~common.f90 common.f90 sourcefile~exec_dist.f90~2->sourcefile~common.f90 sourcefile~common.f90~2 common.f90 sourcefile~exec_dist.f90~2->sourcefile~common.f90~2 sourcefile~distributed.f90 distributed.f90 sourcefile~exec_dist.f90~2->sourcefile~distributed.f90 sourcefile~sendrecv.f90 sendrecv.f90 sourcefile~exec_dist.f90~2->sourcefile~sendrecv.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~exec_dist.f90~2->sourcefile~tdsops.f90~2 sourcefile~distributed.f90->sourcefile~common.f90 sourcefile~distributed.f90->sourcefile~common.f90~2 sourcefile~sendrecv.f90->sourcefile~common.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~exec_dist.f90~2~~AfferentGraph sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~exec_dist.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_omp_exec_dist use mpi use m_common , only : dp use m_omp_common , only : SZ use m_omp_kernels_dist , only : der_univ_dist , der_univ_subs , & der_univ_fused_subs use m_tdsops , only : tdsops_t use m_omp_sendrecv , only : sendrecv_fields implicit none contains subroutine exec_dist_tds_compact ( & du , u , u_recv_s , u_recv_e , du_send_s , du_send_e , du_recv_s , du_recv_e , & tdsops , nproc , pprev , pnext , n_groups ) implicit none ! du = d(u) real ( dp ), dimension (:, :, :), intent ( out ) :: du real ( dp ), dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care about the data they pass back real ( dp ), dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e type ( tdsops_t ), intent ( in ) :: tdsops integer , intent ( in ) :: nproc , pprev , pnext integer , intent ( in ) :: n_groups integer :: n_data integer :: k n_data = SZ * n_groups !$omp parallel do do k = 1 , n_groups call der_univ_dist ( & du (:, :, k ), du_send_s (:, :, k ), du_send_e (:, :, k ), & u (:, :, k ), u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops % n_tds , tdsops % n_rhs , & tdsops % coeffs_s , tdsops % coeffs_e , tdsops % coeffs , & tdsops % dist_fw , tdsops % dist_bw , tdsops % dist_af & ) end do !$omp end parallel do ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) !$omp parallel do do k = 1 , n_groups call der_univ_subs ( & du (:, :, k ), du_recv_s (:, :, k ), du_recv_e (:, :, k ), & tdsops % n_tds , tdsops % dist_sa , tdsops % dist_sc , tdsops % stretch & ) end do !$omp end parallel do end subroutine exec_dist_tds_compact subroutine exec_dist_transeq_compact ( & rhs_du , dud , d2u , & du_send_s , du_send_e , du_recv_s , du_recv_e , & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e , & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e , & u , u_recv_s , u_recv_e , & v , v_recv_s , v_recv_e , & tdsops_du , tdsops_dud , tdsops_d2u , nu , nproc , pprev , pnext , n_groups ) implicit none !> The result array, it is also used as temporary storage real ( dp ), dimension (:, :, :), intent ( out ) :: rhs_du !> Temporary storage arrays real ( dp ), dimension (:, :, :), intent ( out ) :: dud , d2u ! The ones below are intent(out) just so that we can write data in them, ! not because we actually need the data they store later where this ! subroutine is called. We absolutely don't care about the data they pass back real ( dp ), dimension (:, :, :), intent ( out ) :: & du_send_s , du_send_e , du_recv_s , du_recv_e real ( dp ), dimension (:, :, :), intent ( out ) :: & dud_send_s , dud_send_e , dud_recv_s , dud_recv_e real ( dp ), dimension (:, :, :), intent ( out ) :: & d2u_send_s , d2u_send_e , d2u_recv_s , d2u_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: u , u_recv_s , u_recv_e real ( dp ), dimension (:, :, :), intent ( in ) :: v , v_recv_s , v_recv_e type ( tdsops_t ), intent ( in ) :: tdsops_du , tdsops_dud , tdsops_d2u real ( dp ), intent ( in ) :: nu integer , intent ( in ) :: nproc , pprev , pnext integer , intent ( in ) :: n_groups real ( dp ), dimension (:, :), allocatable :: ud , ud_recv_s , ud_recv_e integer :: n_data integer :: i , j , k !> DistD2 implementation is hardcoded for 4 halo layers integer , parameter :: n_halo = 4 n_data = SZ * n_groups allocate ( ud ( SZ , tdsops_dud % n_tds )) allocate ( ud_recv_e ( SZ , n_halo )) allocate ( ud_recv_s ( SZ , n_halo )) !$omp parallel do private(ud, ud_recv_e, ud_recv_s) do k = 1 , n_groups call der_univ_dist ( & rhs_du (:, :, k ), du_send_s (:, :, k ), du_send_e (:, :, k ), & u (:, :, k ), u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops_du % n_tds , tdsops_du % n_rhs , & tdsops_du % coeffs_s , tdsops_du % coeffs_e , tdsops_du % coeffs , & tdsops_du % dist_fw , tdsops_du % dist_bw , tdsops_du % dist_af & ) call der_univ_dist ( & d2u (:, :, k ), d2u_send_s (:, :, k ), d2u_send_e (:, :, k ), & u (:, :, k ), u_recv_s (:, :, k ), u_recv_e (:, :, k ), & tdsops_d2u % n_tds , tdsops_d2u % n_rhs , & tdsops_d2u % coeffs_s , tdsops_d2u % coeffs_e , tdsops_d2u % coeffs , & tdsops_d2u % dist_fw , tdsops_d2u % dist_bw , tdsops_d2u % dist_af & ) ! Handle dud by locally generating u*v do j = 1 , tdsops_dud % n_tds !$omp simd do i = 1 , SZ ud ( i , j ) = u ( i , j , k ) * v ( i , j , k ) end do !$omp end simd end do do j = 1 , n_halo !$omp simd do i = 1 , SZ ud_recv_s ( i , j ) = u_recv_s ( i , j , k ) * v_recv_s ( i , j , k ) ud_recv_e ( i , j ) = u_recv_e ( i , j , k ) * v_recv_e ( i , j , k ) end do !$omp end simd end do call der_univ_dist ( & dud (:, :, k ), dud_send_s (:, :, k ), dud_send_e (:, :, k ), & ud (:, :), ud_recv_s (:, :), ud_recv_e (:, :), & tdsops_dud % n_tds , tdsops_dud % n_rhs , & tdsops_dud % coeffs_s , tdsops_dud % coeffs_e , tdsops_dud % coeffs , & tdsops_dud % dist_fw , tdsops_dud % dist_bw , tdsops_dud % dist_af & ) end do !$omp end parallel do ! halo exchange for 2x2 systems call sendrecv_fields ( du_recv_s , du_recv_e , du_send_s , du_send_e , & n_data , nproc , pprev , pnext ) call sendrecv_fields ( dud_recv_s , dud_recv_e , dud_send_s , dud_send_e , & n_data , nproc , pprev , pnext ) call sendrecv_fields ( d2u_recv_s , d2u_recv_e , d2u_send_s , d2u_send_e , & n_data , nproc , pprev , pnext ) !$omp parallel do do k = 1 , n_groups call der_univ_fused_subs ( & rhs_du (:, :, k ), dud (:, :, k ), d2u (:, :, k ), v (:, :, k ), & du_recv_s (:, :, k ), du_recv_e (:, :, k ), & dud_recv_s (:, :, k ), dud_recv_e (:, :, k ), & d2u_recv_s (:, :, k ), d2u_recv_e (:, :, k ), & nu , tdsops_du % n_tds , & tdsops_du % dist_sa , tdsops_du % dist_sc , tdsops_du % stretch , & tdsops_dud % dist_sa , tdsops_dud % dist_sc , tdsops_dud % stretch , & tdsops_d2u % dist_sa , tdsops_d2u % dist_sc , tdsops_d2u % stretch , & tdsops_d2u % stretch_correct & ) end do !$omp end parallel do end subroutine exec_dist_transeq_compact end module m_omp_exec_dist","tags":"","url":"sourcefile/exec_dist.f90~2.html"},{"title":"tgv.f90 – x3d2","text":"This file depends on sourcefile~~tgv.f90~~EfferentGraph sourcefile~tgv.f90 tgv.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~tgv.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~common.f90 common.f90 sourcefile~tgv.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~tgv.f90->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~tgv.f90->sourcefile~mesh.f90 sourcefile~solver.f90 solver.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90->sourcefile~common.f90 sourcefile~base_case.f90->sourcefile~field.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~config.f90 config.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tgv.f90~~AfferentGraph sourcefile~tgv.f90 tgv.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_case_tgv use iso_fortran_env , only : stderr => error_unit use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_base_case , only : base_case_t use m_common , only : dp , VERT , DIR_C use m_field , only : field_t use m_mesh , only : mesh_t use m_solver , only : init implicit none type , extends ( base_case_t ) :: case_tgv_t contains procedure :: boundary_conditions => boundary_conditions_tgv procedure :: initial_conditions => initial_conditions_tgv procedure :: forcings => forcings_tgv procedure :: pre_correction => pre_correction_tgv procedure :: postprocess => postprocess_tgv end type case_tgv_t interface case_tgv_t module procedure case_tgv_init end interface case_tgv_t contains function case_tgv_init ( backend , mesh , host_allocator ) result ( flow_case ) implicit none class ( base_backend_t ), target , intent ( inout ) :: backend type ( mesh_t ), target , intent ( inout ) :: mesh type ( allocator_t ), target , intent ( inout ) :: host_allocator type ( case_tgv_t ) :: flow_case call flow_case % case_init ( backend , mesh , host_allocator ) end function case_tgv_init subroutine initial_conditions_tgv ( self ) implicit none class ( case_tgv_t ) :: self call self % set_init ( self % solver % u , u_func ) call self % set_init ( self % solver % v , v_func ) call self % solver % w % fill ( 0._dp ) call self % solver % u % set_data_loc ( VERT ) call self % solver % v % set_data_loc ( VERT ) call self % solver % w % set_data_loc ( VERT ) end subroutine initial_conditions_tgv pure function u_func ( coords ) result ( r ) implicit none real ( dp ), intent ( in ) :: coords ( 3 ) real ( dp ) :: r r = sin ( coords ( 1 )) * cos ( coords ( 2 )) * cos ( coords ( 3 )) end function u_func pure function v_func ( coords ) result ( r ) implicit none real ( dp ), intent ( in ) :: coords ( 3 ) real ( dp ) :: r r = - cos ( coords ( 1 )) * sin ( coords ( 2 )) * cos ( coords ( 3 )) end function v_func subroutine boundary_conditions_tgv ( self ) implicit none class ( case_tgv_t ) :: self ! do nothing for TGV case end subroutine boundary_conditions_tgv subroutine forcings_tgv ( self , du , dv , dw , iter ) implicit none class ( case_tgv_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw integer , intent ( in ) :: iter ! do nothing for TGV case end subroutine forcings_tgv subroutine pre_correction_tgv ( self , u , v , w ) implicit none class ( case_tgv_t ) :: self class ( field_t ), intent ( inout ) :: u , v , w ! do nothing for TGV case end subroutine pre_correction_tgv subroutine postprocess_tgv ( self , iter , t ) implicit none class ( case_tgv_t ) :: self integer , intent ( in ) :: iter real ( dp ), intent ( in ) :: t if ( self % solver % mesh % par % is_root ()) then print * , 'time =' , t , 'iteration =' , iter end if call self % print_enstrophy ( self % solver % u , self % solver % v , self % solver % w ) call self % print_div_max_mean ( self % solver % u , self % solver % v , self % solver % w ) end subroutine postprocess_tgv end module m_case_tgv","tags":"","url":"sourcefile/tgv.f90.html"},{"title":"poisson_fft.f90 – x3d2","text":"This file depends on sourcefile~~poisson_fft.f90~3~~EfferentGraph sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~common.f90 common.f90 sourcefile~poisson_fft.f90~3->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~poisson_fft.f90~3->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~poisson_fft.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~spectral_processing.f90 spectral_processing.f90 sourcefile~poisson_fft.f90~3->sourcefile~spectral_processing.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~poisson_fft.f90~3->sourcefile~tdsops.f90~2 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~spectral_processing.f90->sourcefile~common.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~poisson_fft.f90~3~~AfferentGraph sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_omp_poisson_fft use decomp_2d_constants , only : PHYSICAL_IN_X use decomp_2d_fft , only : decomp_2d_fft_init , decomp_2d_fft_3d , & decomp_2d_fft_get_size use m_common , only : dp , CELL use m_field , only : field_t use m_mesh , only : mesh_t use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : dirps_t use m_omp_spectral , only : process_spectral_000 , process_spectral_010 implicit none type , extends ( poisson_fft_t ) :: omp_poisson_fft_t !! FFT based Poisson solver complex ( dp ), allocatable , dimension (:, :, :) :: c_x , c_y , c_z contains procedure :: fft_forward => fft_forward_omp procedure :: fft_forward_010 => fft_forward_omp procedure :: fft_forward_100 => fft_forward_100_omp procedure :: fft_forward_110 => fft_forward_110_omp procedure :: fft_backward => fft_backward_omp procedure :: fft_backward_010 => fft_backward_omp procedure :: fft_backward_100 => fft_backward_100_omp procedure :: fft_backward_110 => fft_backward_110_omp procedure :: fft_postprocess_000 => fft_postprocess_000_omp procedure :: fft_postprocess_010 => fft_postprocess_010_omp procedure :: fft_postprocess_100 => fft_postprocess_100_omp procedure :: fft_postprocess_110 => fft_postprocess_110_omp procedure :: enforce_periodicity_x => enforce_periodicity_x_omp procedure :: undo_periodicity_x => undo_periodicity_x_omp procedure :: enforce_periodicity_y => enforce_periodicity_y_omp procedure :: undo_periodicity_y => undo_periodicity_y_omp end type omp_poisson_fft_t interface omp_poisson_fft_t module procedure init end interface omp_poisson_fft_t private :: init contains function init ( mesh , xdirps , ydirps , zdirps , lowmem ) result ( poisson_fft ) implicit none type ( mesh_t ), intent ( in ) :: mesh class ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps logical , optional , intent ( in ) :: lowmem integer , dimension ( 3 ) :: istart , iend , isize integer :: dims ( 3 ) type ( omp_poisson_fft_t ) :: poisson_fft if ( mesh % par % is_root ()) then print * , \"Initialising 2decomp&fft\" end if if ( present ( lowmem )) then print * , 'lowmem_fft has no impact in the OpenMP backend.' end if ! Get global cell dims dims = mesh % get_global_dims ( CELL ) ! Work out the spectral dimensions in the permuted state call decomp_2d_fft_init ( PHYSICAL_IN_X , dims ( 1 ), dims ( 2 ), dims ( 3 )) call decomp_2d_fft_get_size ( istart , iend , isize ) ! Converts a start position into an offset istart (:) = istart (:) - 1 call poisson_fft % base_init ( mesh , xdirps , ydirps , zdirps , isize , istart ) if ( mesh % geo % stretched ( 2 )) then error stop 'OpenMP backends FFT based Poisson solver does not support& & stretching in y-direction yet!' end if allocate ( poisson_fft % c_x ( poisson_fft % nx_spec , poisson_fft % ny_spec , & poisson_fft % nz_spec )) end function init subroutine fft_forward_omp ( self , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in call decomp_2d_fft_3d ( f_in % data , self % c_x ) end subroutine fft_forward_omp subroutine fft_forward_010_omp ( self , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in error stop 'OpenMP backend does not support fft_forward_010 yet!' end subroutine fft_forward_010_omp subroutine fft_forward_100_omp ( self , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in error stop 'OpenMP backend does not support fft_forward_100 yet!' end subroutine fft_forward_100_omp subroutine fft_forward_110_omp ( self , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( in ) :: f_in error stop 'OpenMP backend does not support fft_forward_110 yet!' end subroutine fft_forward_110_omp subroutine fft_backward_omp ( self , f_out ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out call decomp_2d_fft_3d ( self % c_x , f_out % data ) end subroutine fft_backward_omp subroutine fft_backward_010_omp ( self , f_out ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out error stop 'OpenMP backend does not support fft_backward_010 yet!' end subroutine fft_backward_010_omp subroutine fft_backward_100_omp ( self , f_out ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out error stop 'OpenMP backend does not support fft_backward_100 yet!' end subroutine fft_backward_100_omp subroutine fft_backward_110_omp ( self , f_out ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out error stop 'OpenMP backend does not support fft_backward_110 yet!' end subroutine fft_backward_110_omp subroutine fft_postprocess_000_omp ( self ) implicit none class ( omp_poisson_fft_t ) :: self call process_spectral_000 ( & self % c_x , self % waves , self % nx_spec , self % ny_spec , self % nz_spec , & self % x_sp_st , self % y_sp_st , self % z_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax , self % bx , self % ay , self % by , self % az , self % bz & ) end subroutine fft_postprocess_000_omp subroutine fft_postprocess_010_omp ( self ) implicit none class ( omp_poisson_fft_t ) :: self call process_spectral_010 ( & self % c_x , self % waves , self % nx_spec , self % ny_spec , self % nz_spec , & self % x_sp_st , self % y_sp_st , self % z_sp_st , & self % nx_glob , self % ny_glob , self % nz_glob , & self % ax , self % bx , self % ay , self % by , self % az , self % bz & ) end subroutine fft_postprocess_010_omp subroutine fft_postprocess_100_omp ( self ) implicit none class ( omp_poisson_fft_t ) :: self error stop 'OpenMP backend does not support fft_postprocess_100 yet!' end subroutine fft_postprocess_100_omp subroutine fft_postprocess_110_omp ( self ) implicit none class ( omp_poisson_fft_t ) :: self error stop 'OpenMP backend does not support fft_postprocess_110 yet!' end subroutine fft_postprocess_110_omp subroutine enforce_periodicity_x_omp ( self , f_out , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in error stop 'OpenMP backend does not support enforce_periodicity_x yet!' end subroutine enforce_periodicity_x_omp subroutine undo_periodicity_x_omp ( self , f_out , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in error stop 'OpenMP backend does not support undo_periodicity_x yet!' end subroutine undo_periodicity_x_omp subroutine enforce_periodicity_y_omp ( self , f_out , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in integer :: i , j , k !$omp parallel do do k = 1 , self % nz_loc do j = 1 , self % ny_glob / 2 do i = 1 , self % nx_loc f_out % data ( i , j , k ) = f_in % data ( i , 2 * ( j - 1 ) + 1 , k ) end do end do do j = self % ny_glob / 2 + 1 , self % ny_glob do i = 1 , self % nx_loc f_out % data ( i , j , k ) = f_in % data ( i , 2 * self % ny_glob - 2 * j + 2 , k ) end do end do end do !$omp end parallel do end subroutine enforce_periodicity_y_omp subroutine undo_periodicity_y_omp ( self , f_out , f_in ) implicit none class ( omp_poisson_fft_t ) :: self class ( field_t ), intent ( inout ) :: f_out class ( field_t ), intent ( in ) :: f_in integer :: i , j , k !$omp parallel do do k = 1 , self % nz_loc do i = 1 , self % nx_loc do j = 1 , self % ny_glob / 2 f_out % data ( i , 2 * j - 1 , k ) = f_in % data ( i , j , k ) end do do j = 1 , self % ny_glob / 2 f_out % data ( i , 2 * j , k ) = f_in % data ( i , self % ny_glob - j + 1 , k ) end do end do end do !$omp end parallel do end subroutine undo_periodicity_y_omp end module m_omp_poisson_fft","tags":"","url":"sourcefile/poisson_fft.f90~3.html"},{"title":"reorder.f90 – x3d2","text":"This file depends on sourcefile~~reorder.f90~~EfferentGraph sourcefile~reorder.f90 reorder.f90 sourcefile~common.f90 common.f90 sourcefile~reorder.f90->sourcefile~common.f90 sourcefile~common.f90~3 common.f90 sourcefile~reorder.f90->sourcefile~common.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~reorder.f90~~AfferentGraph sourcefile~reorder.f90 reorder.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~reorder.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_kernels_reorder use cudafor use m_common , only : dp use m_cuda_common , only : SZ contains attributes ( global ) subroutine reorder_c2x ( u_x , u_c , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_c integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y ; b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_c ( i + ( b_i - 1 ) * SZ , j + ( b_j - 1 ) * SZ , b_k ) if ( SZ == 64 ) then tile ( i + 32 , j ) = u_c ( i + 32 + ( b_i - 1 ) * SZ , j + ( b_j - 1 ) * SZ , b_k ) tile ( i , j + 32 ) = u_c ( i + ( b_i - 1 ) * SZ , j + 32 + ( b_j - 1 ) * SZ , b_k ) tile ( i + 32 , j + 32 ) = & u_c ( i + 32 + ( b_i - 1 ) * SZ , j + 32 + ( b_j - 1 ) * SZ , b_k ) end if call syncthreads () ! copy into output array from shared u_x ( i , j + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) = tile ( j , i ) if ( SZ == 64 ) then u_x ( i + 32 , j + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) = tile ( j , i + 32 ) u_x ( i , j + 32 + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) = tile ( j + 32 , i ) u_x ( i + 32 , j + 32 + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) = & tile ( j + 32 , i + 32 ) end if end subroutine reorder_c2x attributes ( global ) subroutine reorder_x2c ( u_c , u_x , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_c real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y ; b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_x ( i , j + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) if ( SZ == 64 ) then tile ( i + 32 , j ) = u_x ( i + 32 , j + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) tile ( i , j + 32 ) = u_x ( i , j + 32 + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) tile ( i + 32 , j + 32 ) = & u_x ( i + 32 , j + 32 + ( b_i - 1 ) * SZ , b_k + ( b_j - 1 ) * nz ) end if call syncthreads () ! copy into output array from shared u_c ( i + ( b_i - 1 ) * SZ , j + ( b_j - 1 ) * SZ , b_k ) = tile ( j , i ) if ( SZ == 64 ) then u_c ( i + 32 + ( b_i - 1 ) * SZ , j + ( b_j - 1 ) * SZ , b_k ) = tile ( j , i + 32 ) u_c ( i + ( b_i - 1 ) * SZ , j + 32 + ( b_j - 1 ) * SZ , b_k ) = tile ( j + 32 , i ) u_c ( i + 32 + ( b_i - 1 ) * SZ , j + 32 + ( b_j - 1 ) * SZ , b_k ) = & tile ( j + 32 , i + 32 ) end if end subroutine reorder_x2c attributes ( global ) subroutine reorder_x2y ( u_y , u_x , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_y real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y ; b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_x ( i , j + ( b_i - 1 ) * SZ , b_j + ( b_k - 1 ) * nz ) if ( SZ == 64 ) then tile ( i + 32 , j ) = u_x ( i + 32 , j + ( b_i - 1 ) * SZ , b_j + ( b_k - 1 ) * nz ) tile ( i , j + 32 ) = u_x ( i , j + 32 + ( b_i - 1 ) * SZ , b_j + ( b_k - 1 ) * nz ) tile ( i + 32 , j + 32 ) = & u_x ( i + 32 , j + 32 + ( b_i - 1 ) * SZ , b_j + ( b_k - 1 ) * nz ) end if call syncthreads () ! copy into output array from shared u_y ( i , j + ( b_k - 1 ) * SZ , b_j + ( b_i - 1 ) * nz ) = tile ( j , i ) if ( SZ == 64 ) then u_y ( i + 32 , j + ( b_k - 1 ) * SZ , b_j + ( b_i - 1 ) * nz ) = tile ( j , i + 32 ) u_y ( i , j + 32 + ( b_k - 1 ) * SZ , b_j + ( b_i - 1 ) * nz ) = tile ( j + 32 , i ) u_y ( i + 32 , j + 32 + ( b_k - 1 ) * SZ , b_j + ( b_i - 1 ) * nz ) = & tile ( j + 32 , i + 32 ) end if end subroutine reorder_x2y attributes ( global ) subroutine reorder_x2z ( u_z , u_x , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_z real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_x integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x ! Data access pattern for reordering between x and z is quite nice ! thus we don't need to use shared memory for this operation. do j = 1 , nz u_z ( i , j , b_i + ( b_j - 1 ) * nx ) = u_x ( i , b_i , j + ( b_j - 1 ) * nz ) end do end subroutine reorder_x2z attributes ( global ) subroutine reorder_y2x ( u_x , u_y , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y ; b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) if ( SZ == 64 ) then tile ( i + 32 , j ) = u_y ( i + 32 , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) tile ( i , j + 32 ) = u_y ( i , ( b_j - 1 ) * SZ + j + 32 , ( b_i - 1 ) * nz + b_k ) tile ( i + 32 , j + 32 ) = & u_y ( i + 32 , ( b_j - 1 ) * SZ + j + 32 , ( b_i - 1 ) * nz + b_k ) end if call syncthreads () ! copy into output array from shared u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + b_k ) = tile ( j , i ) if ( SZ == 64 ) then u_x ( i + 32 , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + b_k ) = tile ( j , i + 32 ) u_x ( i , ( b_i - 1 ) * SZ + j + 32 , ( b_j - 1 ) * nz + b_k ) = tile ( j + 32 , i ) u_x ( i + 32 , ( b_i - 1 ) * SZ + j + 32 , ( b_j - 1 ) * nz + b_k ) = & tile ( j + 32 , i + 32 ) end if end subroutine reorder_y2x attributes ( global ) subroutine reorder_y2z ( u_z , u_y , nx , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_z real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nx , nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y ; b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) if ( SZ == 64 ) then tile ( i + 32 , j ) = u_y ( i + 32 , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) tile ( i , j + 32 ) = u_y ( i , ( b_j - 1 ) * SZ + j + 32 , ( b_i - 1 ) * nz + b_k ) tile ( i + 32 , j + 32 ) = & u_y ( i + 32 , ( b_j - 1 ) * SZ + j + 32 , ( b_i - 1 ) * nz + b_k ) end if call syncthreads () ! copy into output array from shared u_z ( i , b_k , ( b_i - 1 ) * SZ + j + ( b_j - 1 ) * nx ) = tile ( j , i ) if ( SZ == 64 ) then u_z ( i + 32 , b_k , ( b_i - 1 ) * SZ + j + ( b_j - 1 ) * nx ) = tile ( j , i + 32 ) u_z ( i , b_k , ( b_i - 1 ) * SZ + j + 32 + ( b_j - 1 ) * nx ) = tile ( j + 32 , i ) u_z ( i + 32 , b_k , ( b_i - 1 ) * SZ + j + 32 + ( b_j - 1 ) * nx ) = & tile ( j + 32 , i + 32 ) end if end subroutine reorder_y2z attributes ( global ) subroutine reorder_z2x ( u_x , u_z , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x do j = 1 , nz u_x ( i , b_i , j + ( b_j - 1 ) * nz ) = u_z ( i , j , b_i + ( b_j - 1 ) * nx ) end do end subroutine reorder_z2x attributes ( global ) subroutine reorder_z2y ( u_y , u_z , nx , nz ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: u_y real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nx , nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y ; b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_z ( i , b_k , ( b_i - 1 ) * SZ + j + ( b_j - 1 ) * nx ) if ( SZ == 64 ) then tile ( i + 32 , j ) = u_z ( i + 32 , b_k , ( b_i - 1 ) * SZ + j + ( b_j - 1 ) * nx ) tile ( i , j + 32 ) = u_z ( i , b_k , ( b_i - 1 ) * SZ + j + 32 + ( b_j - 1 ) * nx ) tile ( i + 32 , j + 32 ) = & u_z ( i + 32 , b_k , ( b_i - 1 ) * SZ + j + 32 + ( b_j - 1 ) * nx ) end if call syncthreads () ! copy into output array from shared u_y ( i , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) = tile ( j , i ) if ( SZ == 64 ) then u_y ( i + 32 , ( b_j - 1 ) * SZ + j , ( b_i - 1 ) * nz + b_k ) = tile ( j , i + 32 ) u_y ( i , ( b_j - 1 ) * SZ + j + 32 , ( b_i - 1 ) * nz + b_k ) = tile ( j + 32 , i ) u_y ( i + 32 , ( b_j - 1 ) * SZ + j + 32 , ( b_i - 1 ) * nz + b_k ) = & tile ( j + 32 , i + 32 ) end if end subroutine reorder_z2y attributes ( global ) subroutine sum_yintox ( u_x , u_y , nz ) implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_y integer , value , intent ( in ) :: nz real ( dp ), shared :: tile ( SZ , SZ ) integer :: i , j , b_i , b_j , b_k i = threadIdx % x ; j = threadIdx % y ; b_i = blockIdx % x ; b_j = blockIdx % y ; b_k = blockIdx % z ! copy into shared tile ( i , j ) = u_y ( i , ( b_j - 1 ) * SZ + j , ( b_k ) + nz * ( b_i - 1 )) if ( SZ == 64 ) then tile ( i + 32 , j ) = u_y ( i + 32 , ( b_j - 1 ) * SZ + j , ( b_k ) + nz * ( b_i - 1 )) tile ( i , j + 32 ) = u_y ( i , ( b_j - 1 ) * SZ + j + 32 , ( b_k ) + nz * ( b_i - 1 )) tile ( i + 32 , j + 32 ) = & u_y ( i + 32 , ( b_j - 1 ) * SZ + j + 32 , ( b_k ) + nz * ( b_i - 1 )) end if call syncthreads () ! copy into output array from shared u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + ( b_k )) = & u_x ( i , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + ( b_k )) + tile ( j , i ) if ( SZ == 64 ) then u_x ( i + 32 , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + ( b_k )) = & u_x ( i + 32 , ( b_i - 1 ) * SZ + j , ( b_j - 1 ) * nz + ( b_k )) + tile ( j , i + 32 ) u_x ( i , ( b_i - 1 ) * SZ + j + 32 , ( b_j - 1 ) * nz + ( b_k )) = & u_x ( i , ( b_i - 1 ) * SZ + j + 32 , ( b_j - 1 ) * nz + ( b_k )) + tile ( j + 32 , i ) u_x ( i + 32 , ( b_i - 1 ) * SZ + j + 32 , ( b_j - 1 ) * nz + ( b_k )) = & u_x ( i + 32 , ( b_i - 1 ) * SZ + j + 32 , ( b_j - 1 ) * nz + ( b_k )) + & tile ( j + 32 , i + 32 ) end if end subroutine sum_yintox attributes ( global ) subroutine sum_zintox ( u_x , u_z , nz ) implicit none ! Arguments real ( dp ), device , intent ( inout ), dimension (:, :, :) :: u_x real ( dp ), device , intent ( in ), dimension (:, :, :) :: u_z integer , value , intent ( in ) :: nz integer :: i , j , b_i , b_j , nx i = threadIdx % x ; b_i = blockIdx % x ; b_j = blockIdx % y nx = gridDim % x do j = 1 , nz u_x ( i , b_i , j + ( b_j - 1 ) * nz ) = u_x ( i , b_i , j + ( b_j - 1 ) * nz ) & + u_z ( i , j , b_i + ( b_j - 1 ) * nx ) end do end subroutine sum_zintox end module m_cuda_kernels_reorder","tags":"","url":"sourcefile/reorder.f90.html"},{"title":"ibm.f90 – x3d2","text":"This file depends on sourcefile~~ibm.f90~~EfferentGraph sourcefile~ibm.f90 ibm.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~common.f90 common.f90 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~field.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io.f90 io.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~ibm.f90~~AfferentGraph sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_ibm !! This module implements the IBM capabilities. !! !! When iibm = 0, the IBM object is never used. !! !! When iibm = 1, the basic IBM capability is used. !! It only requires ep1, a 3D field, as input. !! This field should be one (zero) in the fluid (solid) !! domain. use iso_fortran_env , only : stderr => error_unit use mpi use m_io_session , only : reader_session_t use m_allocator , only : allocator_t , field_t use m_base_backend , only : base_backend_t use m_common , only : dp , i8 , pi , DIR_X , DIR_C , VERT use m_field , only : field_t use m_mesh , only : mesh_t implicit none private public :: ibm_t , iibm_basic integer , parameter :: iibm_basic = 1 type :: ibm_t class ( base_backend_t ), pointer :: backend => null () class ( mesh_t ), pointer :: mesh => null () type ( allocator_t ), pointer :: host_allocator => null () integer :: iibm = 0 class ( field_t ), pointer :: ep1 => null () contains procedure :: body end type ibm_t interface ibm_t module procedure init end interface ibm_t contains function init ( backend , mesh , host_allocator ) result ( ibm ) !! Initialize the basic IBM implicit none class ( base_backend_t ), target , intent ( inout ) :: backend type ( mesh_t ), target , intent ( inout ) :: mesh type ( allocator_t ), target , intent ( inout ) :: host_allocator type ( ibm_t ) :: ibm logical :: file_exists integer :: ierr , dims ( 3 ) real ( dp ), allocatable :: field_data (:, :, :) class ( field_t ), pointer :: ep1 type ( reader_session_t ) :: reader_session character ( len =* ), parameter :: ibm_file = \"ibm.bp\" integer ( i8 ) :: start_dims ( 3 ), count_dims ( 3 ), iibm_i8 ibm % backend => backend ibm % mesh => mesh ibm % host_allocator => host_allocator ! Stop if the file is missing if ( mesh % par % is_root ()) inquire ( file = ibm_file , exist = file_exists ) call MPI_Bcast ( file_exists , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierr ) if ( ierr /= 0 ) then if ( mesh % par % is_root ()) then print * , 'ERROR: MPI_Bcast ' , ierr end if call MPI_Abort ( MPI_COMM_WORLD , 1 , ierr ) return end if if (. not . file_exists ) then if ( mesh % par % is_root ()) then print * , 'ERROR: IBM file not found: ' , trim ( ibm_file ), ierr end if call MPI_Abort ( MPI_COMM_WORLD , 1 , ierr ) return end if ! Open a session to read the IBM configuration file call reader_session % open ( ibm_file , MPI_COMM_WORLD ) ! Read the iibm parameter call reader_session % read_data ( \"iibm\" , iibm_i8 ) ibm % iibm = int ( iibm_i8 , kind = 4 ) ! Basic IBM only needs ep1 on the vertices if ( ibm % iibm == iibm_basic ) then ! Read the vertex mask ep1 ! ! The mask was written in python in C order ! start_dims and count_dims are thus reversed ! The resulting output is in reversed order dims = mesh % get_dims ( VERT ) start_dims = int ( ibm % mesh % par % n_offset , i8 ) count_dims = int ( dims , i8 ) ! Allocate field_data allocate ( field_data ( count_dims ( 1 ), count_dims ( 2 ), count_dims ( 3 ))) ! Read the vertex mask call reader_session % read_data ( \"ep1\" , field_data , start_dims , count_dims ) ! Get and fill a block on the host ep1 => ibm % host_allocator % get_block ( DIR_C ) call ep1 % fill ( 1.0_dp ) ep1 % data (:, :, :) = field_data (:, :, :) ! Get a block on the device and move the data ibm % ep1 => ibm % backend % allocator % get_block ( DIR_X ) call ibm % backend % set_field_data ( ibm % ep1 , ep1 % data ) ! Free memory call ibm % host_allocator % release_block ( ep1 ) deallocate ( field_data ) else ! IBM disabled or unsupported type ibm % ep1 => null () end if ! Closing the session handles all file and reader finalisation call reader_session % close () end function init subroutine body ( self , u , v , w ) !! Apply basic IBM before the pressure solver implicit none class ( ibm_t ) :: self class ( field_t ), intent ( inout ) :: u , v , w if ( self % iibm == iibm_basic ) then ! vel = vel * ep1 ! ! FIXME : currently velocity is zero in the solid. !         It should be dt * grad(p&#94;n). !         After reconstruction, it should be !   dt * grad(p&#94;n) - dt * grad(p&#94;n+1) !         Currently grad(p&#94;n) is not available call self % backend % vecmult ( u , self % ep1 ) call self % backend % vecmult ( v , self % ep1 ) call self % backend % vecmult ( w , self % ep1 ) end if end subroutine body end module m_ibm","tags":"","url":"sourcefile/ibm.f90.html"},{"title":"backend.f90 – x3d2","text":"This file depends on sourcefile~~backend.f90~2~~EfferentGraph sourcefile~backend.f90~2 backend.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~common.f90 common.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~backend.f90~2~~AfferentGraph sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_base_backend use mpi use m_allocator , only : allocator_t use m_common , only : dp , DIR_C , get_rdr_from_dirs use m_field , only : field_t use m_mesh , only : mesh_t use m_poisson_fft , only : poisson_fft_t use m_tdsops , only : tdsops_t , dirps_t implicit none type , abstract :: base_backend_t !! base_backend class defines all the abstract operations that the !! solver class requires. !! !! For example, transport equation in solver class evaluates the !! derivatives in x, y, and z directions, and reorders the input !! fields as required. Then finally, combines all the directional !! derivatives to obtain the divergence of U*. !! !! All these high level operations solver class executes are !! defined here using the abstract interfaces. Every backend !! implementation extends the present abstact backend class to !! define the specifics of these operations based on the target !! architecture. !> DistD2 implementation is hardcoded for 4 halo layers for all backends integer :: n_halo = 4 type ( mesh_t ), pointer :: mesh class ( allocator_t ), pointer :: allocator class ( poisson_fft_t ), pointer :: poisson_fft contains procedure ( transeq_ders ), deferred :: transeq_x procedure ( transeq_ders ), deferred :: transeq_y procedure ( transeq_ders ), deferred :: transeq_z procedure ( transeq_ders_spec ), deferred :: transeq_species procedure ( tds_solve ), deferred :: tds_solve procedure ( reorder ), deferred :: reorder procedure ( sum_intox ), deferred :: sum_yintox procedure ( sum_intox ), deferred :: sum_zintox procedure ( veccopy ), deferred :: veccopy procedure ( vecadd ), deferred :: vecadd procedure ( vecmult ), deferred :: vecmult procedure ( scalar_product ), deferred :: scalar_product procedure ( field_max_mean ), deferred :: field_max_mean procedure ( field_ops ), deferred :: field_scale procedure ( field_ops ), deferred :: field_shift procedure ( field_reduce ), deferred :: field_volume_integral procedure ( field_set_face ), deferred :: field_set_face procedure ( copy_data_to_f ), deferred :: copy_data_to_f procedure ( copy_f_to_data ), deferred :: copy_f_to_data procedure ( alloc_tdsops ), deferred :: alloc_tdsops procedure ( init_poisson_fft ), deferred :: init_poisson_fft procedure :: base_init procedure :: get_field_data procedure :: set_field_data end type base_backend_t abstract interface subroutine transeq_ders ( self , du , dv , dw , u , v , w , nu , dirps ) !! transeq equation obtains the derivatives direction by !! direction, and the exact algorithm used to obtain these !! derivatives are decided at runtime. Backend implementations !! are responsible from directing calls to transeq_ders into !! the correct algorithm. import :: base_backend_t import :: field_t import :: dirps_t import :: dp implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps end subroutine transeq_ders end interface abstract interface subroutine transeq_ders_spec ( self , dspec , uvw , spec , nu , dirps , sync ) !! transeq equation obtains the derivatives direction by !! direction, and the exact algorithm used to obtain these !! derivatives are decided at runtime. Backend implementations !! are responsible from directing calls to transeq_ders into !! the correct algorithm. import :: base_backend_t import :: field_t import :: dirps_t import :: dp implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: dspec class ( field_t ), intent ( in ) :: uvw , spec real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps logical , intent ( in ) :: sync end subroutine transeq_ders_spec end interface abstract interface subroutine tds_solve ( self , du , u , tdsops ) !! transeq equation obtains the derivatives direction by !! direction, and the exact algorithm used to obtain these !! derivatives are decided at runtime. Backend implementations !! are responsible from directing calls to tds_solve to the !! correct algorithm. import :: base_backend_t import :: field_t import :: tdsops_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u class ( tdsops_t ), intent ( in ) :: tdsops end subroutine tds_solve end interface abstract interface subroutine reorder ( self , u_ , u , direction ) !! reorder subroutines are straightforward, they rearrange !! data into our specialist data structure so that regardless !! of the direction tridiagonal systems are solved efficiently !! and fast. import :: base_backend_t import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_ class ( field_t ), intent ( in ) :: u integer , intent ( in ) :: direction end subroutine reorder end interface abstract interface subroutine sum_intox ( self , u , u_ ) !! sum9into3 subroutine combines all the directional velocity !! derivatives into the corresponding x directional fields. import :: base_backend_t import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_ end subroutine sum_intox end interface abstract interface subroutine veccopy ( self , dst , src ) !! copy vectors: y = x import :: base_backend_t import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: dst class ( field_t ), intent ( in ) :: src end subroutine veccopy end interface abstract interface subroutine vecadd ( self , a , x , b , y ) !! adds two vectors together: y = a*x + b*y import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y end subroutine vecadd end interface abstract interface subroutine vecmult ( self , y , x ) !! pointwise multiplication between two vectors: y(:) = y(:) * x(:) import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: y class ( field_t ), intent ( in ) :: x end subroutine vecmult end interface abstract interface real ( dp ) function scalar_product ( self , x , y ) result ( s ) !! Calculates the scalar product of two input fields import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y end function scalar_product end interface abstract interface subroutine field_ops ( self , f , a ) !! Scales or shifts a field by a import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: a end subroutine field_ops end interface abstract interface real ( dp ) function field_reduce ( self , f ) result ( s ) !! Reduces field to a scalar, example: volume integral import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( in ) :: f end function field_reduce end interface abstract interface subroutine field_max_mean ( self , max_val , mean_val , f , enforced_data_loc ) !! Obtains maximum and mean values in a field import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self real ( dp ), intent ( out ) :: max_val , mean_val class ( field_t ), intent ( in ) :: f integer , optional , intent ( in ) :: enforced_data_loc end subroutine field_max_mean end interface abstract interface subroutine field_set_face ( self , f , c_start , c_end , face ) !! A field is a subdomain with a rectangular cuboid shape. !! It has 6 faces, and these faces are either a subdomain boundary !! or a global domain boundary based on the location of the subdomain. !! This subroutine allows us to set any of these faces to a value, !! 'c_start' and 'c_end' for faces at opposite sides. !! 'face' is one of X_FACE, Y_FACE, Z_FACE from common.f90 import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), intent ( in ) :: c_start , c_end integer , intent ( in ) :: face end subroutine field_set_face end interface abstract interface subroutine copy_data_to_f ( self , f , data ) !! Copy the specialist data structure from device or host back !! to a regular 3D data array in host memory. import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ), intent ( inout ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( in ) :: data end subroutine copy_data_to_f subroutine copy_f_to_data ( self , data , f ) !! Copy a regular 3D array in host memory into the specialist !! data structure field that lives on device or host import :: base_backend_t import :: dp import :: field_t implicit none class ( base_backend_t ), intent ( inout ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: data class ( field_t ), intent ( in ) :: f end subroutine copy_f_to_data end interface abstract interface subroutine alloc_tdsops ( & self , tdsops , n_tds , delta , operation , scheme , bc_start , bc_end , & stretch , stretch_correct , n_halo , from_to , sym , c_nu , nu0_nu & ) import :: base_backend_t import :: dp import :: tdsops_t implicit none class ( base_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: n_tds real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: operation , scheme integer , intent ( in ) :: bc_start , bc_end real ( dp ), optional , intent ( in ) :: stretch (:), stretch_correct (:) integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu end subroutine alloc_tdsops end interface abstract interface subroutine init_poisson_fft ( self , mesh , xdirps , ydirps , zdirps , lowmem ) import :: base_backend_t import :: dirps_t import :: mesh_t implicit none class ( base_backend_t ) :: self type ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps logical , optional , intent ( in ) :: lowmem end subroutine init_poisson_fft end interface contains subroutine base_init ( self ) implicit none class ( base_backend_t ) :: self end subroutine base_init subroutine get_field_data ( self , data , f , dir ) !! Extract data from field `f` optionally reordering into `dir` orientation. !! To output in same orientation as `f`, use `call ...%get_field_data(data, f, f%dir)` implicit none class ( base_backend_t ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: data !! Output array class ( field_t ), intent ( in ) :: f !! Field integer , optional , intent ( in ) :: dir !! Desired orientation of output array (defaults to Cartesian) class ( field_t ), pointer :: f_temp integer :: direction , rdr_dir if ( present ( dir )) then direction = dir else direction = DIR_C end if ! Returns 0 if no reorder required rdr_dir = get_rdr_from_dirs ( f % dir , direction ) ! Carry out a reorder if we need, and copy from field to data array if ( rdr_dir /= 0 ) then f_temp => self % allocator % get_block ( direction ) call self % reorder ( f_temp , f , rdr_dir ) call self % copy_f_to_data ( data , f_temp ) call self % allocator % release_block ( f_temp ) else call self % copy_f_to_data ( data , f ) end if end subroutine get_field_data subroutine set_field_data ( self , f , data , dir ) implicit none class ( base_backend_t ) :: self class ( field_t ), intent ( inout ) :: f !! Field real ( dp ), dimension (:, :, :), intent ( in ) :: data !! Input array integer , optional , intent ( in ) :: dir !! Orientation of input array (defaults to Cartesian) class ( field_t ), pointer :: f_temp integer :: direction , rdr_dir if ( present ( dir )) then direction = dir else direction = DIR_C end if ! Returns 0 if no reorder required rdr_dir = get_rdr_from_dirs ( direction , f % dir ) ! Carry out a reorder if we need, and copy from data array to field if ( rdr_dir /= 0 ) then f_temp => self % allocator % get_block ( direction , f % data_loc ) call self % copy_data_to_f ( f_temp , data ) call self % reorder ( f , f_temp , rdr_dir ) call self % allocator % release_block ( f_temp ) else call self % copy_data_to_f ( f , data ) end if end subroutine set_field_data end module m_base_backend","tags":"","url":"sourcefile/backend.f90~2.html"},{"title":"field.f90 – x3d2","text":"This file depends on sourcefile~~field.f90~~EfferentGraph sourcefile~field.f90 field.f90 sourcefile~common.f90 common.f90 sourcefile~field.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~field.f90~~AfferentGraph sourcefile~field.f90 field.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~allocator.f90~2->sourcefile~field.f90 sourcefile~allocator.f90~2->sourcefile~allocator.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~field.f90 sourcefile~backend.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~backend.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~field.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~backend.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~field.f90 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~solver.f90 solver.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~field.f90 sourcefile~cylinder.f90->sourcefile~allocator.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90->sourcefile~mesh.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~field.f90 sourcefile~generic.f90->sourcefile~allocator.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~generic.f90->sourcefile~mesh.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~field.f90 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~field.f90 sourcefile~poisson_fft.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~field.f90 sourcefile~tgv.f90->sourcefile~allocator.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~tgv.f90->sourcefile~mesh.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~allocator.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~channel.f90->sourcefile~mesh.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90 sourcefile~xcompact.f90->sourcefile~allocator.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~mesh.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_field use m_common , only : dp , DIR_X , DIR_Y , DIR_Z , DIR_C type :: field_t !! Memory block type holding both a data field and a pointer !! to the next block.  The `field_t` type also holds a integer !! `refcount` that counts the number of references to this !! field.  User code is currently responsible for incrementing !! the reference count. class ( field_t ), pointer :: next real ( dp ), pointer , private :: p_data (:) real ( dp ), pointer , contiguous :: data (:, :, :) integer :: dir integer :: data_loc integer :: refcount = 0 integer :: id !! An integer identifying the memory block. contains procedure :: fill procedure :: get_shape procedure :: set_shape procedure :: set_data_loc end type field_t interface field_t module procedure field_init end interface field_t type :: flist_t !! Use for creating a list of field pointers class ( field_t ), pointer :: ptr end type flist_t contains function field_init ( ngrid , next , id ) result ( f ) integer , intent ( in ) :: ngrid , id type ( field_t ), pointer , intent ( in ) :: next type ( field_t ) :: f allocate ( f % p_data ( ngrid )) f % refcount = 0 f % next => next f % id = id end function field_init subroutine fill ( self , c ) implicit none class ( field_t ) :: self real ( dp ), intent ( in ) :: c self % p_data (:) = c end subroutine fill subroutine set_data_loc ( self , data_loc ) class ( field_t ) :: self integer , intent ( in ) :: data_loc self % data_loc = data_loc end subroutine function get_shape ( self ) result ( dims ) implicit none class ( field_t ) :: self integer :: dims ( 3 ) dims = shape ( self % data ) end function get_shape subroutine set_shape ( self , dims ) implicit none class ( field_t ) :: self integer , intent ( in ) :: dims ( 3 ) self % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 )) => self % p_data end subroutine set_shape end module m_field","tags":"","url":"sourcefile/field.f90.html"},{"title":"exec_thom.f90 – x3d2","text":"This file depends on sourcefile~~exec_thom.f90~2~~EfferentGraph sourcefile~exec_thom.f90~2 exec_thom.f90 sourcefile~common.f90 common.f90 sourcefile~exec_thom.f90~2->sourcefile~common.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~exec_thom.f90~2->sourcefile~tdsops.f90~2 sourcefile~thomas.f90~2 thomas.f90 sourcefile~exec_thom.f90~2->sourcefile~thomas.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~thomas.f90~2->sourcefile~common.f90 sourcefile~common.f90~2 common.f90 sourcefile~thomas.f90~2->sourcefile~common.f90~2 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_exec_thom use m_common , only : dp use m_tdsops , only : tdsops_t use m_omp_kernels_thom , only : der_univ_thom , der_univ_thom_per implicit none private public :: exec_thom_tds_compact contains subroutine exec_thom_tds_compact ( du , u , tdsops , n_groups ) real ( dp ), dimension (:, :, :), intent ( out ) :: du real ( dp ), dimension (:, :, :), intent ( in ) :: u type ( tdsops_t ), intent ( in ) :: tdsops integer , intent ( in ) :: n_groups integer :: k if ( tdsops % periodic ) then !$omp parallel do do k = 1 , n_groups call der_univ_thom_per ( & du (:, :, k ), u (:, :, k ), tdsops % n_tds , tdsops % coeffs , tdsops % alpha , & tdsops % thom_f , tdsops % thom_s , tdsops % thom_w , & tdsops % thom_p , tdsops % stretch & ) end do !$omp end parallel do else !$omp parallel do do k = 1 , n_groups call der_univ_thom ( & du (:, :, k ), u (:, :, k ), tdsops % n_tds , tdsops % n_rhs , & tdsops % coeffs_s , tdsops % coeffs_e , tdsops % coeffs , & tdsops % thom_f , tdsops % thom_s , tdsops % thom_w , & tdsops % stretch & ) end do !$omp end parallel do end if end subroutine exec_thom_tds_compact end module m_exec_thom","tags":"","url":"sourcefile/exec_thom.f90~2.html"},{"title":"cylinder.f90 – x3d2","text":"This file depends on sourcefile~~cylinder.f90~~EfferentGraph sourcefile~cylinder.f90 cylinder.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~cylinder.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~common.f90 common.f90 sourcefile~cylinder.f90->sourcefile~common.f90 sourcefile~config.f90 config.f90 sourcefile~cylinder.f90->sourcefile~config.f90 sourcefile~field.f90 field.f90 sourcefile~cylinder.f90->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~cylinder.f90->sourcefile~mesh.f90 sourcefile~solver.f90 solver.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~base_case.f90->sourcefile~allocator.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90->sourcefile~common.f90 sourcefile~base_case.f90->sourcefile~field.f90 sourcefile~base_case.f90->sourcefile~mesh.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~config.f90->sourcefile~common.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~solver.f90->sourcefile~allocator.f90 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~solver.f90->sourcefile~common.f90 sourcefile~solver.f90->sourcefile~config.f90 sourcefile~solver.f90->sourcefile~field.f90 sourcefile~solver.f90->sourcefile~mesh.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~ibm.f90->sourcefile~allocator.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~ibm.f90->sourcefile~common.f90 sourcefile~ibm.f90->sourcefile~field.f90 sourcefile~ibm.f90->sourcefile~mesh.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~allocator.f90 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90->sourcefile~common.f90 sourcefile~vector_calculus.f90->sourcefile~field.f90 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~checkpoint_manager.f90->sourcefile~common.f90 sourcefile~checkpoint_manager.f90->sourcefile~config.f90 sourcefile~checkpoint_manager.f90->sourcefile~field.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~io.f90 io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io_session.f90->sourcefile~common.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~io_base.f90 io_base.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~snapshot_manager.f90->sourcefile~common.f90 sourcefile~snapshot_manager.f90->sourcefile~config.f90 sourcefile~snapshot_manager.f90->sourcefile~field.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~io.f90->sourcefile~common.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io_base.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~common.f90 sourcefile~io_field_utils.f90->sourcefile~field.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~cylinder.f90~~AfferentGraph sourcefile~cylinder.f90 cylinder.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_case_cylinder !! An example case set up to run a cylinder flow. use iso_fortran_env , only : stderr => error_unit use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_base_case , only : base_case_t use m_common , only : dp , get_argument , DIR_C , VERT use m_config , only : cylinder_config_t use m_field , only : field_t use m_mesh , only : mesh_t use m_solver , only : init implicit none type , extends ( base_case_t ) :: case_cylinder_t type ( cylinder_config_t ) :: cylinder_cfg contains procedure :: boundary_conditions => boundary_conditions_cylinder procedure :: initial_conditions => initial_conditions_cylinder procedure :: forcings => forcings_cylinder procedure :: pre_correction => pre_correction_cylinder procedure :: postprocess => postprocess_cylinder end type case_cylinder_t interface case_cylinder_t module procedure case_cylinder_init end interface case_cylinder_t contains function case_cylinder_init ( backend , mesh , host_allocator ) result ( flow_case ) implicit none class ( base_backend_t ), target , intent ( inout ) :: backend type ( mesh_t ), target , intent ( inout ) :: mesh type ( allocator_t ), target , intent ( inout ) :: host_allocator type ( case_cylinder_t ) :: flow_case call flow_case % cylinder_cfg % read ( nml_file = get_argument ( 1 )) call flow_case % case_init ( backend , mesh , host_allocator ) end function case_cylinder_init subroutine boundary_conditions_cylinder ( self ) implicit none class ( case_cylinder_t ) :: self end subroutine boundary_conditions_cylinder subroutine initial_conditions_cylinder ( self ) implicit none class ( case_cylinder_t ) :: self real ( dp ) :: init_noise ( 3 ) integer :: dims ( 3 ) class ( field_t ), pointer :: u_init , v_init , w_init dims = self % solver % mesh % get_dims ( VERT ) u_init => self % solver % host_allocator % get_block ( DIR_C ) v_init => self % solver % host_allocator % get_block ( DIR_C ) w_init => self % solver % host_allocator % get_block ( DIR_C ) ! Initial value is 0. call u_init % fill ( 0._dp ) call v_init % fill ( 0._dp ) call w_init % fill ( 0._dp ) ! Set initial noise in [0,1] call random_number ( u_init % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 ))) call random_number ( u_init % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 ))) call random_number ( u_init % data ( 1 : dims ( 1 ), 1 : dims ( 2 ), 1 : dims ( 3 ))) ! Offset and rescale the noise init_noise = self % cylinder_cfg % init_noise u_init % data (:, :, :) = 1._dp & + ( u_init % data (:, :, :) - 0.5_dp ) * init_noise ( 1 ) v_init % data (:, :, :) = ( v_init % data (:, :, :) - 0.5_dp ) * init_noise ( 2 ) w_init % data (:, :, :) = ( w_init % data (:, :, :) - 0.5_dp ) * init_noise ( 3 ) call self % solver % backend % set_field_data ( self % solver % u , u_init % data ) call self % solver % backend % set_field_data ( self % solver % v , v_init % data ) call self % solver % backend % set_field_data ( self % solver % w , w_init % data ) call self % solver % host_allocator % release_block ( u_init ) call self % solver % host_allocator % release_block ( v_init ) call self % solver % host_allocator % release_block ( w_init ) call self % solver % u % set_data_loc ( VERT ) call self % solver % v % set_data_loc ( VERT ) call self % solver % w % set_data_loc ( VERT ) end subroutine initial_conditions_cylinder subroutine forcings_cylinder ( self , du , dv , dw , iter ) implicit none class ( case_cylinder_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw integer , intent ( in ) :: iter end subroutine forcings_cylinder subroutine pre_correction_cylinder ( self , u , v , w ) implicit none class ( case_cylinder_t ) :: self class ( field_t ), intent ( inout ) :: u , v , w end subroutine pre_correction_cylinder subroutine postprocess_cylinder ( self , iter , t ) implicit none class ( case_cylinder_t ) :: self integer , intent ( in ) :: iter real ( dp ), intent ( in ) :: t if ( self % solver % mesh % par % is_root ()) then print * , 'time =' , t , 'iteration =' , iter end if call self % print_enstrophy ( self % solver % u , self % solver % v , self % solver % w ) call self % print_div_max_mean ( self % solver % u , self % solver % v , self % solver % w ) end subroutine postprocess_cylinder end module m_case_cylinder","tags":"","url":"sourcefile/cylinder.f90.html"},{"title":"decomp_dummy.f90 – x3d2","text":"This file depends on sourcefile~~decomp_dummy.f90~~EfferentGraph sourcefile~decomp_dummy.f90 decomp_dummy.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~decomp_dummy.f90->sourcefile~mesh_content.f90 sourcefile~common.f90 common.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_decomp !! Dummy implementation of the decomposition to be linked against when 2decomp&fft isn't available. implicit none contains function is_avail_2decomp () result ( avail ) logical :: avail avail = . false . end function subroutine decomposition_2decomp ( grid , par ) use m_mesh_content , only : par_t , grid_t class ( grid_t ), intent ( inout ) :: grid class ( par_t ), intent ( inout ) :: par error stop \"This build doesn't support 2decomp decomposition\" end subroutine decomposition_2decomp end module","tags":"","url":"sourcefile/decomp_dummy.f90.html"},{"title":"backend.f90 – x3d2","text":"This file depends on sourcefile~~backend.f90~3~~EfferentGraph sourcefile~backend.f90~3 backend.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90 sourcefile~allocator.f90~2 allocator.f90 sourcefile~backend.f90~3->sourcefile~allocator.f90~2 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~common.f90 common.f90 sourcefile~backend.f90~3->sourcefile~common.f90 sourcefile~common.f90~3 common.f90 sourcefile~backend.f90~3->sourcefile~common.f90~3 sourcefile~distributed.f90~2 distributed.f90 sourcefile~backend.f90~3->sourcefile~distributed.f90~2 sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~field.f90 field.f90 sourcefile~backend.f90~3->sourcefile~field.f90 sourcefile~fieldops.f90 fieldops.f90 sourcefile~backend.f90~3->sourcefile~fieldops.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~backend.f90~3->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~reorder.f90 reorder.f90 sourcefile~backend.f90~3->sourcefile~reorder.f90 sourcefile~sendrecv.f90~2 sendrecv.f90 sourcefile~backend.f90~3->sourcefile~sendrecv.f90~2 sourcefile~tdsops.f90 tdsops.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90~2 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~allocator.f90~2->sourcefile~allocator.f90 sourcefile~allocator.f90~2->sourcefile~common.f90 sourcefile~allocator.f90~2->sourcefile~field.f90 sourcefile~allocator.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~distributed.f90~2->sourcefile~common.f90 sourcefile~exec_dist.f90->sourcefile~common.f90 sourcefile~exec_dist.f90->sourcefile~common.f90~3 sourcefile~exec_dist.f90->sourcefile~distributed.f90~2 sourcefile~exec_dist.f90->sourcefile~sendrecv.f90~2 sourcefile~exec_dist.f90->sourcefile~tdsops.f90 sourcefile~field.f90->sourcefile~common.f90 sourcefile~fieldops.f90->sourcefile~common.f90 sourcefile~fieldops.f90->sourcefile~common.f90~3 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~poisson_fft.f90~2->sourcefile~allocator.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~common.f90 sourcefile~poisson_fft.f90~2->sourcefile~field.f90 sourcefile~poisson_fft.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~spectral_processing.f90~2 spectral_processing.f90 sourcefile~poisson_fft.f90~2->sourcefile~spectral_processing.f90~2 sourcefile~reorder.f90->sourcefile~common.f90 sourcefile~reorder.f90->sourcefile~common.f90~3 sourcefile~sendrecv.f90~2->sourcefile~common.f90 sourcefile~tdsops.f90->sourcefile~common.f90 sourcefile~tdsops.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~spectral_processing.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~backend.f90~3~~AfferentGraph sourcefile~backend.f90~3 backend.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_backend use iso_fortran_env , only : stderr => error_unit use cudafor use mpi use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_common , only : dp , MPI_X3D2_DP , move_data_loc , & RDR_X2Y , RDR_X2Z , RDR_Y2X , RDR_Y2Z , RDR_Z2X , RDR_Z2Y , & RDR_C2X , RDR_C2Y , RDR_C2Z , RDR_X2C , RDR_Y2C , RDR_Z2C , & DIR_X , DIR_Y , DIR_Z , DIR_C , VERT , NULL_LOC , & X_FACE , Y_FACE , Z_FACE use m_field , only : field_t use m_mesh , only : mesh_t use m_tdsops , only : dirps_t , tdsops_t use m_cuda_allocator , only : cuda_allocator_t , cuda_field_t use m_cuda_common , only : SZ use m_cuda_exec_dist , only : exec_dist_transeq_3fused , exec_dist_tds_compact use m_cuda_poisson_fft , only : cuda_poisson_fft_t use m_cuda_sendrecv , only : sendrecv_fields , sendrecv_3fields use m_cuda_tdsops , only : cuda_tdsops_t use m_cuda_kernels_dist , only : transeq_3fused_dist , transeq_3fused_subs use m_cuda_kernels_fieldops , only : axpby , buffer_copy , field_scale , & field_shift , scalar_product , & field_max_sum , field_set_y_face , & pwmul , volume_integral use m_cuda_kernels_reorder , only : reorder_x2y , reorder_x2z , reorder_y2x , & reorder_y2z , reorder_z2x , reorder_z2y , & reorder_c2x , reorder_x2c , & sum_yintox , sum_zintox implicit none private :: transeq_halo_exchange , transeq_dist_component type , extends ( base_backend_t ) :: cuda_backend_t !character(len=*), parameter :: name = 'cuda' real ( dp ), device , allocatable , dimension (:, :, :) :: & u_recv_s_dev , u_recv_e_dev , u_send_s_dev , u_send_e_dev , & v_recv_s_dev , v_recv_e_dev , v_send_s_dev , v_send_e_dev , & w_recv_s_dev , w_recv_e_dev , w_send_s_dev , w_send_e_dev , & du_send_s_dev , du_send_e_dev , du_recv_s_dev , du_recv_e_dev , & dud_send_s_dev , dud_send_e_dev , dud_recv_s_dev , dud_recv_e_dev , & d2u_send_s_dev , d2u_send_e_dev , d2u_recv_s_dev , d2u_recv_e_dev type ( dim3 ) :: xblocks , xthreads , yblocks , ythreads , zblocks , zthreads contains procedure :: alloc_tdsops => alloc_cuda_tdsops procedure :: transeq_x => transeq_x_cuda procedure :: transeq_y => transeq_y_cuda procedure :: transeq_z => transeq_z_cuda procedure :: transeq_species => transeq_species_cuda procedure :: tds_solve => tds_solve_cuda procedure :: reorder => reorder_cuda procedure :: sum_yintox => sum_yintox_cuda procedure :: sum_zintox => sum_zintox_cuda procedure :: veccopy => veccopy_cuda procedure :: vecadd => vecadd_cuda procedure :: vecmult => vecmult_cuda procedure :: scalar_product => scalar_product_cuda procedure :: field_max_mean => field_max_mean_cuda procedure :: field_scale => field_scale_cuda procedure :: field_shift => field_shift_cuda procedure :: field_set_face => field_set_face_cuda procedure :: field_volume_integral => field_volume_integral_cuda procedure :: copy_data_to_f => copy_data_to_f_cuda procedure :: copy_f_to_data => copy_f_to_data_cuda procedure :: init_poisson_fft => init_cuda_poisson_fft procedure :: transeq_cuda_dist procedure :: transeq_cuda_thom procedure :: tds_solve_dist end type cuda_backend_t interface cuda_backend_t module procedure init end interface cuda_backend_t contains function init ( mesh , allocator ) result ( backend ) implicit none type ( mesh_t ), target , intent ( inout ) :: mesh class ( allocator_t ), target , intent ( inout ) :: allocator type ( cuda_backend_t ) :: backend type ( cuda_poisson_fft_t ) :: cuda_poisson_fft integer :: n_groups call backend % base_init () select type ( allocator ) type is ( cuda_allocator_t ) ! class level access to the allocator backend % allocator => allocator end select backend % mesh => mesh backend % xthreads = dim3 ( SZ , 1 , 1 ) backend % xblocks = dim3 ( backend % allocator % get_n_groups ( DIR_X ), 1 , 1 ) backend % ythreads = dim3 ( SZ , 1 , 1 ) backend % yblocks = dim3 ( backend % allocator % get_n_groups ( DIR_Y ), 1 , 1 ) backend % zthreads = dim3 ( SZ , 1 , 1 ) backend % zblocks = dim3 ( backend % allocator % get_n_groups ( DIR_Z ), 1 , 1 ) ! Buffer size should be big enough for the largest MPI exchange. n_groups = maxval ([ backend % allocator % get_n_groups ( DIR_X ), & backend % allocator % get_n_groups ( DIR_Y ), & backend % allocator % get_n_groups ( DIR_Z )]) allocate ( backend % u_send_s_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % u_send_e_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % u_recv_s_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % u_recv_e_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % v_send_s_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % v_send_e_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % v_recv_s_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % v_recv_e_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % w_send_s_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % w_send_e_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % w_recv_s_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % w_recv_e_dev ( SZ , backend % n_halo , n_groups )) allocate ( backend % du_send_s_dev ( SZ , 1 , n_groups )) allocate ( backend % du_send_e_dev ( SZ , 1 , n_groups )) allocate ( backend % du_recv_s_dev ( SZ , 1 , n_groups )) allocate ( backend % du_recv_e_dev ( SZ , 1 , n_groups )) allocate ( backend % dud_send_s_dev ( SZ , 1 , n_groups )) allocate ( backend % dud_send_e_dev ( SZ , 1 , n_groups )) allocate ( backend % dud_recv_s_dev ( SZ , 1 , n_groups )) allocate ( backend % dud_recv_e_dev ( SZ , 1 , n_groups )) allocate ( backend % d2u_send_s_dev ( SZ , 1 , n_groups )) allocate ( backend % d2u_send_e_dev ( SZ , 1 , n_groups )) allocate ( backend % d2u_recv_s_dev ( SZ , 1 , n_groups )) allocate ( backend % d2u_recv_e_dev ( SZ , 1 , n_groups )) end function init subroutine alloc_cuda_tdsops ( & self , tdsops , n_tds , delta , operation , scheme , bc_start , bc_end , & stretch , stretch_correct , n_halo , from_to , sym , c_nu , nu0_nu & ) implicit none class ( cuda_backend_t ) :: self class ( tdsops_t ), allocatable , intent ( inout ) :: tdsops integer , intent ( in ) :: n_tds real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: operation , scheme integer , intent ( in ) :: bc_start , bc_end real ( dp ), optional , intent ( in ) :: stretch (:), stretch_correct (:) integer , optional , intent ( in ) :: n_halo character ( * ), optional , intent ( in ) :: from_to logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu allocate ( cuda_tdsops_t :: tdsops ) select type ( tdsops ) type is ( cuda_tdsops_t ) tdsops = cuda_tdsops_t ( n_tds , delta , operation , scheme , bc_start , & bc_end , stretch , stretch_correct , n_halo , & from_to , sym , c_nu , nu0_nu ) end select end subroutine alloc_cuda_tdsops subroutine transeq_x_cuda ( self , du , dv , dw , u , v , w , nu , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps call self % transeq_cuda_dist ( du , dv , dw , u , v , w , nu , dirps , & self % xblocks , self % xthreads ) end subroutine transeq_x_cuda subroutine transeq_y_cuda ( self , du , dv , dw , u , v , w , nu , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass v, u, w call self % transeq_cuda_dist ( dv , du , dw , v , u , w , nu , dirps , & self % yblocks , self % ythreads ) end subroutine transeq_y_cuda subroutine transeq_z_cuda ( self , du , dv , dw , u , v , w , nu , dirps ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps ! u, v, w is reordered so that we pass w, u, v call self % transeq_cuda_dist ( dw , du , dv , w , u , v , nu , dirps , & self % zblocks , self % zthreads ) end subroutine transeq_z_cuda subroutine transeq_species_cuda ( self , dspec , uvw , spec , nu , dirps , sync ) !! Compute the convection and diffusion for the given field !! in the given direction. !! Halo exchange for the given field is necessary !! When sync is true, halo exchange of momentum is necessary implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: dspec class ( field_t ), intent ( in ) :: uvw , spec real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps logical , intent ( in ) :: sync integer :: n_groups type ( cuda_tdsops_t ), pointer :: der1st , der1st_sym , der2nd , der2nd_sym real ( dp ), device , pointer , dimension (:, :, :) :: u_dev , spec_dev , dspec_dev call resolve_field_t ( u_dev , uvw ) call resolve_field_t ( spec_dev , spec ) call resolve_field_t ( dspec_dev , dspec ) select type ( tdsops => dirps % der1st ) type is ( cuda_tdsops_t ); der1st => tdsops end select select type ( tdsops => dirps % der1st_sym ) type is ( cuda_tdsops_t ); der1st_sym => tdsops end select select type ( tdsops => dirps % der2nd ) type is ( cuda_tdsops_t ); der2nd => tdsops end select select type ( tdsops => dirps % der2nd_sym ) type is ( cuda_tdsops_t ); der2nd_sym => tdsops end select n_groups = self % allocator % get_n_groups ( dirps % dir ) ! Halo exchange for momentum if needed if ( sync ) then call copy_into_buffers ( self % u_send_s_dev , self % u_send_e_dev , & u_dev , self % mesh % get_n ( dirps % dir , VERT )) call sendrecv_fields ( self % u_recv_s_dev , self % u_recv_e_dev , & self % u_send_s_dev , self % u_send_e_dev , & SZ * self % n_halo * n_groups , & self % mesh % par % nproc_dir ( dirps % dir ), & self % mesh % par % pprev ( dirps % dir ), & self % mesh % par % pnext ( dirps % dir )) end if ! Copy halo data into buffer arrays call copy_into_buffers ( self % v_send_s_dev , self % v_send_e_dev , & spec_dev , self % mesh % get_n ( dirps % dir , VERT )) ! halo exchange call sendrecv_fields ( self % v_recv_s_dev , self % v_recv_e_dev , & self % v_send_s_dev , self % v_send_e_dev , & SZ * self % n_halo * n_groups , & self % mesh % par % nproc_dir ( dirps % dir ), & self % mesh % par % pprev ( dirps % dir ), & self % mesh % par % pnext ( dirps % dir )) call transeq_dist_component ( self , dspec_dev , spec_dev , u_dev , nu , & self % v_recv_s_dev , self % v_recv_e_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & der1st , der1st_sym , der2nd , dirps % dir , & self % xblocks , self % xthreads ) call dspec % set_data_loc ( spec % data_loc ) end subroutine transeq_species_cuda subroutine transeq_cuda_dist ( self , du , dv , dw , u , v , w , nu , dirps , & blocks , threads ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w real ( dp ), intent ( in ) :: nu type ( dirps_t ), intent ( in ) :: dirps type ( dim3 ), intent ( in ) :: blocks , threads real ( dp ), device , pointer , dimension (:, :, :) :: u_dev , v_dev , w_dev , & du_dev , dv_dev , dw_dev type ( cuda_tdsops_t ), pointer :: der1st , der1st_sym , der2nd , der2nd_sym call resolve_field_t ( u_dev , u ) call resolve_field_t ( v_dev , v ) call resolve_field_t ( w_dev , w ) call resolve_field_t ( du_dev , du ) call resolve_field_t ( dv_dev , dv ) call resolve_field_t ( dw_dev , dw ) select type ( tdsops => dirps % der1st ) type is ( cuda_tdsops_t ); der1st => tdsops end select select type ( tdsops => dirps % der1st_sym ) type is ( cuda_tdsops_t ); der1st_sym => tdsops end select select type ( tdsops => dirps % der2nd ) type is ( cuda_tdsops_t ); der2nd => tdsops end select select type ( tdsops => dirps % der2nd_sym ) type is ( cuda_tdsops_t ); der2nd_sym => tdsops end select call transeq_halo_exchange ( self , u_dev , v_dev , w_dev , dirps % dir ) call transeq_dist_component ( self , du_dev , u_dev , u_dev , nu , & self % u_recv_s_dev , self % u_recv_e_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & der1st , der1st_sym , der2nd , dirps % dir , & blocks , threads ) call transeq_dist_component ( self , dv_dev , v_dev , u_dev , nu , & self % v_recv_s_dev , self % v_recv_e_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & der1st_sym , der1st , der2nd_sym , dirps % dir , & blocks , threads ) call transeq_dist_component ( self , dw_dev , w_dev , u_dev , nu , & self % w_recv_s_dev , self % w_recv_e_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & der1st_sym , der1st , der2nd_sym , dirps % dir , & blocks , threads ) call du % set_data_loc ( u % data_loc ) call dv % set_data_loc ( v % data_loc ) call dw % set_data_loc ( w % data_loc ) end subroutine transeq_cuda_dist subroutine transeq_halo_exchange ( self , u_dev , v_dev , w_dev , dir ) class ( cuda_backend_t ) :: self real ( dp ), device , dimension (:, :, :), intent ( in ) :: u_dev , v_dev , w_dev integer , intent ( in ) :: dir integer :: n , nproc_dir , pprev , pnext integer :: n_groups n_groups = self % allocator % get_n_groups ( dir ) n = self % mesh % get_n ( dir , VERT ) nproc_dir = self % mesh % par % nproc_dir ( dir ) pprev = self % mesh % par % pprev ( dir ) pnext = self % mesh % par % pnext ( dir ) ! Copy halo data into buffer arrays call copy_into_buffers ( self % u_send_s_dev , self % u_send_e_dev , u_dev , n ) call copy_into_buffers ( self % v_send_s_dev , self % v_send_e_dev , v_dev , n ) call copy_into_buffers ( self % w_send_s_dev , self % w_send_e_dev , w_dev , n ) ! halo exchange call sendrecv_3fields ( & self % u_recv_s_dev , self % u_recv_e_dev , & self % v_recv_s_dev , self % v_recv_e_dev , & self % w_recv_s_dev , self % w_recv_e_dev , & self % u_send_s_dev , self % u_send_e_dev , & self % v_send_s_dev , self % v_send_e_dev , & self % w_send_s_dev , self % w_send_e_dev , & SZ * self % n_halo * n_groups , nproc_dir , pprev , pnext ) end subroutine transeq_halo_exchange subroutine transeq_dist_component ( self , rhs_du_dev , u_dev , conv_dev , nu , & u_recv_s_dev , u_recv_e_dev , & conv_recv_s_dev , conv_recv_e_dev , & tdsops_du , tdsops_dud , tdsops_d2u , & dir , blocks , threads ) !! Computes RHS_x&#94;u following: !! !! rhs_x&#94;u = -0.5*(conv*du/dx + d(u*conv)/dx) + nu*d2u/dx2 class ( cuda_backend_t ) :: self !> The result field, it is also used as temporary storage real ( dp ), device , dimension (:, :, :), intent ( out ) :: rhs_du_dev real ( dp ), device , dimension (:, :, :), intent ( in ) :: u_dev , conv_dev real ( dp ), intent ( in ) :: nu real ( dp ), device , dimension (:, :, :), intent ( in ) :: & u_recv_s_dev , u_recv_e_dev , & conv_recv_s_dev , conv_recv_e_dev class ( cuda_tdsops_t ), intent ( in ) :: tdsops_du , tdsops_dud , tdsops_d2u integer , intent ( in ) :: dir type ( dim3 ), intent ( in ) :: blocks , threads class ( field_t ), pointer :: dud , d2u real ( dp ), device , pointer , dimension (:, :, :) :: dud_dev , d2u_dev ! Get some fields for storing the intermediate results dud => self % allocator % get_block ( dir ) d2u => self % allocator % get_block ( dir ) call resolve_field_t ( dud_dev , dud ) call resolve_field_t ( d2u_dev , d2u ) call exec_dist_transeq_3fused ( & rhs_du_dev , & u_dev , u_recv_s_dev , u_recv_e_dev , & conv_dev , conv_recv_s_dev , conv_recv_e_dev , & dud_dev , d2u_dev , & self % du_send_s_dev , self % du_send_e_dev , & self % du_recv_s_dev , self % du_recv_e_dev , & self % dud_send_s_dev , self % dud_send_e_dev , & self % dud_recv_s_dev , self % dud_recv_e_dev , & self % d2u_send_s_dev , self % d2u_send_e_dev , & self % d2u_recv_s_dev , self % d2u_recv_e_dev , & tdsops_du , tdsops_dud , tdsops_d2u , nu , & self % mesh % par % nproc_dir ( dir ), self % mesh % par % pprev ( dir ), & self % mesh % par % pnext ( dir ), blocks , threads & ) ! Release temporary blocks call self % allocator % release_block ( dud ) call self % allocator % release_block ( d2u ) end subroutine transeq_dist_component subroutine transeq_cuda_thom ( self , du , dv , dw , u , v , w , dirps ) !! Thomas algorithm implementation. So much more easier than the !! distributed algorithm. It is intended to work only on a single rank !! so there is no MPI communication. implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du , dv , dw class ( field_t ), intent ( in ) :: u , v , w type ( dirps_t ), intent ( in ) :: dirps end subroutine transeq_cuda_thom subroutine tds_solve_cuda ( self , du , u , tdsops ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u class ( tdsops_t ), intent ( in ) :: tdsops type ( dim3 ) :: blocks , threads ! Check if direction matches for both in/out fields and dirps if ( u % dir /= du % dir ) then error stop 'DIR mismatch between fields in tds_solve.' end if blocks = dim3 ( self % allocator % get_n_groups ( u % dir ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) if ( u % data_loc /= NULL_LOC ) then call du % set_data_loc ( move_data_loc ( u % data_loc , u % dir , tdsops % move )) end if call tds_solve_dist ( self , du , u , tdsops , blocks , threads ) end subroutine tds_solve_cuda subroutine tds_solve_dist ( self , du , u , tdsops , blocks , threads ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: du class ( field_t ), intent ( in ) :: u class ( tdsops_t ), intent ( in ) :: tdsops type ( dim3 ), intent ( in ) :: blocks , threads real ( dp ), device , pointer , dimension (:, :, :) :: du_dev , u_dev type ( cuda_tdsops_t ), pointer :: tdsops_dev integer :: n_groups , dir dir = u % dir n_groups = self % allocator % get_n_groups ( u % dir ) call resolve_field_t ( du_dev , du ) call resolve_field_t ( u_dev , u ) select type ( tdsops ) type is ( cuda_tdsops_t ); tdsops_dev => tdsops end select call copy_into_buffers ( self % u_send_s_dev , self % u_send_e_dev , u_dev , & tdsops_dev % n_tds ) call sendrecv_fields ( self % u_recv_s_dev , self % u_recv_e_dev , & self % u_send_s_dev , self % u_send_e_dev , & SZ * self % n_halo * n_groups , & self % mesh % par % nproc_dir ( dir ), & self % mesh % par % pprev ( dir ), & self % mesh % par % pnext ( dir )) ! call exec_dist call exec_dist_tds_compact ( & du_dev , u_dev , & self % u_recv_s_dev , self % u_recv_e_dev , & self % du_send_s_dev , self % du_send_e_dev , & self % du_recv_s_dev , self % du_recv_e_dev , & tdsops_dev , self % mesh % par % nproc_dir ( dir ), & self % mesh % par % pprev ( dir ), self % mesh % par % pnext ( dir ), & blocks , threads & ) end subroutine tds_solve_dist subroutine reorder_cuda ( self , u_o , u_i , direction ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u_o class ( field_t ), intent ( in ) :: u_i integer , intent ( in ) :: direction real ( dp ), device , pointer , dimension (:, :, :) :: u_o_d , u_i_d , u_temp_d class ( field_t ), pointer :: u_temp type ( dim3 ) :: blocks , threads integer :: nx_padded , ny_padded , nz_padded integer , dimension ( 3 ) :: dims_padded call resolve_field_t ( u_o_d , u_o ) call resolve_field_t ( u_i_d , u_i ) dims_padded = self % allocator % get_padded_dims ( DIR_C ) nx_padded = dims_padded ( 1 ) ny_padded = dims_padded ( 2 ) nz_padded = dims_padded ( 3 ) select case ( direction ) case ( RDR_X2Y ) blocks = dim3 ( nx_padded / SZ , nz_padded , ny_padded / SZ ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_x2y <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_X2Z ) blocks = dim3 ( nx_padded , ny_padded / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_x2z <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_Y2X ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_y2x <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_Y2Z ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_y2z <<< blocks , threads >>> ( u_o_d , u_i_d , & !& nx_padded , nz_padded ) case ( RDR_Z2X ) blocks = dim3 ( nx_padded , ny_padded / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_z2x <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_Z2Y ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_z2y <<< blocks , threads >>> ( u_o_d , u_i_d , & !& nx_padded , nz_padded ) case ( RDR_C2X ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_c2x <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_C2Y ) ! First reorder from C to X, then from X to Y u_temp => self % allocator % get_block ( DIR_X ) call resolve_field_t ( u_temp_d , u_temp ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_c2x <<< blocks , threads >>> ( u_temp_d , u_i_d , nz_padded ) !& blocks = dim3 ( nx_padded / SZ , nz_padded , ny_padded / SZ ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_x2y <<< blocks , threads >>> ( u_o_d , u_temp_d , nz_padded ) !& call self % allocator % release_block ( u_temp ) case ( RDR_C2Z ) ! First reorder from C to X, then from X to Z u_temp => self % allocator % get_block ( DIR_X ) call resolve_field_t ( u_temp_d , u_temp ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_c2x <<< blocks , threads >>> ( u_temp_d , u_i_d , nz_padded ) !& blocks = dim3 ( nx_padded , ny_padded / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_x2z <<< blocks , threads >>> ( u_o_d , u_temp_d , nz_padded ) !& call self % allocator % release_block ( u_temp ) case ( RDR_X2C ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_x2c <<< blocks , threads >>> ( u_o_d , u_i_d , nz_padded ) !& case ( RDR_Y2C ) ! First reorder from Y to X, then from X to C u_temp => self % allocator % get_block ( DIR_X ) call resolve_field_t ( u_temp_d , u_temp ) blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_y2x <<< blocks , threads >>> ( u_temp_d , u_i_d , nz_padded ) !& call reorder_x2c <<< blocks , threads >>> ( u_o_d , u_temp_d , nz_padded ) !& call self % allocator % release_block ( u_temp ) case ( RDR_Z2C ) ! First reorder from Z to X, then from X to C u_temp => self % allocator % get_block ( DIR_X ) call resolve_field_t ( u_temp_d , u_temp ) blocks = dim3 ( nx_padded , ny_padded / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call reorder_z2x <<< blocks , threads >>> ( u_temp_d , u_i_d , nz_padded ) !& blocks = dim3 ( nx_padded / SZ , ny_padded / SZ , nz_padded ) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call reorder_x2c <<< blocks , threads >>> ( u_o_d , u_temp_d , nz_padded ) !& call self % allocator % release_block ( u_temp ) case default error stop 'Reorder direction is undefined.' end select ! reorder keeps the data_loc the same call u_o % set_data_loc ( u_i % data_loc ) end subroutine reorder_cuda subroutine sum_yintox_cuda ( self , u , u_y ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_y real ( dp ), device , pointer , dimension (:, :, :) :: u_d , u_y_d type ( dim3 ) :: blocks , threads integer , dimension ( 3 ) :: dims_padded call resolve_field_t ( u_d , u ) call resolve_field_t ( u_y_d , u_y ) dims_padded = self % allocator % get_padded_dims ( DIR_C ) blocks = dim3 ( dims_padded ( 1 ) / SZ , dims_padded ( 2 ) / SZ , dims_padded ( 3 )) threads = dim3 ( min ( SZ , 32 ), min ( SZ , 32 ), 1 ) call sum_yintox <<< blocks , threads >>> ( u_d , u_y_d , dims_padded ( 3 )) !& end subroutine sum_yintox_cuda subroutine sum_zintox_cuda ( self , u , u_z ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: u class ( field_t ), intent ( in ) :: u_z real ( dp ), device , pointer , dimension (:, :, :) :: u_d , u_z_d type ( dim3 ) :: blocks , threads integer , dimension ( 3 ) :: dims_padded call resolve_field_t ( u_d , u ) call resolve_field_t ( u_z_d , u_z ) dims_padded = self % allocator % get_padded_dims ( DIR_C ) blocks = dim3 ( dims_padded ( 1 ), dims_padded ( 2 ) / SZ , 1 ) threads = dim3 ( SZ , 1 , 1 ) call sum_zintox <<< blocks , threads >>> ( u_d , u_z_d , dims_padded ( 3 )) !& end subroutine sum_zintox_cuda subroutine veccopy_cuda ( self , dst , src ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: dst class ( field_t ), intent ( in ) :: src real ( dp ), device , pointer , dimension (:, :, :) :: dst_d , src_d type ( dim3 ) :: blocks , threads integer :: n call resolve_field_t ( dst_d , dst ) call resolve_field_t ( src_d , src ) n = size ( src_d , dim = 2 ) blocks = dim3 ( size ( src_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call copy <<< blocks , threads >>> ( n , dst_d , src_d ) !& end subroutine veccopy_cuda subroutine vecadd_cuda ( self , a , x , b , y ) implicit none class ( cuda_backend_t ) :: self real ( dp ), intent ( in ) :: a class ( field_t ), intent ( in ) :: x real ( dp ), intent ( in ) :: b class ( field_t ), intent ( inout ) :: y real ( dp ), device , pointer , dimension (:, :, :) :: x_d , y_d type ( dim3 ) :: blocks , threads integer :: nx call resolve_field_t ( x_d , x ) call resolve_field_t ( y_d , y ) nx = size ( x_d , dim = 2 ) blocks = dim3 ( size ( x_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call axpby <<< blocks , threads >>> ( nx , a , x_d , b , y_d ) !& end subroutine vecadd_cuda subroutine vecmult_cuda ( self , y , x ) !! [[m_base_backend(module):vecmult(interface)]] implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: y class ( field_t ), intent ( in ) :: x real ( dp ), device , pointer , dimension (:, :, :) :: x_d , y_d type ( dim3 ) :: blocks , threads integer :: n call resolve_field_t ( x_d , x ) call resolve_field_t ( y_d , y ) n = size ( y_d , dim = 2 ) blocks = dim3 ( size ( y_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call pwmul <<< blocks , threads >>> ( y_d , x_d , n ) !& end subroutine vecmult_cuda real ( dp ) function scalar_product_cuda ( self , x , y ) result ( s ) !! [[m_base_backend(module):scalar_product(interface)]] implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( in ) :: x , y real ( dp ), device , pointer , dimension (:, :, :) :: x_d , y_d real ( dp ), device , allocatable :: sum_d integer :: dims ( 3 ), dims_padded ( 3 ), n , n_i , n_i_pad , n_j , ierr type ( dim3 ) :: blocks , threads if (( x % data_loc == NULL_LOC ) . or . ( y % data_loc == NULL_LOC )) then error stop \"You must set the data_loc before calling scalar product\" end if if (( x % data_loc /= y % data_loc ) . or . ( x % dir /= y % dir )) then error stop \"Called scalar product with incompatible fields\" end if call resolve_field_t ( x_d , x ) call resolve_field_t ( y_d , y ) allocate ( sum_d ) sum_d = 0._dp dims = self % mesh % get_dims ( x % data_loc ) dims_padded = self % allocator % get_padded_dims ( DIR_C ) if ( x % dir == DIR_X ) then n = dims ( 1 ); n_j = dims ( 2 ); n_i = dims ( 3 ); n_i_pad = dims_padded ( 3 ) else if ( x % dir == DIR_Y ) then n = dims ( 2 ); n_j = dims ( 1 ); n_i = dims ( 3 ); n_i_pad = dims_padded ( 3 ) else if ( x % dir == DIR_Z ) then n = dims ( 3 ); n_j = dims ( 2 ); n_i = dims ( 1 ); n_i_pad = dims_padded ( 1 ) else error stop 'scalar_product_cuda does not support DIR_C fields!' end if blocks = dim3 ( n_i , ( n_j - 1 ) / SZ + 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call scalar_product <<< blocks , threads >>> ( sum_d , x_d , y_d , & !& n , n_i_pad , n_j ) s = sum_d call MPI_Allreduce ( MPI_IN_PLACE , s , 1 , MPI_X3D2_DP , MPI_SUM , & MPI_COMM_WORLD , ierr ) end function scalar_product_cuda subroutine copy_into_buffers ( u_send_s_dev , u_send_e_dev , u_dev , n ) implicit none real ( dp ), device , dimension (:, :, :), intent ( out ) :: u_send_s_dev , & u_send_e_dev real ( dp ), device , dimension (:, :, :), intent ( in ) :: u_dev integer , intent ( in ) :: n type ( dim3 ) :: blocks , threads integer :: n_halo = 4 blocks = dim3 ( size ( u_dev , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call buffer_copy <<< blocks , threads >>> ( u_send_s_dev , u_send_e_dev , & !& u_dev , n , n_halo ) end subroutine copy_into_buffers subroutine field_max_mean_cuda ( self , max_val , mean_val , f , enforced_data_loc ) !! [[m_base_backend(module):field_max_mean(interface)]] implicit none class ( cuda_backend_t ) :: self real ( dp ), intent ( out ) :: max_val , mean_val class ( field_t ), intent ( in ) :: f integer , optional , intent ( in ) :: enforced_data_loc real ( dp ), device , pointer , dimension (:, :, :) :: f_d real ( dp ), device , allocatable :: max_d , sum_d integer :: data_loc , dims ( 3 ), dims_padded ( 3 ), n , n_i , n_i_pad , n_j , ierr type ( dim3 ) :: blocks , threads if ( f % data_loc == NULL_LOC . and . (. not . present ( enforced_data_loc ))) then error stop 'The input field to cuda::field_max_mean does not have a & &valid f%data_loc. You may enforce a data_loc of your & &choice as last argument to carry on at your own risk!' end if if ( present ( enforced_data_loc )) then data_loc = enforced_data_loc else data_loc = f % data_loc end if dims = self % mesh % get_dims ( data_loc ) dims_padded = self % allocator % get_padded_dims ( DIR_C ) call resolve_field_t ( f_d , f ) allocate ( max_d , sum_d ) max_d = 0._dp ; sum_d = 0._dp if ( f % dir == DIR_X ) then n = dims ( 1 ); n_j = dims ( 2 ); n_i = dims ( 3 ); n_i_pad = dims_padded ( 3 ) else if ( f % dir == DIR_Y ) then n = dims ( 2 ); n_j = dims ( 1 ); n_i = dims ( 3 ); n_i_pad = dims_padded ( 3 ) else if ( f % dir == DIR_Z ) then n = dims ( 3 ); n_j = dims ( 2 ); n_i = dims ( 1 ); n_i_pad = dims_padded ( 1 ) else error stop 'field_max_mean does not support DIR_C fields!' end if blocks = dim3 ( n_i , ( n_j - 1 ) / SZ + 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call field_max_sum <<< blocks , threads >>> ( max_d , sum_d , f_d , & !& n , n_i_pad , n_j ) ! rank-local values, copy them first from device to host max_val = max_d mean_val = sum_d mean_val = mean_val / product ( self % mesh % get_global_dims ( data_loc )) ! make sure all ranks have final values call MPI_Allreduce ( MPI_IN_PLACE , max_val , 1 , MPI_X3D2_DP , & MPI_MAX , MPI_COMM_WORLD , ierr ) call MPI_Allreduce ( MPI_IN_PLACE , mean_val , 1 , MPI_X3D2_DP , & MPI_SUM , MPI_COMM_WORLD , ierr ) end subroutine field_max_mean_cuda subroutine field_scale_cuda ( self , f , a ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: a real ( dp ), device , pointer , dimension (:, :, :) :: f_d type ( dim3 ) :: blocks , threads integer :: n call resolve_field_t ( f_d , f ) n = size ( f_d , dim = 2 ) blocks = dim3 ( size ( f_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call field_scale <<< blocks , threads >>> ( f_d , a , n ) !& end subroutine field_scale_cuda subroutine field_shift_cuda ( self , f , a ) implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: a real ( dp ), device , pointer , dimension (:, :, :) :: f_d type ( dim3 ) :: blocks , threads integer :: n call resolve_field_t ( f_d , f ) n = size ( f_d , dim = 2 ) blocks = dim3 ( size ( f_d , dim = 3 ), 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call field_shift <<< blocks , threads >>> ( f_d , a , n ) !& end subroutine field_shift_cuda subroutine field_set_face_cuda ( self , f , c_start , c_end , face ) !! [[m_base_backend(module):field_set_face(subroutine)]] implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), intent ( in ) :: c_start , c_end integer , intent ( in ) :: face real ( dp ), device , pointer , dimension (:, :, :) :: f_d type ( dim3 ) :: blocks , threads integer :: dims ( 3 ), nx , ny , nz if ( f % dir /= DIR_X ) then error stop 'Setting a field face is only supported for DIR_X fields.' end if if ( f % data_loc == NULL_LOC ) then error stop 'field_set_face require a valid data_loc.' end if call resolve_field_t ( f_d , f ) dims = self % mesh % get_dims ( f % data_loc ) select case ( face ) case ( X_FACE ) error stop 'Setting X_FACE is not yet supported.' case ( Y_FACE ) blocks = dim3 (( dims ( 1 ) - 1 ) / 64 + 1 , dims ( 3 ), 1 ) threads = dim3 ( 64 , 1 , 1 ) call field_set_y_face <<< blocks , threads >>> ( f_d , c_start , c_end , & !& dims ( 1 ), dims ( 2 ), dims ( 3 )) case ( Z_FACE ) error stop 'Setting Z_FACE is not yet supported.' case default error stop 'face is undefined.' end select end subroutine field_set_face_cuda real ( dp ) function field_volume_integral_cuda ( self , f ) result ( s ) !! volume integral of a field implicit none class ( cuda_backend_t ) :: self class ( field_t ), intent ( in ) :: f real ( dp ), device , pointer , dimension (:, :, :) :: f_d real ( dp ), device , allocatable :: integral_d integer :: dims ( 3 ), dims_padded ( 3 ), ierr type ( dim3 ) :: blocks , threads if ( f % data_loc == NULL_LOC ) then error stop 'You must set the data_loc before calling volume integral.' end if if ( f % dir /= DIR_X ) then error stop 'Volume integral can only be called on DIR_X fields.' end if call resolve_field_t ( f_d , f ) allocate ( integral_d ) integral_d = 0._dp dims = self % mesh % get_dims ( f % data_loc ) dims_padded = self % allocator % get_padded_dims ( DIR_C ) blocks = dim3 ( dims ( 3 ), ( dims ( 2 ) - 1 ) / SZ + 1 , 1 ) threads = dim3 ( SZ , 1 , 1 ) call volume_integral <<< blocks , threads >>> ( integral_d , f_d , & !& dims ( 1 ), dims_padded ( 3 ), dims ( 2 )) s = integral_d call MPI_Allreduce ( MPI_IN_PLACE , s , 1 , MPI_X3D2_DP , MPI_SUM , & MPI_COMM_WORLD , ierr ) end function field_volume_integral_cuda subroutine copy_data_to_f_cuda ( self , f , data ) class ( cuda_backend_t ), intent ( inout ) :: self class ( field_t ), intent ( inout ) :: f real ( dp ), dimension (:, :, :), intent ( inout ) :: data select type ( f ); type is ( cuda_field_t ); f % data_d = data ; end select end subroutine copy_data_to_f_cuda subroutine copy_f_to_data_cuda ( self , data , f ) class ( cuda_backend_t ), intent ( inout ) :: self real ( dp ), dimension (:, :, :), intent ( out ) :: data class ( field_t ), intent ( in ) :: f select type ( f ); type is ( cuda_field_t ); data = f % data_d ; end select end subroutine copy_f_to_data_cuda subroutine init_cuda_poisson_fft ( self , mesh , xdirps , ydirps , zdirps , lowmem ) implicit none class ( cuda_backend_t ) :: self type ( mesh_t ), intent ( in ) :: mesh type ( dirps_t ), intent ( in ) :: xdirps , ydirps , zdirps logical , optional , intent ( in ) :: lowmem allocate ( cuda_poisson_fft_t :: self % poisson_fft ) select type ( poisson_fft => self % poisson_fft ) type is ( cuda_poisson_fft_t ) poisson_fft = cuda_poisson_fft_t ( mesh , xdirps , ydirps , zdirps , lowmem ) end select end subroutine init_cuda_poisson_fft subroutine resolve_field_t ( u_dev , u ) real ( dp ), device , pointer , dimension (:, :, :), intent ( out ) :: u_dev class ( field_t ), intent ( in ) :: u select type ( u ) type is ( cuda_field_t ) u_dev => u % data_d end select end subroutine resolve_field_t end module m_cuda_backend","tags":"","url":"sourcefile/backend.f90~3.html"},{"title":"tdsops.f90 – x3d2","text":"This file depends on sourcefile~~tdsops.f90~2~~EfferentGraph sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~common.f90 common.f90 sourcefile~tdsops.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tdsops.f90~2~~AfferentGraph sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~tdsops.f90~2 sourcefile~backend.f90~2 backend.f90 sourcefile~backend.f90->sourcefile~backend.f90~2 sourcefile~exec_dist.f90~2 exec_dist.f90 sourcefile~backend.f90->sourcefile~exec_dist.f90~2 sourcefile~poisson_fft.f90~3 poisson_fft.f90 sourcefile~backend.f90->sourcefile~poisson_fft.f90~3 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90~2 sourcefile~backend.f90~3->sourcefile~backend.f90~2 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~tdsops.f90 tdsops.f90 sourcefile~backend.f90~3->sourcefile~tdsops.f90 sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~exec_dist.f90~2->sourcefile~tdsops.f90~2 sourcefile~exec_thom.f90~2 exec_thom.f90 sourcefile~exec_thom.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90~2->sourcefile~poisson_fft.f90 sourcefile~poisson_fft.f90~3->sourcefile~tdsops.f90~2 sourcefile~poisson_fft.f90~3->sourcefile~poisson_fft.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~tdsops.f90~2 sourcefile~solver.f90->sourcefile~backend.f90~2 sourcefile~vector_calculus.f90 vector_calculus.f90 sourcefile~solver.f90->sourcefile~vector_calculus.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~tdsops.f90->sourcefile~tdsops.f90~2 sourcefile~vector_calculus.f90->sourcefile~tdsops.f90~2 sourcefile~vector_calculus.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~backend.f90~2 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~backend.f90~2 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~backend.f90~2 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~exec_dist.f90->sourcefile~tdsops.f90 sourcefile~exec_thom.f90 exec_thom.f90 sourcefile~exec_thom.f90->sourcefile~tdsops.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~backend.f90~2 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~ibm.f90->sourcefile~backend.f90~2 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~backend.f90~2 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~2 sourcefile~xcompact.f90->sourcefile~backend.f90~3 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_tdsops use iso_fortran_env , only : stderr => error_unit use m_common , only : dp , pi , VERT , CELL , & BC_PERIODIC , BC_NEUMANN , BC_DIRICHLET implicit none type :: tdsops_t !! Tridiagonal Solver Operators class. !! !! Operator arrays are preprocessed in this class based on the arguments !! provided. dist_fw and dist_bw are used in the first phase of the !! distributed tridiagonal solver algorithm. dist_sa and dist_sc are used !! in the final substitution phase. See the kernels_dist.f90 files in the !! relevant backend folders. !! coeff arrays define the specific rules of building the RHS !! corresponding to the tridiagonal system to be solved, and used only in !! the first phase of the distributed algorithm when building the RHS. !! If a boundary condition is defined then coeffs_s and coeffs_e differ !! from coeffs array and define the RHS rule for the first and last 4 !! entries in the tridiagonal system (n_halo = 4). !! !! This class does not know about the current rank or its relative !! location among other ranks. All the operator arrays here are used when !! executing a distributed tridiagonal solver phase one or two. real ( dp ), allocatable , dimension (:) :: dist_fw , dist_bw , & !! fw/bw phase dist_sa , dist_sc , & !! back subs. dist_af !! the auxiliary factors real ( dp ), allocatable , dimension (:) :: thom_f , thom_s , thom_w , thom_p real ( dp ), allocatable :: stretch (:), stretch_correct (:) real ( dp ), allocatable :: coeffs (:), coeffs_s (:, :), coeffs_e (:, :) real ( dp ) :: alpha , a , b , c = 0._dp , d = 0._dp !! Compact scheme coeffs logical :: periodic integer :: n_tds !! Tridiagonal system size integer :: n_rhs !! Right-hand-side builder size integer :: move = 0 !! move between vertices and cell centres integer :: n_halo !! number of halo points contains procedure :: deriv_1st , deriv_2nd , interpl_mid , stagder_1st procedure :: preprocess_dist , preprocess_thom end type tdsops_t interface tdsops_t module procedure tdsops_init end interface tdsops_t type :: dirps_t !! Directional tridiagonal solver container. !! !! This class contains the preprocessed tridiagonal solvers for operating !! in each coordinate direction. class ( tdsops_t ), allocatable :: der1st , der1st_sym , der2nd , der2nd_sym , & stagder_v2p , stagder_p2v , interpl_v2p , interpl_p2v integer :: dir end type dirps_t contains function tdsops_init ( & n_tds , delta , operation , scheme , bc_start , bc_end , & stretch , stretch_correct , n_halo , from_to , sym , c_nu , nu0_nu & ) result ( tdsops ) !! Constructor function for the tdsops_t class. !! !! 'n_tds', 'delta', 'operation', 'scheme', 'bc_start', and 'bc_end' are !! necessary arguments. The remaining arguments are optional. !! !! 'stretch' is for obtaining the correct derivations in a stretched mesh !! 'stretch_correct' is for correcting the second derivative with the first !! !! 'from_to' is necessary for interpolation and staggared derivative, and !! it can be 'v2p' or 'p2v'. !! If the specific region the instance is operating is not a boundary !! region, then 'bc_start' and 'bc_end' are BC_HALO. !! !! 'sym' is relevant when the BC is free-slip. If sym is .true. then it !! means the field we operate on is assumed to be an even function !! (symmetric, cos type) accross the boundary. If it is .false. it means !! the field is assumed to be an odd function (anti-symmetric, sin type). !! !! 'c_nu', 'nu0_nu' are relevant when operation is second order !! derivative and scheme is compact6-hyperviscous. implicit none type ( tdsops_t ) :: tdsops !! return value of the function integer , intent ( in ) :: n_tds !! Tridiagonal system size real ( dp ), intent ( in ) :: delta !! Grid spacing character ( * ), intent ( in ) :: operation , scheme integer , intent ( in ) :: bc_start , bc_end !! Boundary Cond. real ( dp ), optional , intent ( in ) :: stretch (:) !! Stretching coefficients real ( dp ), optional , intent ( in ) :: stretch_correct (:) !! Stretch correction integer , optional , intent ( in ) :: n_halo !! Number of halo cells character ( * ), optional , intent ( in ) :: from_to !! 'v2p' or 'p2v' logical , optional , intent ( in ) :: sym !! (==npaire), only for Neumann BCs real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu !! params for hypervisc. #ifdef SINGLE_PREC real ( dp ) :: tol = 1e-12 #else real ( dp ) :: tol = 1e-16 #endif integer :: n , n_stencil tdsops % n_tds = n_tds ! we need special treatment in the right-hand-side build stage for ! the very last point in the domain if output length is smaller than ! the input length if ( present ( from_to )) then if (( bc_end == BC_NEUMANN . or . bc_end == BC_DIRICHLET ) & . and . from_to == 'v2p' ) then tdsops % n_rhs = n_tds + 1 else tdsops % n_rhs = n_tds end if else tdsops % n_rhs = n_tds end if if ( present ( n_halo )) then tdsops % n_halo = n_halo if ( n_halo /= 4 ) then write ( stderr , '(\"Warning: n_halo is set to \", i2, \"be careful! & &The default is 4 and there are quite a few & &places where things are hardcoded assuming & &n_halo is 4.\")' ) n_halo end if else tdsops % n_halo = 4 end if ! n_rhs >= n_tds, n is used when its better to allocate a larger size n = tdsops % n_rhs ! preprocessed coefficient arrays for the distributed algorithm allocate ( tdsops % dist_fw ( n ), tdsops % dist_bw ( n )) allocate ( tdsops % dist_sa ( n ), tdsops % dist_sc ( n )) allocate ( tdsops % dist_af ( n )) ! preprocessed coefficient arrays for the Thomas algorithm allocate ( tdsops % thom_f ( n ), tdsops % thom_s ( n )) allocate ( tdsops % thom_w ( n ), tdsops % thom_p ( n )) ! RHS coefficient arrays n_stencil = 2 * tdsops % n_halo + 1 allocate ( tdsops % coeffs ( n_stencil )) allocate ( tdsops % coeffs_s ( n_stencil , tdsops % n_halo )) allocate ( tdsops % coeffs_e ( n_stencil , tdsops % n_halo )) allocate ( tdsops % stretch ( n_tds )) if ( present ( stretch )) then tdsops % stretch (:) = stretch (:) else tdsops % stretch (:) = 1._dp end if allocate ( tdsops % stretch_correct ( n_tds )) if ( present ( stretch_correct )) then tdsops % stretch_correct (:) = stretch_correct (:) else tdsops % stretch_correct (:) = 0._dp end if tdsops % periodic = bc_start == BC_PERIODIC . and . bc_end == BC_PERIODIC if ( operation == 'first-deriv' ) then call tdsops % deriv_1st ( delta , scheme , bc_start , bc_end , sym ) else if ( operation == 'second-deriv' ) then call tdsops % deriv_2nd ( delta , scheme , bc_start , bc_end , sym , & c_nu , nu0_nu ) else if ( operation == 'interpolate' ) then call tdsops % interpl_mid ( scheme , from_to , bc_start , bc_end , sym ) else if ( operation == 'stag-deriv' ) then call tdsops % stagder_1st ( delta , scheme , from_to , bc_start , bc_end , sym ) else error stop 'operation is not defined' end if select case ( from_to ) case ( 'v2p' ) tdsops % move = 1 case ( 'p2v' ) tdsops % move = - 1 case default tdsops % move = 0 end select if ( tdsops % dist_sa ( n_tds ) > tol ) then print * , 'There are ' , n_tds , 'points in a subdomain, it may be too few!' print * , 'The entry distributed solver disregards in \"' & // operation // '\" operation is:' , tdsops % dist_sa ( n_tds ) print * , 'It may result in numerical errors with the distributed solver!' end if end function tdsops_init subroutine deriv_1st ( self , delta , scheme , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme integer , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , afi , bfi integer :: i , n , n_halo logical :: symmetry if ( self % n_halo < 2 ) error stop 'First derivative require n_halo >= 2' if ( present ( sym )) then symmetry = sym else symmetry = . false . end if ! alpha is alfa select case ( scheme ) case ( 'compact6' ) alpha = 1._dp / 3._dp afi = 7._dp / 9._dp / delta bfi = 1._dp / 3 6._dp / delta case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = afi ; self % b = bfi self % coeffs (:) = [ 0._dp , 0._dp , - bfi , - afi , & 0._dp , & afi , bfi , 0._dp , 0._dp ] do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % n_tds n_halo = self % n_halo allocate ( dist_b ( self % n_rhs )) dist_b (:) = 1._dp select case ( bc_start ) case ( BC_NEUMANN ) if ( symmetry ) then ! sym == .true.; d(uu)/dx, dv/dx, dw/dx !                d(vv)/dy, du/dy, dw/dy !                d(ww)/dz, du/dz, dv/dz self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - afi , & - bfi , & afi , bfi , 0._dp , 0._dp ] else ! sym == .false.; d(uv)/dx, d(uw)/dx, du/dx !                 d(vu)/dy, d(vw)/dy, dv/dy !                 d(wu)/dz, d(wv)/dz, dw/dz self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 2 * afi , 2 * bfi , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - afi , & bfi , & afi , bfi , 0._dp , 0._dp ] end if case ( BC_DIRICHLET ) ! first line self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - 2.5_dp , & 2._dp , 0.5_dp , 0._dp , 0._dp ] self % coeffs_s (:, 1 ) = self % coeffs_s (:, 1 ) / delta ! second line self % dist_sa ( 2 ) = 0.25_dp self % dist_sc ( 2 ) = 0.25_dp self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - 0.75_dp , & 0._dp , & 0.75_dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = self % coeffs_s (:, 2 ) / delta end select select case ( bc_end ) case ( BC_NEUMANN ) if ( symmetry ) then ! sym == .true.; d(uu)/dx, dv/dx, dw/dx !                d(vv)/dy, du/dy, dw/dy !                d(ww)/dz, du/dz, dv/dz self % dist_sa ( n ) = 0._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bfi , - afi , & bfi , & afi , 0._dp , 0._dp , 0._dp ] else ! sym == .false.; d(uv)/dx, d(uw)/dx, du/dx !                 d(vu)/dy, d(vw)/dy, dv/dy !                 d(wu)/dz, d(wv)/dz, dw/dz self % dist_sa ( n ) = 2 * alpha self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , - 2 * bfi , - 2 * afi , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bfi , - afi , & - bfi , & afi , 0._dp , 0._dp , 0._dp ] end if case ( BC_DIRICHLET ) ! last line self % dist_sa ( n ) = 2._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, n_halo ) = [ 0._dp , 0._dp , - 0.5_dp , - 2._dp , & 2.5_dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo ) = self % coeffs_e (:, n_halo ) / delta ! second last line self % dist_sa ( n - 1 ) = 0.25_dp self % dist_sc ( n - 1 ) = 0.25_dp self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , 0._dp , - 0.75_dp , & 0._dp , & 0.75_dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, n_halo - 1 ) = self % coeffs_e (:, n_halo - 1 ) / delta end select call self % preprocess_thom ( dist_b ) call self % preprocess_dist ( dist_b ) end subroutine deriv_1st subroutine deriv_2nd ( self , delta , scheme , bc_start , bc_end , sym , & c_nu , nu0_nu ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme integer , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), optional , intent ( in ) :: c_nu , nu0_nu real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , asi , bsi , csi , dsi real ( dp ) :: dpis3 , xnpi2 , xmpi2 , den , d2 , temp1 , temp2 integer :: i , n , n_halo logical :: symmetry if ( self % n_halo < 4 ) error stop 'Second derivative require n_halo >= 4' if ( present ( sym )) then symmetry = sym else symmetry = . false . end if d2 = delta * delta ! alpha is alsa select case ( scheme ) case ( 'compact6' ) alpha = 2._dp / 1 1._dp asi = 1 2._dp / 1 1._dp / d2 bsi = 3._dp / 4 4._dp / d2 csi = 0._dp dsi = 0._dp case ( 'compact6-hyperviscous' ) if ( present ( c_nu ) . and . present ( nu0_nu )) then dpis3 = 2._dp * pi / 3._dp xnpi2 = pi * pi * ( 1._dp + nu0_nu ) xmpi2 = dpis3 * dpis3 * ( 1._dp + c_nu * nu0_nu ) den = 40 5._dp * xnpi2 - 64 0._dp * xmpi2 + 14 4._dp alpha = 0.5_dp - ( 32 0._dp * xmpi2 - 129 6._dp ) / den asi = - ( 432 9._dp * xnpi2 / 8._dp - 3 2._dp * xmpi2 & - 14 0._dp * xnpi2 * xmpi2 + 28 6._dp ) / den / d2 bsi = ( 211 5._dp * xnpi2 - 179 2._dp * xmpi2 & - 28 0._dp * xnpi2 * xmpi2 + 132 8._dp ) / den / ( 4._dp * d2 ) csi = - ( 769 5._dp * xnpi2 / 8._dp + 28 8._dp * xmpi2 & - 18 0._dp * xnpi2 * xmpi2 - 257 4._dp ) / den / ( 9._dp * d2 ) dsi = ( 19 8._dp * xnpi2 + 12 8._dp * xmpi2 & - 4 0._dp * xnpi2 * xmpi2 - 73 6._dp ) / den / ( 1 6._dp * d2 ) else error stop 'compact6-hyperviscous requires c_nu and nu0_nu' end if case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = asi ; self % b = bsi ; self % c = csi ; self % d = dsi self % coeffs (:) = [ dsi , csi , bsi , asi , & - 2._dp * ( asi + bsi + csi + dsi ), & asi , bsi , csi , dsi ] do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % n_tds n_halo = self % n_halo allocate ( dist_b ( self % n_rhs )) dist_b (:) = 1._dp select case ( bc_start ) case ( BC_NEUMANN ) if ( symmetry ) then ! sym == .true.; d2v/dx2, d2w/dx2 !                d2u/dy2, d2w/dy2 !                d2u/dz2, d2v/dz2 self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & 2 * asi , 2 * bsi , 2 * csi , 2 * dsi ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , asi , & - 2 * asi - bsi - 2 * csi - 2 * dsi , & asi + csi , bsi + dsi , csi , dsi ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bsi , asi + csi , & - 2 * asi - 2 * bsi - 2 * csi - dsi , & asi , bsi , csi , dsi ] self % coeffs_s (:, 4 ) = [ 0._dp , csi , bsi + dsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi , csi , dsi ] else ! sym == .false.; d2u/dx2 !                 d2v/dy2 !                 d2w/dz2 self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , asi , & - 2 * asi - 3 * bsi - 2 * csi - 2 * dsi , & asi - csi , bsi - dsi , csi , dsi ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bsi , asi - csi , & - 2 * asi - 2 * bsi - 2 * csi - 3 * dsi , & asi , bsi , csi , dsi ] self % coeffs_s (:, 4 ) = [ 0._dp , - csi , bsi - dsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi , csi , dsi ] end if case ( BC_DIRICHLET ) ! first line self % dist_sa ( 1 ) = 0._dp self % dist_sc ( 1 ) = 1 1._dp self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 1 3._dp / d2 , & - 2 7._dp / d2 , 1 5._dp / d2 , - 1._dp / d2 , 0._dp ] ! second line self % dist_sa ( 2 ) = 0.1_dp self % dist_sc ( 2 ) = 0.1_dp self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , 1.2_dp / d2 , & - 2.4_dp / d2 , & 1.2_dp / d2 , 0._dp , 0._dp , 0._dp ] ! third line self % dist_sa ( 3 ) = 2._dp / 1 1._dp self % dist_sc ( 3 ) = 2._dp / 1 1._dp temp1 = 3._dp / 4 4._dp / d2 ; temp2 = 1 2._dp / 1 1._dp / d2 self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , temp1 , temp2 , & - 2._dp * ( temp1 + temp2 ), & temp2 , temp1 , 0._dp , 0._dp ] ! fourth line is same as third self % dist_sa ( 4 ) = 2._dp / 1 1._dp self % dist_sc ( 4 ) = 2._dp / 1 1._dp self % coeffs_s (:, 4 ) = self % coeffs_s (:, 3 ) end select select case ( bc_end ) case ( BC_NEUMANN ) if ( symmetry ) then ! sym == .true.; d2v/dx2, d2w/dx2 !                d2u/dy2, d2w/dy2 !                d2u/dz2, d2v/dz2 self % dist_sa ( n ) = 2 * alpha self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dsi , csi , bsi + dsi , asi + csi , & - 2 * asi - bsi - 2 * csi - 2 * dsi , & asi , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - dsi , & asi + csi , bsi , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi + dsi , csi , 0._dp ] else ! sym == .false.; d2u/dx2 !                 d2v/dy2 !                 d2w/dz2 self % dist_sa ( n ) = 0._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dsi , csi , bsi - dsi , asi - csi , & - 2 * asi - 3 * bsi - 2 * csi - 2 * dsi , & asi , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 3 * dsi , & asi - csi , bsi , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dsi , csi , bsi , asi , & - 2 * asi - 2 * bsi - 2 * csi - 2 * dsi , & asi , bsi - dsi , - csi , 0._dp ] end if case ( BC_DIRICHLET ) ! last line self % dist_sa ( n ) = 1 1._dp self % dist_sc ( n ) = 0._dp self % coeffs_e (:, 4 ) = [ 0._dp , - 1._dp / d2 , 1 5._dp / d2 , - 2 7._dp / d2 , & 1 3._dp / d2 , & 0._dp , 0._dp , 0._dp , 0._dp ] ! second last line self % dist_sa ( n - 1 ) = 0.1_dp self % dist_sc ( n - 1 ) = 0.1_dp self % coeffs_e (:, 3 ) = [ 0._dp , 0._dp , 0._dp , 1.2_dp / d2 , & - 2.4_dp / d2 , & 1.2_dp / d2 , 0._dp , 0._dp , 0._dp ] ! third last line self % dist_sa ( n - 2 ) = 2._dp / 1 1._dp self % dist_sc ( n - 2 ) = 2._dp / 1 1._dp temp1 = 3._dp / 4 4._dp / d2 ; temp2 = 1 2._dp / 1 1._dp / d2 self % coeffs_e (:, 2 ) = [ 0._dp , 0._dp , temp1 , temp2 , & - 2._dp * ( temp1 + temp2 ), & temp2 , temp1 , 0._dp , 0._dp ] ! fourth last line is same as third last self % dist_sa ( n - 3 ) = 2._dp / 1 1._dp self % dist_sc ( n - 3 ) = 2._dp / 1 1._dp self % coeffs_e (:, 1 ) = self % coeffs_e (:, 2 ) end select call self % preprocess_thom ( dist_b ) call self % preprocess_dist ( dist_b ) end subroutine deriv_2nd subroutine interpl_mid ( self , scheme , from_to , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self character ( * ), intent ( in ) :: scheme , from_to integer , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , aici , bici , cici , dici integer :: i , n , n_halo if ( self % n_halo < 4 ) error stop 'Interpolation require n_halo >= 4' ! alpha is ailcai select case ( scheme ) case ( 'classic' ) alpha = 0.3_dp aici = 0.75_dp bici = 0.05_dp cici = 0._dp dici = 0._dp case ( 'optimised' ) alpha = 0.461658_dp dici = 0.00146508_dp aici = ( 7 5._dp + 7 0._dp * alpha - 64 0._dp * dici ) / 12 8._dp bici = ( - 2 5._dp + 12 6._dp * alpha + 230 4._dp * dici ) / 25 6._dp cici = ( 3._dp - 1 0._dp * alpha - 128 0._dp * dici ) / 25 6._dp case ( 'aggressive' ) alpha = 0.49_dp aici = ( 7 5._dp + 7 0._dp * alpha ) / 12 8._dp bici = ( - 2 5._dp + 12 6._dp * alpha ) / 25 6._dp cici = ( 3._dp - 1 0._dp * alpha ) / 25 6._dp dici = 0._dp case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = aici ; self % b = bici ; self % c = cici ; self % d = dici select case ( from_to ) case ( 'v2p' ) self % coeffs (:) = [ 0._dp , dici , cici , bici , & aici , & aici , bici , cici , dici ] case ( 'p2v' ) self % coeffs (:) = [ dici , cici , bici , aici , & aici , & bici , cici , dici , 0._dp ] end select do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % n_tds n_halo = self % n_halo allocate ( dist_b ( self % n_rhs )) dist_b (:) = 1._dp select case ( bc_start ) case ( BC_NEUMANN ) self % dist_sa ( 1 ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .true. dist_b ( 1 ) = 1._dp + alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & aici , & aici + bici , bici + cici , cici + dici , dici ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , bici , & aici + cici , & aici + dici , bici , cici , dici ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , cici , bici + dici , & aici , & aici , bici , cici , dici ] case ( 'p2v' ) ! sym is always .true. self % dist_sc ( 1 ) = 2 * alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & 2 * aici , & 2 * bici , 2 * cici , 2 * dici , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , aici + bici , & aici + cici , & bici + dici , cici , dici , 0._dp ] self % coeffs_s (:, 3 ) = [ 0._dp , 0._dp , bici + cici , aici + dici , & aici , & bici , cici , dici , 0._dp ] self % coeffs_s (:, 4 ) = [ 0._dp , cici + dici , bici , aici , & aici , & bici , cici , dici , 0._dp ] end select case ( BC_DIRICHLET ) error stop 'Dirichlet BC is not supported for midpoint interpolations!' end select select case ( bc_end ) case ( BC_NEUMANN ) self % dist_sc ( n ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .true. dist_b ( n ) = 1._dp + alpha self % coeffs_e (:, 4 ) = 0._dp self % coeffs_e (:, 3 ) = [ 0._dp , dici , cici + dici , bici + cici , & aici + bici , & aici , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ 0._dp , dici , cici , bici , & aici + dici , & aici + cici , bici , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ 0._dp , dici , cici , bici , & aici , & aici , bici + dici , cici , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sa ( n ) = 2 * alpha self % coeffs_e (:, 4 ) = [ 2 * dici , 2 * cici , 2 * bici , 2 * aici , & 0._dp , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 3 ) = [ dici , cici , bici + dici , aici + cici , & aici + bici , & 0._dp , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 2 ) = [ dici , cici , bici , aici , & aici + dici , & bici + cici , 0._dp , 0._dp , 0._dp ] self % coeffs_e (:, 1 ) = [ dici , cici , bici , aici , & aici , & bici , cici + dici , 0._dp , 0._dp ] end select case ( BC_DIRICHLET ) error stop 'Dirichlet BC is not supported for midpoint interpolations!' end select call self % preprocess_thom ( dist_b ) call self % preprocess_dist ( dist_b ) end subroutine interpl_mid subroutine stagder_1st ( self , delta , scheme , from_to , bc_start , bc_end , sym ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), intent ( in ) :: delta character ( * ), intent ( in ) :: scheme , from_to integer , intent ( in ) :: bc_start , bc_end logical , optional , intent ( in ) :: sym real ( dp ), allocatable :: dist_b (:) real ( dp ) :: alpha , aci , bci integer :: i , n , n_halo if ( self % n_halo < 2 ) error stop 'Staggared deriv require n_halo >= 2' ! alpha is alcai select case ( scheme ) case ( 'compact6' ) alpha = 9._dp / 6 2._dp aci = 6 3._dp / 6 2._dp / delta bci = 1 7._dp / 6 2._dp / 3._dp / delta case default error stop 'scheme is not defined' end select self % alpha = alpha self % a = aci ; self % b = bci select case ( from_to ) case ( 'v2p' ) self % coeffs (:) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci , & aci , bci , 0._dp , 0._dp ] case ( 'p2v' ) self % coeffs (:) = [ 0._dp , 0._dp , - bci , - aci , & aci , & bci , 0._dp , 0._dp , 0._dp ] end select do i = 1 , self % n_halo self % coeffs_s (:, i ) = self % coeffs (:) self % coeffs_e (:, i ) = self % coeffs (:) end do self % dist_sa (:) = alpha ; self % dist_sc (:) = alpha n = self % n_tds n_halo = self % n_halo allocate ( dist_b ( self % n_rhs )) dist_b (:) = 1._dp select case ( bc_start ) case ( BC_NEUMANN ) self % dist_sa ( 1 ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .false. dist_b ( 1 ) = 1._dp + alpha self % coeffs_s (:, 1 ) = [ 0._dp , 0._dp , 0._dp , 0._dp , & - aci - 2 * bci , & aci + bci , bci , 0._dp , 0._dp ] self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci , & aci , bci , 0._dp , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sc ( 1 ) = 0._dp self % coeffs_s (:, 1 ) = 0._dp self % coeffs_s (:, 2 ) = [ 0._dp , 0._dp , 0._dp , - aci - bci , & aci , & bci , 0._dp , 0._dp , 0._dp ] end select case ( BC_DIRICHLET ) error stop 'Dirichlet BC is not supported for midpoint derivatives!' end select select case ( bc_end ) case ( BC_NEUMANN ) self % dist_sc ( n ) = 0._dp select case ( from_to ) case ( 'v2p' ) ! sym is always .false. dist_b ( n ) = 1._dp + alpha self % coeffs_e (:, n_halo ) = 0._dp self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , 0._dp , - bci , & - aci - bci , & aci + 2 * bci , 0._dp , 0._dp , 0._dp ] case ( 'p2v' ) ! sym is always .true. self % dist_sa ( n ) = 0._dp self % coeffs_e (:, n_halo ) = 0._dp self % coeffs_e (:, n_halo - 1 ) = [ 0._dp , 0._dp , - bci , - aci , & aci + bci , & 0._dp , 0._dp , 0._dp , 0._dp ] end select case ( BC_DIRICHLET ) error stop 'Dirichlet BC is not supported for midpoint derivatives!' end select call self % preprocess_thom ( dist_b ) call self % preprocess_dist ( dist_b ) end subroutine stagder_1st subroutine preprocess_dist ( self , dist_b ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), dimension (:), intent ( in ) :: dist_b integer :: i ! Ref DOI: 10.1109/MCSE.2021.3130544 ! Algorithm 3 in page 4 ! First two lines first do i = 1 , 2 self % dist_sa ( i ) = self % dist_sa ( i ) / dist_b ( i ) self % dist_sc ( i ) = self % dist_sc ( i ) / dist_b ( i ) self % dist_bw ( i ) = self % dist_sc ( i ) self % dist_af ( i ) = 1._dp / dist_b ( i ) end do ! Then the remaining in the forward pass do i = 3 , self % n_tds ! Algorithm 3 in ref obtains 'r' coeffs on the fly in line 7. ! As we have to solve many RHSs with the same tridiagonal system, ! it is better to do a preprocessing first. ! So lets store 'r' coeff in dist_fw array. self % dist_fw ( i ) = 1._dp / ( dist_b ( i ) & - self % dist_sa ( i ) * self % dist_sc ( i - 1 )) ! dist_af is 'a_i' in line 7 of Algorithm 3 in ref. self % dist_af ( i ) = self % dist_sa ( i ) ! We store a_i&#94;* and c_i&#94;* in dist_sa and dist_sc because ! we need them later in the substitution phase. self % dist_sa ( i ) = - self % dist_fw ( i ) * self % dist_sa ( i ) & * self % dist_sa ( i - 1 ) self % dist_sc ( i ) = self % dist_fw ( i ) * self % dist_sc ( i ) end do ! backward pass starting in line 12 of Algorithm 3. do i = self % n_tds - 2 , 2 , - 1 self % dist_sa ( i ) = self % dist_sa ( i ) & - self % dist_sc ( i ) * self % dist_sa ( i + 1 ) self % dist_bw ( i ) = self % dist_sc ( i ) self % dist_sc ( i ) = - self % dist_sc ( i ) * self % dist_sc ( i + 1 ) end do ! Line 17 and 18 are tricky ! First we have a new 'r', we need it. ! And for 'r' we need c_0&#94;*... ! Now examine closely, c_0&#94;* is set in line 4 and never overwritten! ! So we can use dist_sc(1) as is in place of c_0&#94;*. ! We need to store this new 'r' somewhere ... ! dist_fw(1) is never used, so store this extra 'r' factor here instead self % dist_fw ( 1 ) = 1._dp / ( 1._dp - self % dist_sc ( 1 ) * self % dist_sa ( 2 )) ! Finally Line 19 and 20 in Algorithm 3 in ref. self % dist_sa ( 1 ) = self % dist_fw ( 1 ) * self % dist_sa ( 1 ) self % dist_sc ( 1 ) = - self % dist_fw ( 1 ) * self % dist_sc ( 1 ) * self % dist_sc ( 2 ) end subroutine preprocess_dist subroutine preprocess_thom ( self , b ) implicit none class ( tdsops_t ), intent ( inout ) :: self real ( dp ), dimension (:), intent ( in ) :: b integer :: i , n n = self % n_tds self % thom_w = b self % thom_f = self % dist_sc if ( self % periodic ) then self % thom_w ( 1 ) = 2._dp self % thom_w ( n ) = 1._dp + self % alpha * self % alpha end if self % thom_s ( 1 ) = 0._dp do i = 2 , n self % thom_s ( i ) = self % dist_sa ( i ) / self % thom_w ( i - 1 ) self % thom_w ( i ) = self % thom_w ( i ) - self % thom_f ( i - 1 ) * self % thom_s ( i ) end do do i = 1 , n self % thom_w ( i ) = 1._dp / self % thom_w ( i ) end do self % thom_p = [ - 1._dp , ( 0._dp , i = 2 , n - 1 ), self % alpha ] do i = 2 , n self % thom_p ( i ) = self % thom_p ( i ) - self % thom_p ( i - 1 ) * self % thom_s ( i ) end do self % thom_p ( n ) = self % thom_p ( n ) * self % thom_w ( n ) do i = n - 1 , 1 , - 1 self % thom_p ( i ) = self % thom_w ( i ) * ( self % thom_p ( i ) & - self % thom_f ( i ) * self % thom_p ( i + 1 )) end do end subroutine preprocess_thom end module m_tdsops","tags":"","url":"sourcefile/tdsops.f90~2.html"},{"title":"time_integrator.f90 – x3d2","text":"This file depends on sourcefile~~time_integrator.f90~~EfferentGraph sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~allocator.f90 allocator.f90 sourcefile~time_integrator.f90->sourcefile~allocator.f90 sourcefile~backend.f90~2 backend.f90 sourcefile~time_integrator.f90->sourcefile~backend.f90~2 sourcefile~common.f90 common.f90 sourcefile~time_integrator.f90->sourcefile~common.f90 sourcefile~field.f90 field.f90 sourcefile~time_integrator.f90->sourcefile~field.f90 sourcefile~allocator.f90->sourcefile~common.f90 sourcefile~allocator.f90->sourcefile~field.f90 sourcefile~backend.f90~2->sourcefile~allocator.f90 sourcefile~backend.f90~2->sourcefile~common.f90 sourcefile~backend.f90~2->sourcefile~field.f90 sourcefile~mesh.f90 mesh.f90 sourcefile~backend.f90~2->sourcefile~mesh.f90 sourcefile~poisson_fft.f90 poisson_fft.f90 sourcefile~backend.f90~2->sourcefile~poisson_fft.f90 sourcefile~tdsops.f90~2 tdsops.f90 sourcefile~backend.f90~2->sourcefile~tdsops.f90~2 sourcefile~field.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~common.f90 sourcefile~mesh.f90->sourcefile~field.f90 sourcefile~decomp_2decompfft.f90 decomp_2decompfft.f90 sourcefile~mesh.f90->sourcefile~decomp_2decompfft.f90 sourcefile~mesh_content.f90 mesh_content.f90 sourcefile~mesh.f90->sourcefile~mesh_content.f90 sourcefile~poisson_fft.f90->sourcefile~common.f90 sourcefile~poisson_fft.f90->sourcefile~field.f90 sourcefile~poisson_fft.f90->sourcefile~mesh.f90 sourcefile~poisson_fft.f90->sourcefile~tdsops.f90~2 sourcefile~tdsops.f90~2->sourcefile~common.f90 sourcefile~decomp_2decompfft.f90->sourcefile~mesh_content.f90 sourcefile~mesh_content.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~time_integrator.f90~~AfferentGraph sourcefile~time_integrator.f90 time_integrator.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time_integrator.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_time_integrator use m_allocator , only : allocator_t use m_base_backend , only : base_backend_t use m_common , only : dp , DIR_X use m_field , only : field_t , flist_t implicit none private adams_bashforth , runge_kutta type :: time_intg_t integer :: method , istep , istage , order , nstep , nstage , nvars , nolds real ( dp ) :: coeffs ( 4 , 4 ) real ( dp ) :: rk_b ( 4 , 4 ) real ( dp ) :: rk_a ( 3 , 3 , 4 ) character ( len = 3 ) :: sname type ( flist_t ), allocatable :: olds (:, :) class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator procedure ( stepper_func ), pointer :: step => null () contains procedure :: finalize procedure :: runge_kutta procedure :: adams_bashforth end type time_intg_t interface time_intg_t module procedure init end interface time_intg_t abstract interface subroutine stepper_func ( self , curr , deriv , dt ) import :: time_intg_t import :: dp import :: flist_t implicit none class ( time_intg_t ), intent ( inout ) :: self type ( flist_t ), intent ( inout ) :: curr (:) type ( flist_t ), intent ( in ) :: deriv (:) real ( dp ), intent ( in ) :: dt end subroutine stepper_func end interface contains subroutine finalize ( self ) implicit none !type(time_intg_t), intent(inout) :: self class ( time_intg_t ), intent ( inout ) :: self integer :: i , j ! Release all the storage for old timesteps do i = 1 , self % nvars do j = 1 , self % nolds call self % allocator % release_block ( self % olds ( i , j )% ptr ) end do end do ! deallocate memory deallocate ( self % olds ) print * , self % sname , ' time integrator deallocated' end subroutine finalize function init ( backend , allocator , method , nvars ) implicit none type ( time_intg_t ) :: init class ( base_backend_t ), pointer :: backend class ( allocator_t ), pointer :: allocator character ( 3 ), intent ( in ) :: method integer , intent ( in ) :: nvars integer :: i , j , stat ! initialize Runge-Kutta coefficients ! rk1 init % rk_a (:, 1 , 1 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_a (:, 2 , 1 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_a (:, 3 , 1 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_b (:, 1 ) = [ 1._dp , 0._dp , 0._dp , 0._dp ] ! rk2 init % rk_a (:, 1 , 2 ) = [ 0.5_dp , 0._dp , 0._dp ] init % rk_a (:, 2 , 2 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_a (:, 3 , 2 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_b (:, 2 ) = [ 0._dp , 1._dp , 0._dp , 0._dp ] ! rk3 init % rk_a (:, 1 , 3 ) = [ 0.5_dp , 0._dp , 0._dp ] init % rk_a (:, 2 , 3 ) = [ 0.0_dp , 3._dp / 4._dp , 0._dp ] init % rk_a (:, 3 , 3 ) = [ 0.0_dp , 0._dp , 0._dp ] init % rk_b (:, 3 ) = & [ 2._dp / 9.0_dp , 1._dp / 3._dp , 4._dp / 9._dp , 0._dp ] ! rk4 init % rk_a (:, 1 , 4 ) = [ 0.5_dp , 0._dp , 0._dp ] init % rk_a (:, 2 , 4 ) = [ 0._dp , 0.5_dp , 0._dp ] init % rk_a (:, 3 , 4 ) = [ 0._dp , 0._dp , 1._dp ] init % rk_b (:, 4 ) = & [ 1._dp / 6._dp , 1._dp / 3._dp , 1._dp / 3._dp , 1._dp / 6._dp ] ! initialize Adams-Bashforth coefficients ! ab1 init % coeffs (:, 1 ) = [ 1._dp , 0._dp , 0._dp , 0._dp ] ! ab2 init % coeffs (:, 2 ) = [ 1.5_dp , - 0.5_dp , 0._dp , 0._dp ] ! ab3 init % coeffs (:, 3 ) = & [ 2 3._dp / 1 2._dp , - 4._dp / 3._dp , 5._dp / 1 2._dp , 0._dp ] ! ab4 init % coeffs (:, 4 ) = & [ 5 5._dp / 2 4._dp , - 5 9._dp / 2 4._dp , 3 7._dp / 2 4._dp , - 3._dp / 8._dp ] ! set variables init % backend => backend init % allocator => allocator init % sname = method if ( init % sname ( 1 : 2 ) == 'AB' ) then read ( init % sname ( 3 : 3 ), * , iostat = stat ) init % order if ( stat /= 0 ) error stop 'Error reading AB integration order' if ( init % order >= 5 ) error stop 'Integration order >4 is not supported' init % nstep = init % order init % nstage = 1 init % nolds = init % nstep - 1 init % step => adams_bashforth else if ( init % sname ( 1 : 2 ) == 'RK' ) then read ( init % sname ( 3 : 3 ), * , iostat = stat ) init % order if ( stat /= 0 ) error stop 'Error reading RK integration order' if ( init % order >= 5 ) error stop 'Integration order >4 is not supported' init % nstep = 1 init % nstage = init % order init % nolds = init % nstage init % step => runge_kutta else print * , 'Integration method ' // init % sname // ' is not defined' error stop end if init % nvars = nvars init % istep = 1 init % istage = 1 ! allocate memory allocate ( init % olds ( init % nvars , init % nolds )) ! Request all the storage for old timesteps do i = 1 , init % nvars do j = 1 , init % nolds init % olds ( i , j )% ptr => allocator % get_block ( DIR_X ) end do end do end function init subroutine runge_kutta ( self , curr , deriv , dt ) implicit none class ( time_intg_t ), intent ( inout ) :: self type ( flist_t ), intent ( inout ) :: curr (:) type ( flist_t ), intent ( in ) :: deriv (:) real ( dp ), intent ( in ) :: dt integer :: i , j ! update solution if ( self % istage == self % nstage ) then do i = 1 , self % nvars ! update step solution from stage derivative if ( self % nstage > 1 ) then call self % backend % veccopy ( curr ( i )% ptr , self % olds ( i , 1 )% ptr ) end if do j = 1 , self % nstage - 1 call self % backend % vecadd ( self % rk_b ( j , self % nstage ) * dt , & self % olds ( i , j + 1 )% ptr , & 1._dp , curr ( i )% ptr ) end do call self % backend % vecadd ( self % rk_b ( self % nstage , self % nstage ) * dt , & deriv ( i )% ptr , & 1._dp , curr ( i )% ptr ) end do ! reset stage counter self % istage = 1 else do i = 1 , self % nvars ! save step initial condition if ( self % istage == 1 ) then call self % backend % veccopy ( self % olds ( i , 1 )% ptr , curr ( i )% ptr ) end if ! save stage derivative call self % backend % veccopy ( self % olds ( i , self % istage + 1 )% ptr , & deriv ( i )% ptr ) ! update stage solution if ( self % istage > 1 ) then call self % backend % veccopy ( curr ( i )% ptr , self % olds ( i , 1 )% ptr ) end if do j = 1 , self % istage call self % backend % vecadd ( self % rk_a ( j , self % istage , self % nstage ) * dt , & self % olds ( i , j + 1 )% ptr , & 1._dp , curr ( i )% ptr ) end do end do ! increment stage counter self % istage = self % istage + 1 end if end subroutine runge_kutta subroutine adams_bashforth ( self , curr , deriv , dt ) implicit none class ( time_intg_t ), intent ( inout ) :: self type ( flist_t ), intent ( inout ) :: curr (:) type ( flist_t ), intent ( in ) :: deriv (:) real ( dp ), intent ( in ) :: dt integer :: i , j integer :: nstep nstep = min ( self % istep , self % nstep ) do i = 1 , self % nvars ! update solution call self % backend % vecadd ( self % coeffs ( 1 , nstep ) * dt , & deriv ( i )% ptr , & 1._dp , curr ( i )% ptr ) do j = 2 , nstep call self % backend % vecadd ( self % coeffs ( j , nstep ) * dt , & self % olds ( i , j - 1 )% ptr , & 1._dp , curr ( i )% ptr ) end do ! rotate pointers if ( nstep < self % nstep ) then ! for startup if ( self % istep > 1 ) then call rotate ( self % olds ( i , :), nstep ) end if else ! after startup if ( self % nstep > 2 ) then call rotate ( self % olds ( i , :), nstep - 1 ) end if end if ! update olds(1) with new derivative if ( self % nstep > 1 ) then call self % backend % veccopy ( self % olds ( i , 1 )% ptr , deriv ( i )% ptr ) end if end do ! increment step counter self % istep = self % istep + 1 end subroutine adams_bashforth subroutine rotate ( sol , n ) implicit none type ( flist_t ), intent ( inout ) :: sol (:) integer , intent ( in ) :: n integer :: i class ( field_t ), pointer :: ptr ! rotate pointer ptr => sol ( n )% ptr do i = n , 2 , - 1 sol ( i )% ptr => sol ( i - 1 )% ptr end do sol ( 1 )% ptr => ptr end subroutine rotate end module m_time_integrator","tags":"","url":"sourcefile/time_integrator.f90.html"},{"title":"ordering.f90 – x3d2","text":"This file depends on sourcefile~~ordering.f90~~EfferentGraph sourcefile~ordering.f90 ordering.f90 sourcefile~common.f90 common.f90 sourcefile~ordering.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~ordering.f90~~AfferentGraph sourcefile~ordering.f90 ordering.f90 sourcefile~backend.f90 backend.f90 sourcefile~backend.f90->sourcefile~ordering.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_ordering use m_common , only : dp , get_dirs_from_rdr , DIR_X , DIR_Y , DIR_Z , DIR_C implicit none contains !! !! \"Application storage\" stores spatial data with a directionality for better cache locality !!  This set of functions converts indices from this application storage (_dir) to cartesian indices (_ijk) !! pure subroutine get_index_ijk ( i , j , k , dir_i , dir_j , dir_k , dir , & SZ , nx_padded , ny_padded , nz_padded ) !! Get cartesian index from application storage directional one integer , intent ( out ) :: i , j , k ! cartesian indices integer , intent ( in ) :: dir_i , dir_j , dir_k ! application storage indices integer , intent ( in ) :: dir ! direction of the applicatino storage indices integer , intent ( in ) :: SZ , nx_padded , ny_padded , nz_padded ! dimensions of the block select case ( dir ) case ( DIR_X ) i = dir_j j = mod ( dir_k - 1 , ny_padded / SZ ) * SZ + dir_i k = 1 + ( dir_k - 1 ) / ( ny_padded / SZ ) case ( DIR_Y ) i = mod ( dir_k - 1 , nx_padded / SZ ) * SZ + dir_i j = dir_j k = 1 + ( dir_k - 1 ) / ( nx_padded / SZ ) case ( DIR_Z ) i = mod ( dir_k - 1 , nx_padded / SZ ) * SZ + dir_i j = 1 + ( dir_k - 1 ) / ( nx_padded / SZ ) k = dir_j case ( DIR_C ) i = dir_i j = dir_j k = dir_k end select end subroutine get_index_ijk pure subroutine get_index_dir ( dir_i , dir_j , dir_k , i , j , k , dir , & SZ , nx_padded , ny_padded , nz_padded ) !! Get application storage directional index from cartesian index integer , intent ( out ) :: dir_i , dir_j , dir_k ! application storage indices integer , intent ( in ) :: i , j , k ! cartesian indices integer , intent ( in ) :: dir ! direction of the application storage indices integer , intent ( in ) :: SZ , nx_padded , ny_padded , nz_padded ! dimensions of the block select case ( dir ) case ( DIR_X ) dir_i = mod ( j - 1 , SZ ) + 1 dir_j = i dir_k = ( ny_padded / SZ ) * ( k - 1 ) + 1 + ( j - 1 ) / SZ case ( DIR_Y ) dir_i = mod ( i - 1 , SZ ) + 1 dir_j = j dir_k = ( nx_padded / SZ ) * ( k - 1 ) + 1 + ( i - 1 ) / SZ case ( DIR_Z ) dir_i = mod ( i - 1 , SZ ) + 1 dir_j = k dir_k = ( nx_padded / SZ ) * ( j - 1 ) + 1 + ( i - 1 ) / SZ case ( DIR_C ) dir_i = i dir_j = j dir_k = k end select end subroutine get_index_dir pure subroutine get_index_reordering ( & out_i , out_j , out_k , in_i , in_j , in_k , dir_from , dir_to , sz , cart_padded & ) !! Converts indices in between any two DIR_? integer , intent ( out ) :: out_i , out_j , out_k ! output indices integer , intent ( in ) :: in_i , in_j , in_k ! input indices integer , intent ( in ) :: dir_from , dir_to integer , intent ( in ) :: sz integer , intent ( in ) :: cart_padded ( 3 ) ! padded cartesian dimensions integer :: i , j , k ! Intermediary cartesian indices call get_index_ijk ( i , j , k , in_i , in_j , in_k , dir_from , sz , & cart_padded ( 1 ), cart_padded ( 2 ), cart_padded ( 3 )) call get_index_dir ( out_i , out_j , out_k , i , j , k , dir_to , sz , & cart_padded ( 1 ), cart_padded ( 2 ), cart_padded ( 3 )) end subroutine get_index_reordering end module m_ordering","tags":"","url":"sourcefile/ordering.f90.html"},{"title":"spectral_processing.f90 – x3d2","text":"This file depends on sourcefile~~spectral_processing.f90~2~~EfferentGraph sourcefile~spectral_processing.f90~2 spectral_processing.f90 sourcefile~common.f90 common.f90 sourcefile~spectral_processing.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~spectral_processing.f90~2~~AfferentGraph sourcefile~spectral_processing.f90~2 spectral_processing.f90 sourcefile~poisson_fft.f90~2 poisson_fft.f90 sourcefile~poisson_fft.f90~2->sourcefile~spectral_processing.f90~2 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~poisson_fft.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_spectral use cudafor use m_common , only : dp implicit none contains attributes ( global ) subroutine memcpy3D ( dst , src , nx , ny , nz ) !! Copy data between x3d2 padded arrays and cuFFTMp descriptors implicit none real ( dp ), device , intent ( inout ), dimension (:, :, :) :: dst real ( dp ), device , intent ( in ), dimension (:, :, :) :: src integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k j = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x !ny k = blockIdx % y !nz if ( j <= ny ) then do i = 1 , nx dst ( i , j , k ) = src ( i , j , k ) end do end if end subroutine memcpy3D attributes ( global ) subroutine memcpy3D_with_transpose ( dst , src , nx , ny , nz ) !! Copy with transpose: src(nx, ny, nz) -> dst(ny, nx, nz) !! Used for 100 case forward FFT implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: dst ! (ny+2, nx, nz) but we only write (ny, nx, nz) real ( dp ), device , intent ( in ), dimension (:, :, :) :: src ! (nx, ny, nz) integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k i = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x ! iterates over nx k = blockIdx % y ! nz if ( i <= nx ) then do j = 1 , ny ! Transpose: dst(j, i, k) = src(i, j, k) dst ( j , i , k ) = src ( i , j , k ) end do end if end subroutine memcpy3D_with_transpose attributes ( global ) subroutine memcpy3D_with_transpose_back ( & dst , src , nx , ny , nz & ) !! Copy with transpose back: src(ny, nx, nz) -> dst(nx, ny, nz) !! Used for 100 case backward FFT implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: dst ! (nx, ny, nz) real ( dp ), device , intent ( in ), dimension (:, :, :) :: src ! (ny+2, nx, nz) but we only read (ny, nx, nz) integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k i = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x ! iterates over nx k = blockIdx % y ! nz if ( i <= nx ) then do j = 1 , ny ! Transpose back: dst(i, j, k) = src(j, i, k) dst ( i , j , k ) = src ( j , i , k ) end do end if end subroutine memcpy3D_with_transpose_back attributes ( global ) subroutine process_spectral_000 ( & div_u , waves , nx_spec , ny_spec , y_sp_st , nx , ny , nz , & ax , bx , ay , by , az , bz & ) !! Post-processes the divergence of velocity in spectral space, including !! scaling w.r.t. grid size. !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none !> Divergence of velocity in spectral space complex ( dp ), device , intent ( inout ), dimension (:, :, :) :: div_u !> Spectral equivalence constants complex ( dp ), device , intent ( in ), dimension (:, :, :) :: waves real ( dp ), device , intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz !> Grid size in spectral space integer , value , intent ( in ) :: nx_spec , ny_spec !> Offset in y direction in the permuted slabs in spectral space integer , value , intent ( in ) :: y_sp_st !> Grid size integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k , ix , iy , iz real ( dp ) :: tmp_r , tmp_c , div_r , div_c j = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x k = blockIdx % y ! nz_spec if ( j <= ny_spec ) then do i = 1 , nx_spec ! normalisation div_r = real ( div_u ( i , j , k ), kind = dp ) / nx / ny / nz div_c = aimag ( div_u ( i , j , k )) / nx / ny / nz ix = i ; iy = j + y_sp_st ; iz = k ! post-process forward ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) + tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in y tmp_r = div_r tmp_c = div_c div_r = tmp_r * by ( iy ) + tmp_c * ay ( iy ) div_c = tmp_c * by ( iy ) - tmp_r * ay ( iy ) if ( iy > ny / 2 + 1 ) div_r = - div_r if ( iy > ny / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) - tmp_r * ax ( ix ) ! Solve Poisson tmp_r = real ( waves ( i , j , k ), kind = dp ) tmp_c = aimag ( waves ( i , j , k )) if (( tmp_r < 1.e-16_dp ) . or . ( tmp_c < 1.e-16_dp )) then div_r = 0._dp ; div_c = 0._dp else div_r = - div_r / tmp_r div_c = - div_c / tmp_c end if ! post-process backward ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) - tmp_c * az ( iz ) div_c = - tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in y tmp_r = div_r tmp_c = div_c div_r = tmp_r * by ( iy ) + tmp_c * ay ( iy ) div_c = tmp_c * by ( iy ) - tmp_r * ay ( iy ) if ( iy > ny / 2 + 1 ) div_r = - div_r if ( iy > ny / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = - tmp_c * bx ( ix ) + tmp_r * ax ( ix ) ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end if end subroutine process_spectral_000 attributes ( global ) subroutine process_spectral_010 ( & div_u , waves , nx_spec , ny_spec , y_sp_st , nx , ny , nz , & ax , bx , ay , by , az , bz & ) !! Post-processes the divergence of velocity in spectral space, including !! scaling w.r.t. grid size. !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none !> Divergence of velocity in spectral space complex ( dp ), device , intent ( inout ), dimension (:, :, :) :: div_u !> Spectral equivalence constants complex ( dp ), device , intent ( in ), dimension (:, :, :) :: waves real ( dp ), device , intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz !> Grid size in spectral space integer , value , intent ( in ) :: nx_spec , ny_spec !> Offset in y direction in the permuted slabs in spectral space integer , value , intent ( in ) :: y_sp_st !> Grid size integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k , ix , iy , iz , iy_rev real ( dp ) :: tmp_r , tmp_c , div_r , div_c , l_r , l_c , r_r , r_c i = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x k = blockIdx % y ! nz_spec if ( i <= nx_spec ) then do j = 1 , ny_spec ix = i ; iy = j + y_sp_st ; iz = k ! normalisation div_r = real ( div_u ( i , j , k ), kind = dp ) / nx / ny / nz div_c = aimag ( div_u ( i , j , k )) / nx / ny / nz ! postprocess in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) + tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! postprocess in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) - tmp_r * ax ( ix ) if ( ix > nx / 2 + 1 ) div_r = - div_r if ( ix > nx / 2 + 1 ) div_c = - div_c ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end if if ( i <= nx_spec ) then do j = 2 , ny_spec / 2 + 1 ix = i ; iy = j + y_sp_st ; iz = k iy_rev = ny_spec - j + 2 + y_sp_st l_r = real ( div_u ( i , j , k ), kind = dp ) l_c = aimag ( div_u ( i , j , k )) r_r = real ( div_u ( i , ny_spec - j + 2 , k ), kind = dp ) r_c = aimag ( div_u ( i , ny_spec - j + 2 , k )) ! update the entry div_u ( i , j , k ) = 0.5_dp * cmplx ( & !& l_r * by ( iy ) + l_c * ay ( iy ) + r_r * by ( iy ) - r_c * ay ( iy ), & - l_r * ay ( iy ) + l_c * by ( iy ) + r_r * ay ( iy ) + r_c * by ( iy ), kind = dp & ) div_u ( i , ny_spec - j + 2 , k ) = 0.5_dp * cmplx ( & !& r_r * by ( iy_rev ) + r_c * ay ( iy_rev ) + l_r * by ( iy_rev ) - l_c * ay ( iy_rev ), & - r_r * ay ( iy_rev ) + r_c * by ( iy_rev ) + l_r * ay ( iy_rev ) + l_c * by ( iy_rev ), & kind = dp & ) end do end if ! Solve Poisson if ( i <= nx_spec ) then do j = 1 , ny_spec div_r = real ( div_u ( i , j , k ), kind = dp ) div_c = aimag ( div_u ( i , j , k )) tmp_r = real ( waves ( i , j , k ), kind = dp ) tmp_c = aimag ( waves ( i , j , k )) if ( abs ( tmp_r ) < 1.e-16_dp ) then div_r = 0._dp else div_r = - div_r / tmp_r end if if ( abs ( tmp_c ) < 1.e-16_dp ) then div_c = 0._dp else div_c = - div_c / tmp_c end if ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) if ( i == nx / 2 + 1 . and . k == nz / 2 + 1 ) div_u ( i , j , k ) = 0._dp end do end if ! post-process backward if ( i <= nx_spec ) then do j = 2 , ny_spec / 2 + 1 ix = i ; iy = j + y_sp_st ; iz = k iy_rev = ny_spec - j + 2 + y_sp_st l_r = real ( div_u ( i , j , k ), kind = dp ) l_c = aimag ( div_u ( i , j , k )) r_r = real ( div_u ( i , ny_spec - j + 2 , k ), kind = dp ) r_c = aimag ( div_u ( i , ny_spec - j + 2 , k )) ! update the entry div_u ( i , j , k ) = cmplx ( & !& l_r * by ( iy ) - l_c * ay ( iy ) + r_r * ay ( iy ) + r_c * by ( iy ), & l_r * ay ( iy ) + l_c * by ( iy ) - r_r * by ( iy ) + r_c * ay ( iy ), kind = dp & ) div_u ( i , ny_spec - j + 2 , k ) = cmplx ( & !& r_r * by ( iy_rev ) - r_c * ay ( iy_rev ) + l_r * ay ( iy_rev ) + l_c * by ( iy_rev ), & r_r * ay ( iy_rev ) + r_c * by ( iy_rev ) - l_r * by ( iy_rev ) + l_c * ay ( iy_rev ), & kind = dp & ) end do end if if ( i <= nx_spec ) then do j = 1 , ny_spec ix = i ; iy = j + y_sp_st ; iz = k div_r = real ( div_u ( i , j , k ), kind = dp ) div_c = aimag ( div_u ( i , j , k )) ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) - tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) + tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) - tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) + tmp_r * ax ( ix ) if ( ix > nx / 2 + 1 ) div_r = - div_r if ( ix > nx / 2 + 1 ) div_c = - div_c ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end if end subroutine process_spectral_010 attributes ( global ) subroutine process_spectral_010_fw ( & div_u , nx_spec , ny_spec , y_sp_st , nx , ny , nz , ax , bx , ay , by , az , bz & ) !! Post-processes the divergence of velocity in spectral space, including !! scaling w.r.t. grid size. !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none !> Divergence of velocity in spectral space complex ( dp ), device , intent ( inout ), dimension (:, :, :) :: div_u !> Spectral equivalence constants real ( dp ), device , intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz !> Grid size in spectral space integer , value , intent ( in ) :: nx_spec , ny_spec !> Offset in y direction in the permuted slabs in spectral space integer , value , intent ( in ) :: y_sp_st !> Grid size integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k , ix , iy , iz , iy_rev real ( dp ) :: tmp_r , tmp_c , div_r , div_c , l_r , l_c , r_r , r_c i = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x k = blockIdx % y ! nz_spec if ( i <= nx_spec ) then do j = 1 , ny_spec ix = i ; iy = j + y_sp_st ; iz = k ! normalisation div_r = real ( div_u ( i , j , k ), kind = dp ) / nx / ny / nz div_c = aimag ( div_u ( i , j , k )) / nx / ny / nz ! postprocess in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) + tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! postprocess in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) + tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) - tmp_r * ax ( ix ) if ( ix > nx / 2 + 1 ) div_r = - div_r if ( ix > nx / 2 + 1 ) div_c = - div_c ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end if if ( i <= nx_spec ) then do j = 2 , ny_spec / 2 + 1 ix = i ; iy = j + y_sp_st ; iz = k iy_rev = ny_spec - j + 2 + y_sp_st l_r = real ( div_u ( i , j , k ), kind = dp ) l_c = aimag ( div_u ( i , j , k )) r_r = real ( div_u ( i , ny_spec - j + 2 , k ), kind = dp ) r_c = aimag ( div_u ( i , ny_spec - j + 2 , k )) ! update the entry div_u ( i , j , k ) = 0.5_dp * cmplx ( & !& l_r * by ( iy ) + l_c * ay ( iy ) + r_r * by ( iy ) - r_c * ay ( iy ), & - l_r * ay ( iy ) + l_c * by ( iy ) + r_r * ay ( iy ) + r_c * by ( iy ), kind = dp & ) div_u ( i , ny_spec - j + 2 , k ) = 0.5_dp * cmplx ( & !& r_r * by ( iy_rev ) + r_c * ay ( iy_rev ) + l_r * by ( iy_rev ) - l_c * ay ( iy_rev ), & - r_r * ay ( iy_rev ) + r_c * by ( iy_rev ) + l_r * ay ( iy_rev ) + l_c * by ( iy_rev ), & kind = dp & ) end do end if end subroutine process_spectral_010_fw attributes ( global ) subroutine process_spectral_010_poisson ( & div_u , a_re , a_im , off , inc , nx_spec , n , nx , ny , nz & ) !! Solve the Poisson equation at cell centres with non-perioic BC along y !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none !> Divergence of velocity in spectral space complex ( dp ), device , intent ( inout ), dimension (:, :, :) :: div_u !> Spectral equivalence constants real ( dp ), device , intent ( inout ), dimension (:, :, :, :) :: a_re , a_im !> offset and increment. increment is 2 when considering only odd or even integer , value , intent ( in ) :: off , inc !> Grid size in spectral space integer , value , intent ( in ) :: nx_spec , n , nx , ny , nz integer :: i , j , k , jm , nm real ( dp ) :: tmp_r , tmp_c , div_r , div_c , epsilon i = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x k = blockIdx % y ! nz_spec epsilon = 1.e-16_dp ! Solve Poisson if ( i <= nx_spec ) then ! Forward pass for the pentadiagonal matrix do j = 1 , n - 2 ! j mapping based on odd/even ! inc=2, off=0 ---> j => 2j - 1 ! inc=2, off=1 ---> j => 2j ! inc=1, off=0 ---> j => j jm = inc * j + off - inc / 2 ! eliminate diag-1 tmp_r = 0._dp if ( abs ( a_re ( i , j , k , 3 )) > epsilon ) then tmp_r = a_re ( i , j + 1 , k , 2 ) / a_re ( i , j , k , 3 ) end if tmp_c = 0._dp if ( abs ( a_im ( i , j , k , 3 )) > epsilon ) then tmp_c = a_im ( i , j + 1 , k , 2 ) / a_im ( i , j , k , 3 ) end if div_r = real ( div_u ( i , jm + inc , k ) - tmp_r * div_u ( i , jm , k ), kind = dp ) div_c = aimag ( div_u ( i , jm + inc , k ) - tmp_c * div_u ( i , jm , k )) div_u ( i , jm + inc , k ) = cmplx ( div_r , div_c , kind = dp ) ! modify pentadiagonal coefficients in-place a_re ( i , j + 1 , k , 3 ) = a_re ( i , j + 1 , k , 3 ) - tmp_r * a_re ( i , j , k , 4 ) a_im ( i , j + 1 , k , 3 ) = a_im ( i , j + 1 , k , 3 ) - tmp_c * a_im ( i , j , k , 4 ) a_re ( i , j + 1 , k , 4 ) = a_re ( i , j + 1 , k , 4 ) - tmp_r * a_re ( i , j , k , 5 ) a_im ( i , j + 1 , k , 4 ) = a_im ( i , j + 1 , k , 4 ) - tmp_c * a_im ( i , j , k , 5 ) ! eliminate diag-2 tmp_r = 0._dp if ( abs ( a_re ( i , j , k , 3 )) > epsilon ) then tmp_r = a_re ( i , j + 2 , k , 1 ) / a_re ( i , j , k , 3 ) end if tmp_c = 0._dp if ( abs ( a_im ( i , j , k , 3 )) > epsilon ) then tmp_c = a_im ( i , j + 2 , k , 1 ) / a_im ( i , j , k , 3 ) end if div_r = real ( div_u ( i , jm + 2 * inc , k ) - tmp_r * div_u ( i , jm , k ), kind = dp ) div_c = aimag ( div_u ( i , jm + 2 * inc , k ) - tmp_c * div_u ( i , jm , k )) div_u ( i , jm + 2 * inc , k ) = cmplx ( div_r , div_c , kind = dp ) ! modify pentadiagonal coefficients in-place a_re ( i , j + 2 , k , 2 ) = a_re ( i , j + 2 , k , 2 ) - tmp_r * a_re ( i , j , k , 4 ) a_im ( i , j + 2 , k , 2 ) = a_im ( i , j + 2 , k , 2 ) - tmp_c * a_im ( i , j , k , 4 ) a_re ( i , j + 2 , k , 3 ) = a_re ( i , j + 2 , k , 3 ) - tmp_r * a_re ( i , j , k , 5 ) a_im ( i , j + 2 , k , 3 ) = a_im ( i , j + 2 , k , 3 ) - tmp_c * a_im ( i , j , k , 5 ) end do ! handle the last row if ( abs ( a_re ( i , n - 1 , k , 3 )) > epsilon ) then tmp_r = a_re ( i , n , k , 2 ) / a_re ( i , n - 1 , k , 3 ) else tmp_r = 0._dp end if if ( abs ( a_im ( i , n - 1 , k , 3 )) > epsilon ) then tmp_c = a_im ( i , n , k , 2 ) / a_im ( i , n - 1 , k , 3 ) else tmp_c = 0._dp end if div_r = a_re ( i , n , k , 3 ) - tmp_r * a_re ( i , n - 1 , k , 4 ) div_c = a_im ( i , n , k , 3 ) - tmp_c * a_im ( i , n - 1 , k , 4 ) ! j mapping based on odd/even for last point j=n nm = inc * n + off - inc / 2 if ( abs ( div_r ) > epsilon ) then tmp_r = tmp_r / div_r div_r = real ( div_u ( i , nm , k ), kind = dp ) / div_r & - tmp_r * real ( div_u ( i , nm - inc , k ), kind = dp ) else tmp_r = 0._dp div_r = 0._dp end if if ( abs ( div_c ) > epsilon ) then tmp_c = tmp_c / div_c div_c = aimag ( div_u ( i , nm , k )) / div_c & - tmp_c * aimag ( div_u ( i , nm - inc , k )) else tmp_c = 0._dp div_c = 0._dp end if div_u ( i , nm , k ) = cmplx ( div_r , div_c , kind = dp ) if ( abs ( a_re ( i , n - 1 , k , 3 )) > epsilon ) then tmp_r = 1._dp / a_re ( i , n - 1 , k , 3 ) else tmp_r = 0._dp end if if ( abs ( a_im ( i , n - 1 , k , 3 )) > epsilon ) then tmp_c = 1._dp / a_im ( i , n - 1 , k , 3 ) else tmp_c = 0._dp end if div_r = a_re ( i , n - 1 , k , 4 ) * tmp_r div_c = a_im ( i , n - 1 , k , 4 ) * tmp_c div_u ( i , nm - inc , k ) = cmplx ( & !& real ( div_u ( i , nm - inc , k ), kind = dp ) * tmp_r & - real ( div_u ( i , nm , k ), kind = dp ) * div_r , & aimag ( div_u ( i , nm - inc , k )) * tmp_c & - aimag ( div_u ( i , nm , k )) * div_c , & kind = dp & ) if ( i == nx / 2 + 1 . and . k == nz / 2 + 1 ) then div_u ( i , nm , k ) = 0._dp div_u ( i , nm - inc , k ) = 0._dp end if ! backward pass do j = n - 2 , 1 , - 1 ! j mapping based on odd/even jm = inc * j + off - inc / 2 if ( abs ( a_re ( i , j , k , 3 )) > epsilon ) then tmp_r = 1._dp / a_re ( i , j , k , 3 ) else tmp_r = 0._dp end if if ( abs ( a_im ( i , j , k , 3 )) > epsilon ) then tmp_c = 1._dp / a_im ( i , j , k , 3 ) else tmp_c = 0._dp end if div_u ( i , jm , k ) = cmplx ( & !& tmp_r * ( real ( div_u ( i , jm , k ), kind = dp ) & - a_re ( i , j , k , 4 ) * real ( div_u ( i , jm + inc , k ), kind = dp ) & - a_re ( i , j , k , 5 ) * real ( div_u ( i , jm + 2 * inc , k ), kind = dp )), & tmp_c * ( aimag ( div_u ( i , jm , k )) & - a_im ( i , j , k , 4 ) * aimag ( div_u ( i , jm + inc , k )) & - a_im ( i , j , k , 5 ) * aimag ( div_u ( i , jm + 2 * inc , k ))), & kind = dp & ) if ( i == nx / 2 + 1 . and . k == nz / 2 + 1 ) div_u ( i , jm , k ) = 0._dp end do end if end subroutine process_spectral_010_poisson attributes ( global ) subroutine process_spectral_010_bw ( & div_u , nx_spec , ny_spec , y_sp_st , nx , ny , nz , ax , bx , ay , by , az , bz & ) !! Post-processes the divergence of velocity in spectral space, including !! scaling w.r.t. grid size. !! !! Ref. JCP 228 (2009), 5989–6015, Sec 4 implicit none !> Divergence of velocity in spectral space complex ( dp ), device , intent ( inout ), dimension (:, :, :) :: div_u !> Spectral equivalence constants real ( dp ), device , intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz !> Grid size in spectral space integer , value , intent ( in ) :: nx_spec , ny_spec !> Offset in y direction in the permuted slabs in spectral space integer , value , intent ( in ) :: y_sp_st !> Grid size integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k , ix , iy , iz , iy_rev real ( dp ) :: tmp_r , tmp_c , div_r , div_c , l_r , l_c , r_r , r_c i = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x k = blockIdx % y ! nz_spec ! post-process backward if ( i <= nx_spec ) then do j = 2 , ny_spec / 2 + 1 ix = i ; iy = j + y_sp_st ; iz = k iy_rev = ny_spec - j + 2 + y_sp_st l_r = real ( div_u ( i , j , k ), kind = dp ) l_c = aimag ( div_u ( i , j , k )) r_r = real ( div_u ( i , ny_spec - j + 2 , k ), kind = dp ) r_c = aimag ( div_u ( i , ny_spec - j + 2 , k )) ! update the entry div_u ( i , j , k ) = cmplx ( & !& l_r * by ( iy ) - l_c * ay ( iy ) + r_r * ay ( iy ) + r_c * by ( iy ), & l_r * ay ( iy ) + l_c * by ( iy ) - r_r * by ( iy ) + r_c * ay ( iy ), kind = dp & ) div_u ( i , ny_spec - j + 2 , k ) = cmplx ( & !& r_r * by ( iy_rev ) - r_c * ay ( iy_rev ) + l_r * ay ( iy_rev ) + l_c * by ( iy_rev ), & r_r * ay ( iy_rev ) + r_c * by ( iy_rev ) - l_r * by ( iy_rev ) + l_c * ay ( iy_rev ), & kind = dp & ) end do end if if ( i <= nx_spec ) then do j = 1 , ny_spec ix = i ; iy = j + y_sp_st ; iz = k div_r = real ( div_u ( i , j , k ), kind = dp ) div_c = aimag ( div_u ( i , j , k )) ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) - tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) + tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! post-process in x tmp_r = div_r tmp_c = div_c div_r = tmp_r * bx ( ix ) - tmp_c * ax ( ix ) div_c = tmp_c * bx ( ix ) + tmp_r * ax ( ix ) if ( ix > nx / 2 + 1 ) div_r = - div_r if ( ix > nx / 2 + 1 ) div_c = - div_c ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end if end subroutine process_spectral_010_bw attributes ( global ) subroutine process_spectral_110 ( & div_u , waves , nx_spec , ny_spec , x_sp_st , y_sp_st , nx , ny , nz , & ax , bx , ay , by , az , bz & ) !! Post-processes for Dirichlet BC in X and Y, periodic in Z implicit none complex ( dp ), device , intent ( inout ), dimension (:, :, :) :: div_u complex ( dp ), device , intent ( in ), dimension (:, :, :) :: waves real ( dp ), device , intent ( in ), dimension (:) :: ax , bx , ay , by , az , bz integer , value , intent ( in ) :: nx_spec , ny_spec integer , value , intent ( in ) :: x_sp_st , y_sp_st integer , value , intent ( in ) :: nx , ny , nz integer :: i , j , k , ix , iy , iz , iy_rev real ( dp ) :: tmp_r , tmp_c , div_r , div_c real ( dp ) :: l_r , l_c , r_r , r_c i = threadIdx % x + ( blockIdx % x - 1 ) * blockDim % x k = blockIdx % y ! nz_spec ! ================================================================ ! FORWARD PASS ! ================================================================ ! Step 1: Normalise and periodic post-process in z if ( i <= nx_spec ) then do j = 1 , ny_spec ix = i + x_sp_st ; iy = j + y_sp_st ; iz = k ! normalisation div_r = real ( div_u ( i , j , k ), kind = dp ) / nx / ny / nz div_c = aimag ( div_u ( i , j , k )) / nx / ny / nz ! postprocess in z (periodic) tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) + tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) - tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end if ! Step 2: Paired even/odd splitting for y (Dirichlet direction) if ( i <= nx_spec ) then do j = 2 , ny_spec / 2 + 1 iy = j + y_sp_st iy_rev = ny_spec - j + 2 + y_sp_st l_r = real ( div_u ( i , j , k ), kind = dp ) l_c = aimag ( div_u ( i , j , k )) r_r = real ( div_u ( i , ny_spec - j + 2 , k ), kind = dp ) r_c = aimag ( div_u ( i , ny_spec - j + 2 , k )) ! update the entry div_u ( i , j , k ) = 0.5_dp * cmplx ( & !& l_r * by ( iy ) + l_c * ay ( iy ) + r_r * by ( iy ) - r_c * ay ( iy ), & - l_r * ay ( iy ) + l_c * by ( iy ) + r_r * ay ( iy ) + r_c * by ( iy ), kind = dp & ) div_u ( i , ny_spec - j + 2 , k ) = 0.5_dp * cmplx ( & !& r_r * by ( iy_rev ) + r_c * ay ( iy_rev ) + l_r * by ( iy_rev ) - l_c * ay ( iy_rev ), & - r_r * ay ( iy_rev ) + r_c * by ( iy_rev ) + l_r * ay ( iy_rev ) + l_c * by ( iy_rev ), & kind = dp & ) end do end if ! NOTE: No x-direction paired splitting! ! For the R2C FFT output, the x-direction Dirichlet BC is handled ! implicitly through the waves_set. ! The R2C output only contains nx/2+1 values (wavenumbers 0 to nx/2), ! so there's no \"pairing\" to do ! ================================================================ ! POISSON SOLVE ! ================================================================ if ( i <= nx_spec ) then do j = 1 , ny_spec ix = i + x_sp_st div_r = real ( div_u ( i , j , k ), kind = dp ) div_c = aimag ( div_u ( i , j , k )) tmp_r = real ( waves ( i , j , k ), kind = dp ) tmp_c = aimag ( waves ( i , j , k )) if ( abs ( tmp_r ) < 1.e-16_dp ) then div_r = 0._dp else div_r = - div_r / tmp_r end if if ( abs ( tmp_c ) < 1.e-16_dp ) then div_c = 0._dp else div_c = - div_c / tmp_c end if ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) ! Zero out the mode at (nx/2+1, *, nz/2+1) for uniqueness if ( ix == nx / 2 + 1 . and . k == nz / 2 + 1 ) div_u ( i , j , k ) = 0._dp end do end if ! ================================================================ ! BACKWARD PASS ! ================================================================ ! Step 1: Paired even/odd recombination for y (Dirichlet direction) if ( i <= nx_spec ) then do j = 2 , ny_spec / 2 + 1 iy = j + y_sp_st iy_rev = ny_spec - j + 2 + y_sp_st l_r = real ( div_u ( i , j , k ), kind = dp ) l_c = aimag ( div_u ( i , j , k )) r_r = real ( div_u ( i , ny_spec - j + 2 , k ), kind = dp ) r_c = aimag ( div_u ( i , ny_spec - j + 2 , k )) ! update the entry div_u ( i , j , k ) = cmplx ( & !& l_r * by ( iy ) - l_c * ay ( iy ) + r_r * ay ( iy ) + r_c * by ( iy ), & l_r * ay ( iy ) + l_c * by ( iy ) - r_r * by ( iy ) + r_c * ay ( iy ), kind = dp & ) div_u ( i , ny_spec - j + 2 , k ) = cmplx ( & !& r_r * by ( iy_rev ) - r_c * ay ( iy_rev ) + l_r * ay ( iy_rev ) + l_c * by ( iy_rev ), & r_r * ay ( iy_rev ) + r_c * by ( iy_rev ) - l_r * by ( iy_rev ) + l_c * ay ( iy_rev ), & kind = dp & ) end do end if ! Step 2: Periodic post-process in z (undo) if ( i <= nx_spec ) then do j = 1 , ny_spec iz = k div_r = real ( div_u ( i , j , k ), kind = dp ) div_c = aimag ( div_u ( i , j , k )) ! post-process in z tmp_r = div_r tmp_c = div_c div_r = tmp_r * bz ( iz ) - tmp_c * az ( iz ) div_c = tmp_c * bz ( iz ) + tmp_r * az ( iz ) if ( iz > nz / 2 + 1 ) div_r = - div_r if ( iz > nz / 2 + 1 ) div_c = - div_c ! update the entry div_u ( i , j , k ) = cmplx ( div_r , div_c , kind = dp ) end do end if end subroutine process_spectral_110 attributes ( global ) subroutine enforce_periodicity_x ( f_out , f_in , nx ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: f_out real ( dp ), device , intent ( in ), dimension (:, :, :) :: f_in integer , value , intent ( in ) :: nx integer :: i , j , k , n2 j = threadIdx % x k = blockIdx % x n2 = nx / 2 do i = 1 , n2 f_out ( i , j , k ) = f_in ( 2 * i - 1 , j , k ) end do if ( mod ( nx , 2 ) == 1 ) then ! odd-size center entry f_out ( n2 + 1 , j , k ) = f_in ( nx , j , k ) do i = n2 + 2 , nx f_out ( i , j , k ) = f_in ( 2 * nx - 2 * i + 2 , j , k ) end do else do i = n2 + 1 , nx f_out ( i , j , k ) = f_in ( 2 * nx - 2 * i + 2 , j , k ) end do end if end subroutine enforce_periodicity_x attributes ( global ) subroutine undo_periodicity_x ( f_out , f_in , nx ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: f_out real ( dp ), device , intent ( in ), dimension (:, :, :) :: f_in integer , value , intent ( in ) :: nx integer :: i , j , k , n2 j = threadIdx % x k = blockIdx % x n2 = nx / 2 do i = 1 , n2 f_out ( 2 * i - 1 , j , k ) = f_in ( i , j , k ) f_out ( 2 * i , j , k ) = f_in ( nx - i + 1 , j , k ) end do if ( mod ( nx , 2 ) == 1 ) then ! odd-size center entry f_out ( nx , j , k ) = f_in ( n2 + 1 , j , k ) end if end subroutine undo_periodicity_x attributes ( global ) subroutine enforce_periodicity_y ( f_out , f_in , ny ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: f_out real ( dp ), device , intent ( in ), dimension (:, :, :) :: f_in integer , value , intent ( in ) :: ny integer :: i , j , k , n2 i = threadIdx % x k = blockIdx % x n2 = ny / 2 do j = 1 , n2 f_out ( i , j , k ) = f_in ( i , 2 * j - 1 , k ) end do if ( mod ( ny , 2 ) == 1 ) then ! odd-size center entry f_out ( i , n2 + 1 , k ) = f_in ( i , ny , k ) do j = n2 + 2 , ny f_out ( i , j , k ) = f_in ( i , 2 * ny - 2 * j + 2 , k ) end do else do j = n2 + 1 , ny f_out ( i , j , k ) = f_in ( i , 2 * ny - 2 * j + 2 , k ) end do end if end subroutine enforce_periodicity_y attributes ( global ) subroutine undo_periodicity_y ( f_out , f_in , ny ) implicit none real ( dp ), device , intent ( out ), dimension (:, :, :) :: f_out real ( dp ), device , intent ( in ), dimension (:, :, :) :: f_in integer , value , intent ( in ) :: ny integer :: i , j , k , n2 i = threadIdx % x k = blockIdx % x n2 = ny / 2 do j = 1 , n2 f_out ( i , 2 * j - 1 , k ) = f_in ( i , j , k ) f_out ( i , 2 * j , k ) = f_in ( i , ny - j + 1 , k ) end do if ( mod ( ny , 2 ) == 1 ) then ! odd-size center entry f_out ( i , ny , k ) = f_in ( i , n2 + 1 , k ) end if end subroutine undo_periodicity_y end module m_cuda_spectral","tags":"","url":"sourcefile/spectral_processing.f90~2.html"},{"title":"distributed.f90 – x3d2","text":"This file depends on sourcefile~~distributed.f90~2~~EfferentGraph sourcefile~distributed.f90~2 distributed.f90 sourcefile~common.f90 common.f90 sourcefile~distributed.f90~2->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~distributed.f90~2~~AfferentGraph sourcefile~distributed.f90~2 distributed.f90 sourcefile~backend.f90~3 backend.f90 sourcefile~backend.f90~3->sourcefile~distributed.f90~2 sourcefile~exec_dist.f90 exec_dist.f90 sourcefile~backend.f90~3->sourcefile~exec_dist.f90 sourcefile~exec_dist.f90->sourcefile~distributed.f90~2 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~backend.f90~3 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_cuda_kernels_dist use cudafor use m_common , only : dp implicit none contains attributes ( global ) subroutine der_univ_dist ( & du , send_u_s , send_u_e , u , u_s , u_e , & n_tds , n_rhs , coeffs_s , coeffs_e , coeffs , ffr , fbc , faf & ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du , send_u_s , & send_u_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u , u_s , u_e integer , value , intent ( in ) :: n_tds , n_rhs real ( dp ), device , intent ( in ), dimension (:, :) :: coeffs_s , coeffs_e real ( dp ), device , intent ( in ), dimension (:) :: coeffs real ( dp ), device , intent ( in ), dimension (:) :: ffr , fbc , faf ! Local variables integer :: i , j , b , k , lj integer :: jm2 , jm1 , jp1 , jp2 real ( dp ) :: c_m4 , c_m3 , c_m2 , c_m1 , c_j , c_p1 , c_p2 , c_p3 , c_p4 , & temp_du , alpha , last_r i = threadIdx % x b = blockIdx % x ! store bulk coeffs in the registers c_m4 = coeffs ( 1 ); c_m3 = coeffs ( 2 ); c_m2 = coeffs ( 3 ); c_m1 = coeffs ( 4 ) c_j = coeffs ( 5 ) c_p1 = coeffs ( 6 ); c_p2 = coeffs ( 7 ); c_p3 = coeffs ( 8 ); c_p4 = coeffs ( 9 ) last_r = ffr ( 1 ) du ( i , 1 , b ) = coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) du ( i , 1 , b ) = du ( i , 1 , b ) * faf ( 1 ) du ( i , 2 , b ) = coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) du ( i , 2 , b ) = du ( i , 2 , b ) * faf ( 2 ) du ( i , 3 , b ) = coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) du ( i , 3 , b ) = ffr ( 3 ) * ( du ( i , 3 , b ) - faf ( 3 ) * du ( i , 2 , b )) du ( i , 4 , b ) = coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) du ( i , 4 , b ) = ffr ( 4 ) * ( du ( i , 4 , b ) - faf ( 3 ) * du ( i , 3 , b )) alpha = faf ( 5 ) do j = 5 , n_rhs - 4 temp_du = c_m4 * u ( i , j - 4 , b ) + c_m3 * u ( i , j - 3 , b ) & + c_m2 * u ( i , j - 2 , b ) + c_m1 * u ( i , j - 1 , b ) & + c_j * u ( i , j , b ) & + c_p1 * u ( i , j + 1 , b ) + c_p2 * u ( i , j + 2 , b ) & + c_p3 * u ( i , j + 3 , b ) + c_p4 * u ( i , j + 4 , b ) du ( i , j , b ) = ffr ( j ) * ( temp_du - alpha * du ( i , j - 1 , b )) end do j = n_rhs - 3 du ( i , j , b ) = coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n_rhs - 2 du ( i , j , b ) = coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n_rhs - 1 du ( i , j , b ) = coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) j = n_rhs du ( i , j , b ) = coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) du ( i , j , b ) = ffr ( j ) * ( du ( i , j , b ) - faf ( j ) * du ( i , j - 1 , b )) send_u_e ( i , 1 , b ) = du ( i , n_tds , b ) ! Backward pass of the hybrid algorithm do j = n_tds - 2 , 2 , - 1 du ( i , j , b ) = du ( i , j , b ) - fbc ( j ) * du ( i , j + 1 , b ) end do du ( i , 1 , b ) = last_r * ( du ( i , 1 , b ) - fbc ( 1 ) * du ( i , 2 , b )) send_u_s ( i , 1 , b ) = du ( i , 1 , b ) end subroutine der_univ_dist attributes ( global ) subroutine der_univ_subs ( du , recv_u_s , recv_u_e , & n , dist_sa , dist_sc , strch ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du real ( dp ), device , intent ( in ), dimension (:, :, :) :: recv_u_s , recv_u_e real ( dp ), device , intent ( in ), dimension (:) :: dist_sa , dist_sc , strch integer , value , intent ( in ) :: n ! Local variables integer :: i , j , b real ( dp ) :: ur , bl , recp , du_s , du_e i = threadIdx % x b = blockIdx % x ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' bl = dist_sa ( 1 ) ur = dist_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s = recp * ( du ( i , 1 , b ) - bl * recv_u_s ( i , 1 , b )) ! End ! At the end we have the 'ur', and assume 'bl' bl = dist_sc ( n ) ur = dist_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e = recp * ( du ( i , n , b ) - ur * recv_u_e ( i , 1 , b )) du ( i , 1 , b ) = du_s * strch ( 1 ) do j = 2 , n - 1 du ( i , j , b ) = ( du ( i , j , b ) - dist_sa ( j ) * du_s - dist_sc ( j ) * du_e ) * strch ( j ) end do du ( i , n , b ) = du_e * strch ( n ) end subroutine der_univ_subs attributes ( global ) subroutine transeq_3fused_dist ( & du , dud , d2u , & send_du_s , send_du_e , send_dud_s , send_dud_e , send_d2u_s , send_d2u_e , & u , u_s , u_e , v , v_s , v_e , n_tds , n_rhs , & du_coeffs_s , du_coeffs_e , du_coeffs , du_fw , du_bw , du_af , & dud_coeffs_s , dud_coeffs_e , dud_coeffs , dud_fw , dud_bw , dud_af , & d2u_coeffs_s , d2u_coeffs_e , d2u_coeffs , d2u_fw , d2u_bw , d2u_af & ) implicit none ! Arguments real ( dp ), device , intent ( out ), dimension (:, :, :) :: du , dud , d2u real ( dp ), device , intent ( out ), dimension (:, :, :) :: & send_du_s , send_du_e , send_dud_s , send_dud_e , send_d2u_s , send_d2u_e real ( dp ), device , intent ( in ), dimension (:, :, :) :: u , u_s , u_e , & v , v_s , v_e integer , value , intent ( in ) :: n_tds , n_rhs real ( dp ), device , intent ( in ) :: du_coeffs_s (:, :), du_coeffs_e (:, :), & du_coeffs (:) real ( dp ), device , intent ( in ) :: du_fw (:), du_bw (:), du_af (:) real ( dp ), device , intent ( in ) :: dud_coeffs_s (:, :), dud_coeffs_e (:, :), & dud_coeffs (:) real ( dp ), device , intent ( in ) :: dud_fw (:), dud_bw (:), dud_af (:) real ( dp ), device , intent ( in ) :: d2u_coeffs_s (:, :), d2u_coeffs_e (:, :), & d2u_coeffs (:) real ( dp ), device , intent ( in ) :: d2u_fw (:), d2u_bw (:), d2u_af (:) ! Local variables integer :: i , j , b real ( dp ) :: du_c_m4 , du_c_m3 , du_c_m2 , du_c_m1 , du_c_j , & du_c_p1 , du_c_p2 , du_c_p3 , du_c_p4 , & du_alpha , du_last_r real ( dp ) :: dud_c_m4 , dud_c_m3 , dud_c_m2 , dud_c_m1 , dud_c_j , & dud_c_p1 , dud_c_p2 , dud_c_p3 , dud_c_p4 , & dud_alpha , dud_last_r real ( dp ) :: d2u_c_m4 , d2u_c_m3 , d2u_c_m2 , d2u_c_m1 , d2u_c_j , & d2u_c_p1 , d2u_c_p2 , d2u_c_p3 , d2u_c_p4 , & d2u_alpha , d2u_last_r real ( dp ) :: temp_du , temp_dud , temp_d2u real ( dp ) :: u_m4 , u_m3 , u_m2 , u_m1 , u_j , u_p1 , u_p2 , u_p3 , u_p4 real ( dp ) :: v_m4 , v_m3 , v_m2 , v_m1 , v_j , v_p1 , v_p2 , v_p3 , v_p4 real ( dp ) :: old_du , old_dud , old_d2u i = threadIdx % x b = blockIdx % x du_last_r = du_fw ( 1 ) dud_last_r = dud_fw ( 1 ) d2u_last_r = d2u_fw ( 1 ) ! j = 1 temp_du = du_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + du_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + du_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + du_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + du_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + du_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + du_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + du_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + du_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) du ( i , 1 , b ) = temp_du * du_af ( 1 ) temp_dud = dud_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) * v_s ( i , 1 , b ) & + dud_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) * v_s ( i , 2 , b ) & + dud_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + dud_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + dud_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + dud_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + dud_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + dud_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + dud_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) * v ( i , 5 , b ) dud ( i , 1 , b ) = temp_dud * dud_af ( 1 ) temp_d2u = d2u_coeffs_s ( 1 , 1 ) * u_s ( i , 1 , b ) & + d2u_coeffs_s ( 2 , 1 ) * u_s ( i , 2 , b ) & + d2u_coeffs_s ( 3 , 1 ) * u_s ( i , 3 , b ) & + d2u_coeffs_s ( 4 , 1 ) * u_s ( i , 4 , b ) & + d2u_coeffs_s ( 5 , 1 ) * u ( i , 1 , b ) & + d2u_coeffs_s ( 6 , 1 ) * u ( i , 2 , b ) & + d2u_coeffs_s ( 7 , 1 ) * u ( i , 3 , b ) & + d2u_coeffs_s ( 8 , 1 ) * u ( i , 4 , b ) & + d2u_coeffs_s ( 9 , 1 ) * u ( i , 5 , b ) d2u ( i , 1 , b ) = temp_d2u * d2u_af ( 1 ) ! j = 2 temp_du = du_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + du_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + du_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + du_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + du_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + du_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + du_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + du_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + du_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) du ( i , 2 , b ) = temp_du * du_af ( 2 ) temp_dud = dud_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) * v_s ( i , 2 , b ) & + dud_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + dud_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + dud_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + dud_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + dud_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + dud_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + dud_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + dud_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) * v ( i , 6 , b ) dud ( i , 2 , b ) = temp_dud * dud_af ( 2 ) temp_d2u = d2u_coeffs_s ( 1 , 2 ) * u_s ( i , 2 , b ) & + d2u_coeffs_s ( 2 , 2 ) * u_s ( i , 3 , b ) & + d2u_coeffs_s ( 3 , 2 ) * u_s ( i , 4 , b ) & + d2u_coeffs_s ( 4 , 2 ) * u ( i , 1 , b ) & + d2u_coeffs_s ( 5 , 2 ) * u ( i , 2 , b ) & + d2u_coeffs_s ( 6 , 2 ) * u ( i , 3 , b ) & + d2u_coeffs_s ( 7 , 2 ) * u ( i , 4 , b ) & + d2u_coeffs_s ( 8 , 2 ) * u ( i , 5 , b ) & + d2u_coeffs_s ( 9 , 2 ) * u ( i , 6 , b ) d2u ( i , 2 , b ) = temp_d2u * d2u_af ( 2 ) ! j = 3 temp_du = du_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + du_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + du_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + du_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + du_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + du_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + du_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + du_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + du_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) du ( i , 3 , b ) = du_fw ( 3 ) * ( temp_du - du_af ( 3 ) * du ( i , 2 , b )) temp_dud = dud_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) * v_s ( i , 3 , b ) & + dud_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + dud_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + dud_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + dud_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + dud_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + dud_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + dud_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) * v ( i , 6 , b ) & + dud_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) * v ( i , 7 , b ) dud ( i , 3 , b ) = dud_fw ( 3 ) * ( temp_dud - dud_af ( 3 ) * dud ( i , 2 , b )) temp_d2u = d2u_coeffs_s ( 1 , 3 ) * u_s ( i , 3 , b ) & + d2u_coeffs_s ( 2 , 3 ) * u_s ( i , 4 , b ) & + d2u_coeffs_s ( 3 , 3 ) * u ( i , 1 , b ) & + d2u_coeffs_s ( 4 , 3 ) * u ( i , 2 , b ) & + d2u_coeffs_s ( 5 , 3 ) * u ( i , 3 , b ) & + d2u_coeffs_s ( 6 , 3 ) * u ( i , 4 , b ) & + d2u_coeffs_s ( 7 , 3 ) * u ( i , 5 , b ) & + d2u_coeffs_s ( 8 , 3 ) * u ( i , 6 , b ) & + d2u_coeffs_s ( 9 , 3 ) * u ( i , 7 , b ) d2u ( i , 3 , b ) = d2u_fw ( 3 ) * ( temp_d2u - d2u_af ( 3 ) * d2u ( i , 2 , b )) ! j = 4 temp_du = du_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + du_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + du_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + du_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + du_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + du_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + du_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + du_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + du_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) du ( i , 4 , b ) = du_fw ( 4 ) * ( temp_du - du_af ( 3 ) * du ( i , 3 , b )) temp_dud = dud_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) * v_s ( i , 4 , b ) & + dud_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) * v ( i , 1 , b ) & + dud_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) * v ( i , 2 , b ) & + dud_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) * v ( i , 3 , b ) & + dud_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) * v ( i , 4 , b ) & + dud_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) * v ( i , 5 , b ) & + dud_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) * v ( i , 6 , b ) & + dud_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) * v ( i , 7 , b ) & + dud_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) * v ( i , 8 , b ) dud ( i , 4 , b ) = dud_fw ( 4 ) * ( temp_dud - dud_af ( 3 ) * dud ( i , 3 , b )) temp_d2u = d2u_coeffs_s ( 1 , 4 ) * u_s ( i , 4 , b ) & + d2u_coeffs_s ( 2 , 4 ) * u ( i , 1 , b ) & + d2u_coeffs_s ( 3 , 4 ) * u ( i , 2 , b ) & + d2u_coeffs_s ( 4 , 4 ) * u ( i , 3 , b ) & + d2u_coeffs_s ( 5 , 4 ) * u ( i , 4 , b ) & + d2u_coeffs_s ( 6 , 4 ) * u ( i , 5 , b ) & + d2u_coeffs_s ( 7 , 4 ) * u ( i , 6 , b ) & + d2u_coeffs_s ( 8 , 4 ) * u ( i , 7 , b ) & + d2u_coeffs_s ( 9 , 4 ) * u ( i , 8 , b ) d2u ( i , 4 , b ) = d2u_fw ( 4 ) * ( temp_d2u - d2u_af ( 3 ) * d2u ( i , 3 , b )) du_alpha = du_af ( 5 ) dud_alpha = dud_af ( 5 ) d2u_alpha = d2u_af ( 5 ) ! store bulk coeffs in the registers du_c_m4 = du_coeffs ( 1 ); du_c_m3 = du_coeffs ( 2 ) du_c_m2 = du_coeffs ( 3 ); du_c_m1 = du_coeffs ( 4 ) du_c_j = du_coeffs ( 5 ) du_c_p1 = du_coeffs ( 6 ); du_c_p2 = du_coeffs ( 7 ) du_c_p3 = du_coeffs ( 8 ); du_c_p4 = du_coeffs ( 9 ) dud_c_m4 = dud_coeffs ( 1 ); dud_c_m3 = dud_coeffs ( 2 ) dud_c_m2 = dud_coeffs ( 3 ); dud_c_m1 = dud_coeffs ( 4 ) dud_c_j = dud_coeffs ( 5 ) dud_c_p1 = dud_coeffs ( 6 ); dud_c_p2 = dud_coeffs ( 7 ) dud_c_p3 = dud_coeffs ( 8 ); dud_c_p4 = dud_coeffs ( 9 ) d2u_c_m4 = d2u_coeffs ( 1 ); d2u_c_m3 = d2u_coeffs ( 2 ) d2u_c_m2 = d2u_coeffs ( 3 ); d2u_c_m1 = d2u_coeffs ( 4 ) d2u_c_j = d2u_coeffs ( 5 ) d2u_c_p1 = d2u_coeffs ( 6 ); d2u_c_p2 = d2u_coeffs ( 7 ) d2u_c_p3 = d2u_coeffs ( 8 ); d2u_c_p4 = d2u_coeffs ( 9 ) ! It is better to access d?(i, j - 1, b) via old_d? old_du = du ( i , 4 , b ) old_dud = dud ( i , 4 , b ) old_d2u = d2u ( i , 4 , b ) ! Populate registers with the u and v stencils u_m4 = u ( i , 1 , b ); u_m3 = u ( i , 2 , b ) u_m2 = u ( i , 3 , b ); u_m1 = u ( i , 4 , b ) u_j = u ( i , 5 , b ); u_p1 = u ( i , 6 , b ) u_p2 = u ( i , 7 , b ); u_p3 = u ( i , 8 , b ) v_m4 = v ( i , 1 , b ); v_m3 = v ( i , 2 , b ) v_m2 = v ( i , 3 , b ); v_m1 = v ( i , 4 , b ) v_j = v ( i , 5 , b ); v_p1 = v ( i , 6 , b ) v_p2 = v ( i , 7 , b ); v_p3 = v ( i , 8 , b ) do j = 5 , n_rhs - 4 u_p4 = u ( i , j + 4 , b ); v_p4 = v ( i , j + 4 , b ) ! du temp_du = du_c_m4 * u_m4 + du_c_m3 * u_m3 + du_c_m2 * u_m2 + du_c_m1 * u_m1 & + du_c_j * u_j & + du_c_p1 * u_p1 + du_c_p2 * u_p2 + du_c_p3 * u_p3 + du_c_p4 * u_p4 du ( i , j , b ) = du_fw ( j ) * ( temp_du - du_alpha * old_du ) old_du = du ( i , j , b ) ! dud temp_dud = dud_c_m4 * u_m4 * v_m4 + dud_c_m3 * u_m3 * v_m3 & + dud_c_m2 * u_m2 * v_m2 + dud_c_m1 * u_m1 * v_m1 & + dud_c_j * u_j * v_j & + dud_c_p1 * u_p1 * v_p1 + dud_c_p2 * u_p2 * v_p2 & + dud_c_p3 * u_p3 * v_p3 + dud_c_p4 * u_p4 * v_p4 dud ( i , j , b ) = dud_fw ( j ) * ( temp_dud - dud_alpha * old_dud ) old_dud = dud ( i , j , b ) ! d2u temp_d2u = d2u_c_m4 * u_m4 + d2u_c_m3 * u_m3 & + d2u_c_m2 * u_m2 + d2u_c_m1 * u_m1 & + d2u_c_j * u_j & + d2u_c_p1 * u_p1 + d2u_c_p2 * u_p2 & + d2u_c_p3 * u_p3 + d2u_c_p4 * u_p4 d2u ( i , j , b ) = d2u_fw ( j ) * ( temp_d2u - d2u_alpha * old_d2u ) old_d2u = d2u ( i , j , b ) ! Prepare registers for the next step u_m4 = u_m3 ; u_m3 = u_m2 ; u_m2 = u_m1 ; u_m1 = u_j u_j = u_p1 ; u_p1 = u_p2 ; u_p2 = u_p3 ; u_p3 = u_p4 v_m4 = v_m3 ; v_m3 = v_m2 ; v_m2 = v_m1 ; v_m1 = v_j v_j = v_p1 ; v_p1 = v_p2 ; v_p2 = v_p3 ; v_p3 = v_p4 end do j = n_rhs - 3 temp_du = du_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + du_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + du_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + du_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + du_coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + du_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + du_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + du_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + du_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) du ( i , j , b ) = du_fw ( j ) * ( temp_du - du_af ( j ) * du ( i , j - 1 , b )) temp_dud = dud_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + dud_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + dud_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + dud_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + dud_coeffs_e ( 5 , 1 ) * u ( i , j , b ) * v ( i , j , b ) & + dud_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + dud_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) * v ( i , j + 2 , b ) & + dud_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) * v ( i , j + 3 , b ) & + dud_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) dud ( i , j , b ) = dud_fw ( j ) * ( temp_dud - dud_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2u_coeffs_e ( 1 , 1 ) * u ( i , j - 4 , b ) & + d2u_coeffs_e ( 2 , 1 ) * u ( i , j - 3 , b ) & + d2u_coeffs_e ( 3 , 1 ) * u ( i , j - 2 , b ) & + d2u_coeffs_e ( 4 , 1 ) * u ( i , j - 1 , b ) & + d2u_coeffs_e ( 5 , 1 ) * u ( i , j , b ) & + d2u_coeffs_e ( 6 , 1 ) * u ( i , j + 1 , b ) & + d2u_coeffs_e ( 7 , 1 ) * u ( i , j + 2 , b ) & + d2u_coeffs_e ( 8 , 1 ) * u ( i , j + 3 , b ) & + d2u_coeffs_e ( 9 , 1 ) * u_e ( i , 1 , b ) d2u ( i , j , b ) = d2u_fw ( j ) * ( temp_d2u - d2u_af ( j ) * d2u ( i , j - 1 , b )) j = n_rhs - 2 temp_du = du_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + du_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + du_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + du_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + du_coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + du_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + du_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + du_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + du_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) du ( i , j , b ) = du_fw ( j ) * ( temp_du - du_af ( j ) * du ( i , j - 1 , b )) temp_dud = dud_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + dud_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + dud_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + dud_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + dud_coeffs_e ( 5 , 2 ) * u ( i , j , b ) * v ( i , j , b ) & + dud_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + dud_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) * v ( i , j + 2 , b ) & + dud_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + dud_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) dud ( i , j , b ) = dud_fw ( j ) * ( temp_dud - dud_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2u_coeffs_e ( 1 , 2 ) * u ( i , j - 4 , b ) & + d2u_coeffs_e ( 2 , 2 ) * u ( i , j - 3 , b ) & + d2u_coeffs_e ( 3 , 2 ) * u ( i , j - 2 , b ) & + d2u_coeffs_e ( 4 , 2 ) * u ( i , j - 1 , b ) & + d2u_coeffs_e ( 5 , 2 ) * u ( i , j , b ) & + d2u_coeffs_e ( 6 , 2 ) * u ( i , j + 1 , b ) & + d2u_coeffs_e ( 7 , 2 ) * u ( i , j + 2 , b ) & + d2u_coeffs_e ( 8 , 2 ) * u_e ( i , 1 , b ) & + d2u_coeffs_e ( 9 , 2 ) * u_e ( i , 2 , b ) d2u ( i , j , b ) = d2u_fw ( j ) * ( temp_d2u - d2u_af ( j ) * d2u ( i , j - 1 , b )) j = n_rhs - 1 temp_du = du_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + du_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + du_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + du_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + du_coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + du_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + du_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + du_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + du_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) du ( i , j , b ) = du_fw ( j ) * ( temp_du - du_af ( j ) * du ( i , j - 1 , b )) temp_dud = dud_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + dud_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + dud_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + dud_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + dud_coeffs_e ( 5 , 3 ) * u ( i , j , b ) * v ( i , j , b ) & + dud_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) * v ( i , j + 1 , b ) & + dud_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + dud_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) & + dud_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) * v_e ( i , 3 , b ) dud ( i , j , b ) = dud_fw ( j ) * ( temp_dud - dud_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2u_coeffs_e ( 1 , 3 ) * u ( i , j - 4 , b ) & + d2u_coeffs_e ( 2 , 3 ) * u ( i , j - 3 , b ) & + d2u_coeffs_e ( 3 , 3 ) * u ( i , j - 2 , b ) & + d2u_coeffs_e ( 4 , 3 ) * u ( i , j - 1 , b ) & + d2u_coeffs_e ( 5 , 3 ) * u ( i , j , b ) & + d2u_coeffs_e ( 6 , 3 ) * u ( i , j + 1 , b ) & + d2u_coeffs_e ( 7 , 3 ) * u_e ( i , 1 , b ) & + d2u_coeffs_e ( 8 , 3 ) * u_e ( i , 2 , b ) & + d2u_coeffs_e ( 9 , 3 ) * u_e ( i , 3 , b ) d2u ( i , j , b ) = d2u_fw ( j ) * ( temp_d2u - d2u_af ( j ) * d2u ( i , j - 1 , b )) j = n_rhs temp_du = du_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + du_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + du_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + du_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + du_coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + du_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + du_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + du_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + du_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) du ( i , j , b ) = du_fw ( j ) * ( temp_du - du_af ( j ) * du ( i , j - 1 , b )) temp_dud = dud_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) * v ( i , j - 4 , b ) & + dud_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) * v ( i , j - 3 , b ) & + dud_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) * v ( i , j - 2 , b ) & + dud_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) * v ( i , j - 1 , b ) & + dud_coeffs_e ( 5 , 4 ) * u ( i , j , b ) * v ( i , j , b ) & + dud_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) * v_e ( i , 1 , b ) & + dud_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) * v_e ( i , 2 , b ) & + dud_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) * v_e ( i , 3 , b ) & + dud_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) * v_e ( i , 4 , b ) dud ( i , j , b ) = dud_fw ( j ) * ( temp_dud - dud_af ( j ) * dud ( i , j - 1 , b )) temp_d2u = d2u_coeffs_e ( 1 , 4 ) * u ( i , j - 4 , b ) & + d2u_coeffs_e ( 2 , 4 ) * u ( i , j - 3 , b ) & + d2u_coeffs_e ( 3 , 4 ) * u ( i , j - 2 , b ) & + d2u_coeffs_e ( 4 , 4 ) * u ( i , j - 1 , b ) & + d2u_coeffs_e ( 5 , 4 ) * u ( i , j , b ) & + d2u_coeffs_e ( 6 , 4 ) * u_e ( i , 1 , b ) & + d2u_coeffs_e ( 7 , 4 ) * u_e ( i , 2 , b ) & + d2u_coeffs_e ( 8 , 4 ) * u_e ( i , 3 , b ) & + d2u_coeffs_e ( 9 , 4 ) * u_e ( i , 4 , b ) d2u ( i , j , b ) = d2u_fw ( j ) * ( temp_d2u - d2u_af ( j ) * d2u ( i , j - 1 , b )) send_du_e ( i , 1 , b ) = du ( i , n_tds , b ) send_dud_e ( i , 1 , b ) = dud ( i , n_tds , b ) send_d2u_e ( i , 1 , b ) = d2u ( i , n_tds , b ) ! Backward pass of the hybrid algorithm do j = n_tds - 2 , 2 , - 1 du ( i , j , b ) = du ( i , j , b ) - du_bw ( j ) * du ( i , j + 1 , b ) dud ( i , j , b ) = dud ( i , j , b ) - dud_bw ( j ) * dud ( i , j + 1 , b ) d2u ( i , j , b ) = d2u ( i , j , b ) - d2u_bw ( j ) * d2u ( i , j + 1 , b ) end do du ( i , 1 , b ) = du_last_r * ( du ( i , 1 , b ) - du_bw ( 1 ) * du ( i , 2 , b )) dud ( i , 1 , b ) = dud_last_r * ( dud ( i , 1 , b ) - dud_bw ( 1 ) * dud ( i , 2 , b )) d2u ( i , 1 , b ) = d2u_last_r * ( d2u ( i , 1 , b ) - d2u_bw ( 1 ) * d2u ( i , 2 , b )) send_du_s ( i , 1 , b ) = du ( i , 1 , b ) send_dud_s ( i , 1 , b ) = dud ( i , 1 , b ) send_d2u_s ( i , 1 , b ) = d2u ( i , 1 , b ) end subroutine transeq_3fused_dist attributes ( global ) subroutine transeq_3fused_subs ( & r_du , conv , dud , d2u , & recv_du_s , recv_du_e , recv_dud_s , recv_dud_e , recv_d2u_s , recv_d2u_e , & n , nu , du_sa , du_sc , du_strch , dud_sa , dud_sc , dud_strch , & d2u_sa , d2u_sc , d2u_strch , d2u_strch_cor & ) implicit none ! Arguments !> The result array, it stores 'du' first then its overwritten real ( dp ), device , intent ( inout ), dimension (:, :, :) :: r_du real ( dp ), device , intent ( in ), dimension (:, :, :) :: conv , dud , d2u real ( dp ), device , intent ( in ), dimension (:, :, :) :: & recv_du_s , recv_du_e , recv_dud_s , recv_dud_e , recv_d2u_s , recv_d2u_e integer , value , intent ( in ) :: n real ( dp ), value , intent ( in ) :: nu real ( dp ), device , intent ( in ), dimension (:) :: du_sa , du_sc , du_strch , & dud_sa , dud_sc , dud_strch , & d2u_sa , d2u_sc , d2u_strch , & d2u_strch_cor ! Local variables integer :: i , j , b real ( dp ) :: ur , bl , recp real ( dp ) :: du_temp , dud_temp , d2u_temp real ( dp ) :: du_s , du_e , dud_s , dud_e , d2u_s , d2u_e i = threadIdx % x b = blockIdx % x ! A small trick we do here is valid for symmetric Toeplitz matrices. ! In our case our matrices satisfy this criteria in the (5:n-4) region ! and as long as a rank has around at least 20 entries the assumptions ! we make here are perfectly valid. ! bl is the bottom left entry in the 2x2 matrix ! ur is the upper right entry in the 2x2 matrix ! Start ! At the start we have the 'bl', and assume 'ur' ! first derivative bl = du_sa ( 1 ) ur = du_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) du_s = recp * ( r_du ( i , 1 , b ) - bl * recv_du_s ( i , 1 , b )) ! first derivative (u*v) bl = dud_sa ( 1 ) ur = dud_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) dud_s = recp * ( dud ( i , 1 , b ) - bl * recv_dud_s ( i , 1 , b )) ! second derivative bl = d2u_sa ( 1 ) ur = d2u_sa ( 1 ) recp = 1._dp / ( 1._dp - ur * bl ) d2u_s = recp * ( d2u ( i , 1 , b ) - bl * recv_d2u_s ( i , 1 , b )) ! End ! At the end we have the 'ur', and assume 'bl' ! first derivative bl = du_sc ( n ) ur = du_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) du_e = recp * ( r_du ( i , n , b ) - ur * recv_du_e ( i , 1 , b )) bl = dud_sc ( n ) ur = dud_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) dud_e = recp * ( dud ( i , n , b ) - ur * recv_dud_e ( i , 1 , b )) ! second derivative bl = d2u_sc ( n ) ur = d2u_sc ( n ) recp = 1._dp / ( 1._dp - ur * bl ) d2u_e = recp * ( d2u ( i , n , b ) - ur * recv_d2u_e ( i , 1 , b )) ! final substitution r_du ( i , 1 , b ) = - 0.5_dp * ( conv ( i , 1 , b ) * du_s * du_strch ( 1 ) & + dud_s * dud_strch ( 1 )) & + nu * ( d2u_s * d2u_strch ( 1 ) & + du_s * du_strch ( 1 ) * d2u_strch_cor ( 1 )) do j = 2 , n - 1 du_temp = ( r_du ( i , j , b ) - du_sa ( j ) * du_s - du_sc ( j ) * du_e ) * du_strch ( j ) dud_temp = ( dud ( i , j , b ) - dud_sa ( j ) * dud_s - dud_sc ( j ) * dud_e ) & * dud_strch ( j ) d2u_temp = ( d2u ( i , j , b ) - d2u_sa ( j ) * d2u_s - d2u_sc ( j ) * d2u_e ) & * d2u_strch ( j ) + du_temp * d2u_strch_cor ( j ) r_du ( i , j , b ) = - 0.5_dp * ( conv ( i , j , b ) * du_temp + dud_temp ) + nu * d2u_temp end do r_du ( i , n , b ) = - 0.5_dp * ( conv ( i , n , b ) * du_e * du_strch ( n ) & + dud_e * dud_strch ( n )) & + nu * ( d2u_e * d2u_strch ( n ) & + du_s * du_strch ( n ) * d2u_strch_cor ( n )) end subroutine transeq_3fused_subs end module m_cuda_kernels_dist","tags":"","url":"sourcefile/distributed.f90~2.html"},{"title":"io_base.f90 – x3d2","text":"This file depends on sourcefile~~io_base.f90~~EfferentGraph sourcefile~io_base.f90 io_base.f90 sourcefile~common.f90 common.f90 sourcefile~io_base.f90->sourcefile~common.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~io_base.f90~~AfferentGraph sourcefile~io_base.f90 io_base.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~io_base.f90 sourcefile~io.f90~2 io.f90 sourcefile~io.f90~2->sourcefile~io_base.f90 sourcefile~io_field_utils.f90 io_field_utils.f90 sourcefile~io_field_utils.f90->sourcefile~io_base.f90 sourcefile~solver.f90 solver.f90 sourcefile~io_field_utils.f90->sourcefile~solver.f90 sourcefile~io_session.f90 io_session.f90 sourcefile~io_session.f90->sourcefile~io_base.f90 sourcefile~io_session.f90->sourcefile~io.f90 sourcefile~checkpoint_manager.f90 checkpoint_manager.f90 sourcefile~checkpoint_manager.f90->sourcefile~io.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_field_utils.f90 sourcefile~checkpoint_manager.f90->sourcefile~io_session.f90 sourcefile~checkpoint_manager.f90->sourcefile~solver.f90 sourcefile~ibm.f90 ibm.f90 sourcefile~ibm.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90 snapshot_manager.f90 sourcefile~snapshot_manager.f90->sourcefile~io.f90 sourcefile~snapshot_manager.f90->sourcefile~io_field_utils.f90 sourcefile~snapshot_manager.f90->sourcefile~io_session.f90 sourcefile~snapshot_manager.f90->sourcefile~solver.f90 sourcefile~io_manager.f90 io_manager.f90 sourcefile~io_manager.f90->sourcefile~checkpoint_manager.f90 sourcefile~io_manager.f90->sourcefile~snapshot_manager.f90 sourcefile~io_manager.f90->sourcefile~solver.f90 sourcefile~solver.f90->sourcefile~ibm.f90 sourcefile~base_case.f90 base_case.f90 sourcefile~base_case.f90->sourcefile~io_manager.f90 sourcefile~base_case.f90->sourcefile~solver.f90 sourcefile~channel.f90 channel.f90 sourcefile~channel.f90->sourcefile~solver.f90 sourcefile~channel.f90->sourcefile~base_case.f90 sourcefile~cylinder.f90 cylinder.f90 sourcefile~cylinder.f90->sourcefile~solver.f90 sourcefile~cylinder.f90->sourcefile~base_case.f90 sourcefile~generic.f90 generic.f90 sourcefile~generic.f90->sourcefile~solver.f90 sourcefile~generic.f90->sourcefile~base_case.f90 sourcefile~tgv.f90 tgv.f90 sourcefile~tgv.f90->sourcefile~solver.f90 sourcefile~tgv.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90 xcompact.f90 sourcefile~xcompact.f90->sourcefile~base_case.f90 sourcefile~xcompact.f90->sourcefile~channel.f90 sourcefile~xcompact.f90->sourcefile~cylinder.f90 sourcefile~xcompact.f90->sourcefile~generic.f90 sourcefile~xcompact.f90->sourcefile~tgv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module m_io_base !! @brief Provides the abstract base types and interfaces for the session-based !! I/O architecture. !! !! @details This internal module defines the fundamental building blocks of !! the I/O system. It establishes a polymorphic layer that allows the !! high-level user session to interact with various I/O backends through a !! consistent interface. !! !! The architecture is designed in distinct layers: !! User code !! - interacts only with the Session layer !! !! Session layer (`m_io_session`) !! - manages all I/O complexity (file handles, state, etc.) !! - instantiates the I/O backend selected at compile-time !! - provides `reader_session_t` and `writer_session_t` for users !! !! Backend layer (`m_io_backend`) !! - concrete implementation of an I/O backed (e.g., ADIOS2) !! - extends the abstract base types defined in this module !! !! Base layer (`m_io_base`, this module) !! - provides abstract `reader_base_t` and `writer_base_t` types !! - enforces a consistent interface for all backends !! !! @note This is an internal module and should not be used directly by users. !! The sole public interface for I/O is the high-level session API provided in !! `m_io_session`. use m_common , only : dp , i8 implicit none private public :: io_reader_t , io_writer_t , io_file_t public :: io_mode_read , io_mode_write integer , parameter :: io_mode_read = 1 integer , parameter :: io_mode_write = 2 !> Base file handle for I/O operations type :: io_file_t contains procedure :: close => base_close procedure :: begin_step => base_begin_step procedure :: end_step => base_end_step procedure :: is_file_functional => base_is_file_functional end type io_file_t !> Base I/O reader type for polymorphic usage type :: io_reader_t contains procedure :: init => base_reader_init procedure :: open => base_reader_open procedure :: finalise => base_reader_finalise ! Generic interfaces for session usage generic :: read_data => read_data_i8 , read_data_integer , read_data_real , & read_data_array_3d procedure :: read_data_i8 procedure :: read_data_integer procedure :: read_data_real procedure :: read_data_array_3d end type io_reader_t !> Base I/O writer type for polymorphic usage type :: io_writer_t contains procedure :: init => base_writer_init procedure :: open => base_writer_open procedure :: finalise => base_writer_finalise generic :: write_data => write_data_i8 , write_data_integer , & write_data_real , & write_data_array_3d procedure :: write_data_i8 procedure :: write_data_integer procedure :: write_data_real procedure :: write_data_array_3d generic :: write_attribute => write_attribute_string , & write_attribute_array_1d_real procedure :: write_attribute_string procedure :: write_attribute_array_1d_real end type io_writer_t contains ! Base implementations (should be overridden by concrete types) subroutine base_close ( self ) class ( io_file_t ), intent ( inout ) :: self error stop \"base_close should not be called - & & use concrete implementation\" end subroutine base_close subroutine base_begin_step ( self ) class ( io_file_t ), intent ( inout ) :: self error stop \"base_begin_step should not be called - & & use concrete implementation\" end subroutine base_begin_step subroutine base_end_step ( self ) class ( io_file_t ), intent ( inout ) :: self error stop \"base_end_step should not be called - & & use concrete implementation\" end subroutine base_end_step subroutine base_reader_init ( self , comm , name ) class ( io_reader_t ), intent ( inout ) :: self integer , intent ( in ) :: comm character ( len =* ), intent ( in ) :: name error stop \"base_reader_init should not be called - & & use concrete implementation\" end subroutine base_reader_init function base_reader_open ( self , filename , mode , comm ) result ( file_handle ) class ( io_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: mode integer , intent ( in ) :: comm class ( io_file_t ), allocatable :: file_handle type ( io_file_t ) :: temp_handle file_handle = temp_handle error stop \"base_reader_open should not be called - & & use concrete implementation\" end function base_reader_open subroutine base_reader_finalise ( self ) class ( io_reader_t ), intent ( inout ) :: self error stop \"base_reader_finalise should not be called - & & use concrete implementation\" end subroutine base_reader_finalise subroutine base_writer_init ( self , comm , name ) class ( io_writer_t ), intent ( inout ) :: self integer , intent ( in ) :: comm character ( len =* ), intent ( in ) :: name error stop \"base_writer_init should not be called - & & use concrete implementation\" end subroutine base_writer_init function base_writer_open ( self , filename , mode , comm ) result ( file_handle ) class ( io_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: mode integer , intent ( in ) :: comm class ( io_file_t ), allocatable :: file_handle type ( io_file_t ) :: temp_handle file_handle = temp_handle error stop \"base_writer_open should not be called - & & use concrete implementation\" end function base_writer_open subroutine base_writer_finalise ( self ) class ( io_writer_t ), intent ( inout ) :: self error stop \"base_writer_finalise should not be called - & & use concrete implementation\" end subroutine base_writer_finalise function base_is_file_functional ( self ) result ( is_functional ) class ( io_file_t ), intent ( in ) :: self logical :: is_functional is_functional = . true . end function base_is_file_functional ! Base read implementations subroutine read_data_i8 ( self , variable_name , value , file_handle ) class ( io_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer ( i8 ), intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle error stop \"read_data_i8 should not be called - & & use concrete implementation\" end subroutine read_data_i8 subroutine read_data_integer ( self , variable_name , value , file_handle ) class ( io_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer , intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle error stop \"read_data_integer should not be called - & & use concrete implementation\" end subroutine read_data_integer subroutine read_data_real ( self , variable_name , value , file_handle ) class ( io_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( out ) :: value class ( io_file_t ), intent ( inout ) :: file_handle error stop \"read_data_real should not be called - & & use concrete implementation\" end subroutine read_data_real subroutine read_data_array_3d ( & self , variable_name , array , file_handle , & shape_dims , start_dims , count_dims & ) class ( io_reader_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( inout ) :: array (:, :, :) class ( io_file_t ), intent ( inout ) :: file_handle integer ( i8 ), intent ( in ), optional :: shape_dims ( 3 ) integer ( i8 ), intent ( in ), optional :: start_dims ( 3 ) integer ( i8 ), intent ( in ), optional :: count_dims ( 3 ) error stop \"read_data_array_3d should not be called - & & use concrete implementation\" end subroutine read_data_array_3d ! Base write implementations subroutine write_data_i8 ( self , variable_name , value , file_handle ) class ( io_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer ( i8 ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle error stop \"write_data_i8 should not be called - & & use concrete implementation\" end subroutine write_data_i8 subroutine write_data_integer ( self , variable_name , value , file_handle ) class ( io_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name integer , intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle error stop \"write_data_integer should not be called - & & use concrete implementation\" end subroutine write_data_integer subroutine write_data_real ( self , variable_name , value , file_handle , use_sp ) class ( io_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle logical , intent ( in ), optional :: use_sp error stop \"write_data_real should not be called - & & use concrete implementation\" end subroutine write_data_real subroutine write_data_array_3d ( & self , variable_name , array , file_handle , & shape_dims , start_dims , count_dims , use_sp & ) class ( io_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: variable_name real ( dp ), intent ( in ) :: array (:, :, :) class ( io_file_t ), intent ( inout ) :: file_handle integer ( i8 ), intent ( in ) :: shape_dims ( 3 ) integer ( i8 ), intent ( in ) :: start_dims ( 3 ) integer ( i8 ), intent ( in ) :: count_dims ( 3 ) logical , intent ( in ), optional :: use_sp error stop \"write_data_array_3d should not be called - & & use concrete implementation\" end subroutine write_data_array_3d subroutine write_attribute_string ( self , attribute_name , value , file_handle ) class ( io_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: attribute_name character ( len =* ), intent ( in ) :: value class ( io_file_t ), intent ( inout ) :: file_handle error stop \"write_attribute_string should not be called - & & use concrete implementation\" end subroutine write_attribute_string subroutine write_attribute_array_1d_real ( & self , attribute_name , values , file_handle & ) class ( io_writer_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: attribute_name real ( dp ), intent ( in ) :: values (:) class ( io_file_t ), intent ( inout ) :: file_handle error stop \"write_attribute_array_1d_real should not be called - & & use concrete implementation\" end subroutine write_attribute_array_1d_real end module m_io_base","tags":"","url":"sourcefile/io_base.f90.html"}]}